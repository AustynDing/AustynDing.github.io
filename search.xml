<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Chapter01 - 绪言</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter01%20-%20%E7%BB%AA%E8%A8%80/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter01%20-%20%E7%BB%AA%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>数据模型是对现实世界数据特征的抽象，用以抽象、表示和处理现实世界中的数据和信息</p><ul><li>数据模型应满足三方面要求<ul><li>能比较真实地模拟现实世界</li><li>容易为人所理解</li><li>便于在计算机上实现</li></ul></li><li>数据模型是数据库系统的核心和基础</li></ul><h2 id="概念-x2F-逻辑-x2F-物理模型"><a href="#概念-x2F-逻辑-x2F-物理模型" class="headerlink" title="概念&#x2F;逻辑&#x2F;物理模型"></a>概念&#x2F;逻辑&#x2F;物理模型</h2><p>概念模型，也称信息模型</p><ul><li>按用户的观点来对数据和信息建模，用于数据库设计</li></ul><p>逻辑模型</p><ul><li>按计算机系统的观点对数据建模，用于DBMS实现</li><li>主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。</li></ul><p>物理模型</p><ul><li>是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676530559189-1ed91a48-52e5-4a49-b468-cddda16ecaf3.png" alt="image.png"></p><h3 id="完整性约束条件"><a href="#完整性约束条件" class="headerlink" title="完整性约束条件"></a>完整性约束条件</h3><p>数据的完整性约束条件，一组完整性规则的集合</p><ul><li>完整性规则：给定的数据模型中数据及其联系所具有的<strong>制约和依存规则</strong></li><li>用以限定符合数据模型的数据库状态以及状态的变化，以<strong>保证数据的正确、有效和相容</strong></li></ul><p>数据模型对完整性约束条件的定义</p><ul><li>反映和规定必须遵守的<strong>基本的通用的完整性约束条件</strong>。</li><li>提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的<strong>特定的语义约束条件</strong>。</li></ul><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>概念模型的用途</p><ul><li>概念模型用于信息世界的建模</li><li>是现实世界到机器世界的一个中间层次</li><li>是数据库设计的有力工具</li><li>数据库设计人员和用户之间进行交流的语言</li></ul><p>对概念模型的基本要求</p><ul><li>较强的语义表达能力</li><li>简单、清晰、易于用户（非IT从业人员）理解</li></ul><h3 id="信息世界中的基本概念"><a href="#信息世界中的基本概念" class="headerlink" title="信息世界中的基本概念"></a>信息世界中的基本概念</h3><p><strong>实体（Entity</strong></p><ul><li>客观存在并可相互区别的事物称为实体。</li><li>可以是具体的人、事、物或抽象的概念。</li></ul><p><strong>属性（Attribute）</strong></p><ul><li>实体所具有的某一特性称为属性。</li><li>一个实体可以由若干个属性来刻画。</li></ul><p><strong>码（Key</strong>） <strong>唯一标识实体的属性集称为码。</strong><br />属性相同的就是同一个实体。一个属性的集合就是一个实体。<br /><code>key</code>是属性的一部分，但是唯一标识实体。<code>key</code>一样的就是同一个实体。类比：身份证号<br /><code>key</code>可以是单一的属性，也可以是一个集合（足以区分不同实体的属性集合）。<br />每一个实体都有<code>key</code></p><p><strong>实体型（Entity Type）</strong> </p><ul><li>用实体名及其属性名集合来抽象和刻画<strong>同类实体</strong>称为实体型</li></ul><p><strong>实体集（Entity Set）</strong></p><ul><li>同一类型实体的集合称为实体集</li></ul><p><strong>联系（Relationship）</strong></p><ul><li><strong>现实世界</strong>中事物内部以及事物之间的<strong>联系</strong>在信息世界中<strong>反映</strong>为实体（型）内部的联系和实体（型）之间的<strong>联系</strong>。</li></ul><p>实体型≈实体集</p><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><h3 id="实体之间的联系"><a href="#实体之间的联系" class="headerlink" title="实体之间的联系"></a>实体之间的联系</h3><p>实体之间的联系通常是指不同实体集之间的联系<br />实体之间的联系有一对一、一对多和多对多等多种类型<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676530202898-e9d84b19-fb33-40de-9104-75a22e8b2a4e.png" alt="image.png"><br>一对一：一位同学<strong>至多拥有</strong>一张学生卡<br />一对多：一个行政班拥有多名同学，一个同学最多归属一个行政班<br />多对多：一个同学可以选n门课，一门课可以有m个同学</p><h3 id="实体内部的联系"><a href="#实体内部的联系" class="headerlink" title="实体内部的联系"></a>实体内部的联系</h3><p>实体内部的联系通常是指组成实体的各属性之间的联系<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676531681995-ab17e78c-6051-4241-853d-ce534eb24117.png" alt="image.png"></p><ul><li>一对一：配偶关系</li></ul><h3 id="实体-联系方法-ER模型"><a href="#实体-联系方法-ER模型" class="headerlink" title="实体-联系方法 ER模型"></a>实体-联系方法 ER模型</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676531391468-c3df5a78-52bf-43fb-b4c6-759ebc1bd713.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676531464323-e416ce9a-5997-4cef-bb47-b16f09bec4bd.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676531809872-0eb8eb25-4134-4548-9595-75cb77b858f4.png" alt="image.png"><br>联系建立了两个实体，让联系也包含了属性。<strong>“成绩”隶属于联系“选修”。选一次课，就会产生一次成绩。所以成绩隶属于联系“选修”</strong></p><h2 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h2><p>逻辑模型作为接口，物理模型作为载体，在外面封装一层应用的壳<br />如何“多快好省”地将信息世界转换为机器世界？<br />基本问题，如何在机器世界中表达“低层”数据结构和“高层”数据结构？</p><ul><li>方案1：尽量独立于应用层，采用“中立”的方式表达概念模型。面向应用层的壳**中立，不受到应用层的影响 ** （数据库作为中转站的方式，实现多个应用的数据共享）</li><li>方案2：在应用层中，使用<strong>特定数据结构</strong>，并在逻辑模型中高效支持这一数据结构。对于效率非常追求，“中立”的好处不大（共享范围小、共享的应用对数据的要求相似）。</li><li>方案*：通用数据结构采用方案1，关键性数据结构采用方案2</li></ul><h3 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h3><p>格式化模型（不常用了）</p><ul><li>层次模型（Hierarchical Model）</li><li>网状模型（Network Model）</li></ul><p>关系模型（Relational Model)）<br />对象模型（和上层应用紧密联系，难以实现共享）</p><ul><li>面向对象数据模型（Object Oriented Data Model）</li><li>对象关系数据模型（Object Relational Data Model）</li></ul><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676533205576-3e697d05-e48f-489a-8272-ea23224f3f8b.png" alt="image.png"></p><ul><li>关系（Relation）：<strong>一个关系对应通常说的一张表</strong>。是满足某种条件的<strong>集合</strong>。</li><li>元组（Tuple）：表中的一行即为一个元组，是<strong>具体的</strong>属性值的集合（无序、不重复）</li><li>属性（Attribute）：表中的一列即为一个属性，给每一个属性起一个名称即属性名</li><li>主码（Key）：也称码键。表中的某个属性组，它可以唯一确定一个元组</li><li>域（Domain）：是一组具有相同数据类型的值的集合。<strong>属性的取值范围来自某个域。</strong></li><li>分量：元组中的一个属性值。</li><li>关系模式<ul><li>对关系的描述</li><li>关系名（属性1，属性2，…，属性n）<code>1 2 3</code>和<code>3 2 1</code>在集合中是等价的</li><li>学生（学号，姓名，年龄，性别，系名，年级）</li></ul></li><li>关系必须是规范化的，满足一定的规范条件</li><li>最基本的规范条件：关系的每一个分量必须是一个<strong>不可分的数据项, 不允许表中还有表</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676533442959-94841cc7-b3d4-4c86-88dd-9d7163badb8d.png" alt="image.png"><br>上表不是一个关系，有嵌套的表</p><h3 id="操作与完整性约束"><a href="#操作与完整性约束" class="headerlink" title="操作与完整性约束"></a>操作与完整性约束</h3><p>数据操作（查询、插入、删除、更新）是集合操作，操作对象和操作结果都是关系<br />存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”<br />关系的完整性约束条件 </p><ul><li>实体完整性：里面的任何一条元祖都确定了一个实体</li><li>参照完整性：实体必须存在</li><li>用户定义的完整性</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>关系模型类似于保姆性质的，进行了检查，效率较低<br />优点</p><ul><li>足够统一且简单</li><li>有严格的数学概念的基础</li><li>对用户（底层）透明</li></ul><p>缺点：</p><ul><li>没有办法对底层进行优化</li></ul><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676533873194-9bf1d87e-4932-4a82-9af5-47484f86b2b9.png" alt="image.png"><br>列族模型：针对网络的处理<br />文档模型：类似于树</p><h2 id="ch06-数据库系统的结构"><a href="#ch06-数据库系统的结构" class="headerlink" title="ch06 数据库系统的结构"></a>ch06 数据库系统的结构</h2><p>从数据库应用开发人员角度</p><ul><li>看数据库系统通常采用三级模式结构，是数据库系统内部的系统结构</li></ul><p>从数据库最终用户角度看<br />数据库系统的结构分为:</p><ul><li>单用户结构</li><li>主从式结构</li><li>分布式结构</li><li>客户-服务器</li><li>浏览器-应用服务器／数据库服务器多层结构等</li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686746566793-767c67e1-47d9-46d5-9ada-8e412283b88c.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677572677389-40b72bb6-464e-4964-a324-dcb66c8ffd55.png" alt="image.png"></p><ul><li>内模式是对模式的物理实现、落地。模式本身绝大多数下是固定的，内模式在不同时间下有不同形式。</li><li>在<strong>模式不变</strong>的情况下，<strong>内模式可以根据需要进行修改。</strong></li><li><strong>所以模式可以隔离来自底层物理模式&#x2F;内模式的变化。</strong></li></ul><p>在统一模式下的不同应用，对数据的访问、需要是相同的或者类似的，处在同一个应用域。如果模式暴露给应用，而应用<strong>不需要这么多</strong>数据同时也会<strong>有安全问题</strong>。同时模式中数据的变化，会对<strong>不同的外模式都会造成影响。</strong>如果只改变外模式1，是不会对其他的外模式造成影响的。<br />所以应用群变得更加安全了，不易受到其他改变的影响<br />外模式（External Schema） </p><ul><li>也称子模式或用户模式</li><li>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</li><li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li></ul><p>外模式的地位:介于模式与应用之间<br />模式与外模式的关系:一对多</p><ul><li>外模式通常是模式的子集</li><li>一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</li><li>对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同</li></ul><p>外模式与应用的关系:一对多</p><ul><li>同一外模式也可以为某一用户的多个应用系统所使用</li><li>但一个应用程序只能使用一个外模式</li></ul><p>外模式的用途</p><ul><li>保证数据库<strong>安全性</strong>的一个有力措施</li><li>每个用户只能看见和访问<strong>所对应的外模式中的数据（隔离）</strong></li></ul><h2 id="三级模式与二级映像"><a href="#三级模式与二级映像" class="headerlink" title="三级模式与二级映像"></a>三级模式与二级映像</h2><p>三级模式是对数据的三个抽象级别<br />二级映象在数据库管理系统内部实现这三个抽象层次的联系和转换</p><ul><li>外模式／模式映像</li><li>模式／内模式映像</li></ul><h3 id="外模式-x2F-模式映像"><a href="#外模式-x2F-模式映像" class="headerlink" title="外模式&#x2F;模式映像"></a>外模式&#x2F;模式映像</h3><ul><li>模式：描述的是<strong>数据的全局逻辑结构</strong></li><li>外模式：描述的是<strong>数据的局部逻辑结构</strong></li><li>同一个模式可以有任意多个外模式 </li><li>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</li><li>映象定义通常包含在各自外模式的描述中</li><li><strong>保证数据的逻辑独立性</strong><ul><li>当模式改变时，数据库管理员对外模式／模式映象作相应改变，使外模式保持不变</li><li><strong>应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</strong></li></ul></li></ul><h3 id="模式-x2F-内模式映像"><a href="#模式-x2F-内模式映像" class="headerlink" title="模式&#x2F;内模式映像"></a>模式&#x2F;内模式映像</h3><ul><li>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。</li></ul><p>例如，说明逻辑记录和字段在内部是如何表示的</p><ul><li>数据库中模式／内模式映象是唯一的</li><li>该映象定义通常包含在模式描述中</li><li><strong>保证数据的物理独立性</strong><ul><li>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变。</li><li><strong>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</strong></li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h3><ul><li><strong>即全局逻辑结构是数据库的中心与关键</strong></li><li>独立于数据库的其他层次</li><li>设计数据库模式结构时应首先确定数据库的逻辑模式</li></ul><h3 id="数据库的内模式"><a href="#数据库的内模式" class="headerlink" title="数据库的内模式"></a>数据库的内模式</h3><ul><li><strong>依赖于它的全局逻辑结构</strong></li><li>独立于数据库的用户视图，即外模式</li><li>独立于具体的存储设备：内模式是数据<strong>物理结构和存储方式</strong>的描述，定义数据在数据库内部的表示方式，而不是具体的存储位置</li><li>将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率</li></ul><h3 id="数据库的外模式"><a href="#数据库的外模式" class="headerlink" title="数据库的外模式"></a>数据库的外模式</h3><ul><li><strong>面向具体的应用程序</strong></li><li>定义在逻辑模式之上</li><li>独立于存储模式和存储设备</li><li><strong>当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动</strong></li><li>设计外模式时应充分考虑到应用的扩充性</li></ul><h3 id="特定的应用程序"><a href="#特定的应用程序" class="headerlink" title="特定的应用程序"></a>特定的应用程序</h3><ul><li>在外模式描述的数据结构上编制的</li><li><strong>依赖于特定的外模式</strong></li><li>与数据库的模式和存储结构独立</li><li>不同的应用程序有时可以共用同一个外模式</li></ul><h3 id="二级映像"><a href="#二级映像" class="headerlink" title="二级映像"></a>二级映像</h3><p>数据库的二级映像</p><ul><li>保证了数据库外模式的稳定性</li><li>从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改</li></ul><p>数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去 <br />数据的存取由数据库管理系统管理</p><ul><li>简化了应用程序的编制大大</li><li>减少了应用程序的维护和修改</li></ul><h1 id="ch07-数据库系统的组成"><a href="#ch07-数据库系统的组成" class="headerlink" title="ch07 数据库系统的组成"></a>ch07 数据库系统的组成</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677573295354-e98dec6e-9676-4d2f-b9e4-80f946829430.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Experiment7</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment7/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment7/</url>
      
        <content type="html"><![CDATA[<h1 id="创建数据库示例"><a href="#创建数据库示例" class="headerlink" title="创建数据库示例"></a>创建数据库示例</h1><p>关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;CREATE DATABASE STUDENTS&quot;</span>;</span><br><span class="line">stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683631611713-30c18c12-8120-4e52-a886-8e2a0ac2df49.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683631681927-09efdef8-e30e-4aa1-ad6a-56ef0483cc7f.png" alt="image.png"></p><h1 id="选择数据库示例"><a href="#选择数据库示例" class="headerlink" title="选择数据库示例"></a>选择数据库示例</h1><p>关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//STEP 3: Open a connection</span></span><br><span class="line">System.out.println(<span class="string">&quot;Connecting to a selected database...&quot;</span>);</span><br><span class="line">conn = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">System.out.println(<span class="string">&quot;Connected database successfully...&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683631823333-85a02d07-46e9-4f8a-aa76-7e2dc034f326.png" alt="image.png"></p><h1 id="删除数据库示例"><a href="#删除数据库示例" class="headerlink" title="删除数据库示例"></a>删除数据库示例</h1><p>关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stmt = conn.createStatement();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DROP DATABASE STUDENTS&quot;</span>;</span><br><span class="line">stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683632080998-75888254-abad-4a71-8a80-79e54095deb8.png" alt="image.png"></p><h1 id="创建表示例"><a href="#创建表示例" class="headerlink" title="创建表示例"></a>创建表示例</h1><p>关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;CREATE TABLE REGISTRATION &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;(id INTEGER not NULL, &quot;</span> +</span><br><span class="line">                  <span class="string">&quot; first VARCHAR(255), &quot;</span> + </span><br><span class="line">                  <span class="string">&quot; last VARCHAR(255), &quot;</span> + </span><br><span class="line">                  <span class="string">&quot; age INTEGER, &quot;</span> + </span><br><span class="line">                  <span class="string">&quot; PRIMARY KEY ( id ))&quot;</span>; </span><br><span class="line"></span><br><span class="line">     stmt.executeUpdate(sql);</span><br><span class="line">     System.out.println(<span class="string">&quot;Created table in given database...&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683632421412-042c944e-aaf7-48bf-a9ab-3be60f21016e.png" alt="image.png"></p><h1 id="删除表示例"><a href="#删除表示例" class="headerlink" title="删除表示例"></a>删除表示例</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683633028958-79990293-9aea-40ab-a420-2b4ef09bfd4b.png" alt="image.png"></p><h1 id="插入记录示例"><a href="#插入记录示例" class="headerlink" title="插入记录示例"></a>插入记录示例</h1><p>关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO Registration &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;VALUES (100, &#x27;Zara&#x27;, &#x27;Ali&#x27;, 18)&quot;</span>;</span><br><span class="line">      stmt.executeUpdate(sql);</span><br><span class="line">      sql = <span class="string">&quot;INSERT INTO Registration &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;VALUES (101, &#x27;Mahnaz&#x27;, &#x27;Fatma&#x27;, 25)&quot;</span>;</span><br><span class="line">      stmt.executeUpdate(sql);</span><br><span class="line">      sql = <span class="string">&quot;INSERT INTO Registration &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;VALUES (102, &#x27;Zaid&#x27;, &#x27;Khan&#x27;, 30)&quot;</span>;</span><br><span class="line">      stmt.executeUpdate(sql);</span><br><span class="line">      sql = <span class="string">&quot;INSERT INTO Registration &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;VALUES(103, &#x27;Sumit&#x27;, &#x27;Mittal&#x27;, 28)&quot;</span>;</span><br><span class="line">      stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683632541083-a024072a-04ab-4de7-92ff-a046f24d230b.png" alt="image.png"></p><h1 id="查询记录示例"><a href="#查询记录示例" class="headerlink" title="查询记录示例"></a>查询记录示例</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683632674174-bff598c6-a279-4205-b50c-724226e13457.png" alt="image.png"></p><h1 id="更新记录示例"><a href="#更新记录示例" class="headerlink" title="更新记录示例"></a>更新记录示例</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683632752790-21637e51-466e-4d0b-8da4-ad0ed2d347f0.png" alt="image.png"></p><h1 id="删除记录示例"><a href="#删除记录示例" class="headerlink" title="删除记录示例"></a>删除记录示例</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683632801283-da2feba3-d75f-4051-9628-5e8948da168e.png" alt="image.png"></p><h1 id="WHERE子句示例"><a href="#WHERE子句示例" class="headerlink" title="WHERE子句示例"></a>WHERE子句示例</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683632863594-0f22db1d-89ac-4c6b-9112-00659419389f.png" alt="image.png"></p><h1 id="排序示例"><a href="#排序示例" class="headerlink" title="排序示例"></a>排序示例</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683632975458-a1403907-b662-4fbe-b087-8763a7afdb55.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 实验作业 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Experiment6</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment6/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment6/</url>
      
        <content type="html"><![CDATA[<h2 id="3-完整性语言实验"><a href="#3-完整性语言实验" class="headerlink" title="3 完整性语言实验"></a>3 完整性语言实验</h2><h3 id="3-1-实体完整性实验"><a href="#3-1-实体完整性实验" class="headerlink" title="3.1 实体完整性实验"></a>3.1 实体完整性实验</h3><h4 id="3-1-1-实验目的"><a href="#3-1-1-实验目的" class="headerlink" title="3.1.1 实验目的"></a>3.1.1 实验目的</h4><p>掌握实体完整性的定义和维护方法。</p><h4 id="3-1-2-实验内容和要求"><a href="#3-1-2-实验内容和要求" class="headerlink" title="3.1.2 实验内容和要求"></a>3.1.2 实验内容和要求</h4><p>定义实体完整性，删除实体完整性。能够写出两种方式定义实体完整性的 SQL 语句：创建表时定义实体完整性、创建表后定义实体完整性。设计 SQL 语句验证完整性约束是否起作用。</p><h4 id="3-1-3-实验重点和难点"><a href="#3-1-3-实验重点和难点" class="headerlink" title="3.1.3 实验重点和难点"></a>3.1.3 实验重点和难点</h4><p>实验重点：创建表时定义实体完整性。<br />实验难点：有多个候选码时实体完整性的定义。</p><h4 id="3-1-4-实验内容记录"><a href="#3-1-4-实验内容记录" class="headerlink" title="3.1.4 实验内容记录"></a>3.1.4 实验内容记录</h4><p>这里参照 employees 数据库创建一个新的数据库 test;<br />CREATE DATABASE test; </p><h5 id="3-1-4-1-创建表时定义实体完整性（列级实体完整性）"><a href="#3-1-4-1-创建表时定义实体完整性（列级实体完整性）" class="headerlink" title="3.1.4.1 创建表时定义实体完整性（列级实体完整性）"></a>3.1.4.1 创建表时定义实体完整性（列级实体完整性）</h5><p>创建雇员表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">  emp_no      <span class="type">INT</span>             <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  birth_date  <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  first_name  <span class="type">VARCHAR</span>(<span class="number">14</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  last_name   <span class="type">VARCHAR</span>(<span class="number">16</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  gender      ENUM (<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;F&#x27;</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,    </span><br><span class="line">  hire_date   <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="3-1-4-2-创建表时定义实体完整性（表级实体完整性）"><a href="#3-1-4-2-创建表时定义实体完整性（表级实体完整性）" class="headerlink" title="3.1.4.2 创建表时定义实体完整性（表级实体完整性）"></a>3.1.4.2 创建表时定义实体完整性（表级实体完整性）</h5><p>创建雇员表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    emp_no      <span class="type">INT</span>             <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birth_date  <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    first_name  <span class="type">VARCHAR</span>(<span class="number">14</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_name   <span class="type">VARCHAR</span>(<span class="number">16</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    gender      ENUM (<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;F&#x27;</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,    </span><br><span class="line">    hire_date   <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_empno <span class="keyword">PRIMARY</span> KEY(emp_no)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注：MYSQL 不支持约束命名。</p><h5 id="3-1-4-3-创建表后定义实体完整性"><a href="#3-1-4-3-创建表后定义实体完整性" class="headerlink" title="3.1.4.3 创建表后定义实体完整性"></a>3.1.4.3 创建表后定义实体完整性</h5><p>创建雇员表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    emp_no      <span class="type">INT</span>             <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birth_date  <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    first_name  <span class="type">VARCHAR</span>(<span class="number">14</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_name   <span class="type">VARCHAR</span>(<span class="number">16</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    gender      ENUM (<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;F&#x27;</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,    </span><br><span class="line">    hire_date   <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(emp_no);</span><br></pre></td></tr></table></figure><h5 id="3-1-4-4-定义实体完整性（多属性主码）"><a href="#3-1-4-4-定义实体完整性（多属性主码）" class="headerlink" title="3.1.4.4 定义实体完整性（多属性主码）"></a>3.1.4.4 定义实体完整性（多属性主码）</h5><p>创建职位表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> titles (</span><br><span class="line">    emp_no      <span class="type">INT</span>             <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    title       <span class="type">VARCHAR</span>(<span class="number">50</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    from_date   <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    to_date     <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (emp_no) <span class="keyword">REFERENCES</span> employees (emp_no) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (emp_no,title, from_date)</span><br><span class="line">); </span><br></pre></td></tr></table></figure><h5 id="3-1-4-5-有多个候选码时定义实体完整性"><a href="#3-1-4-5-有多个候选码时定义实体完整性" class="headerlink" title="3.1.4.5 有多个候选码时定义实体完整性"></a>3.1.4.5 有多个候选码时定义实体完整性</h5><p>当存在多个候选码时，只能定义一个主码，其它的候选码定义唯一性约束。<br />创建部门表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments (</span><br><span class="line">    dept_no     <span class="type">CHAR</span>(<span class="number">4</span>)         <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    dept_name   <span class="type">VARCHAR</span>(<span class="number">40</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (dept_no),</span><br><span class="line">    <span class="keyword">UNIQUE</span>  KEY (dept_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="3-1-4-6-删除实体完整性"><a href="#3-1-4-6-删除实体完整性" class="headerlink" title="3.1.4.6 删除实体完整性"></a>3.1.4.6 删除实体完整性</h5><p>删除部门表上的实体完整性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> departments</span><br><span class="line"><span class="keyword">DROP</span> INDEX dept_name;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> departments</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure><h4 id="3-1-5-思考"><a href="#3-1-5-思考" class="headerlink" title="3.1.5 思考"></a>3.1.5 思考</h4><ul><li>所有列级完整性约束都可以改写为表级完整性约束，而表级完整性约束不一定能改写为列级完整性约束。请举例说明。</li></ul><p>例如多属性主码就只能通过表级完整性约束定义。列级完整性约束可以实现缺省约束和非空约束，而表级完整性约束无法实现。表级完整性约束只能实现主键约束、外键约束、唯一性约束、检查约束<br />表级完整性约束不一定能改写为列级完整性约束，因为有些表级完整性约束涉及到多个列，而列级完整性约束只能应用于单个列。例如，以下语句使用了表级完整性约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> project_assignments (</span><br><span class="line"> project_id <span class="type">int</span>,</span><br><span class="line"> employee_id <span class="type">int</span>,</span><br><span class="line"> join_date <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">CONSTRAINT</span> pk_assgn <span class="keyword">PRIMARY</span> KEY (project_id , employee_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>不能改写为以下语句，因为 PRIMARY KEY 约束不能作为列级完整性约束应用于多个列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> project_assignments (</span><br><span class="line"> project_id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line"> employee_id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line"> join_date <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>什么情况下会违反实体完整性约束，DBMS 将做何种违约处理？请用实验验证。</li></ul><p>当更新数据时，新的数据可能违反实体完整性约束。此时 DBMS 会拒绝执行。<br />举例：插入的数据中，对应的主码为空值时，就会违反实体完整性约束<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680279157056-7e3c9b71-0a6a-4c73-9971-caca17f9a85f.png" alt="image.png"><br><code>dept_no</code>是主码，所以不能为空</p><h3 id="3-2-参照完整性实验"><a href="#3-2-参照完整性实验" class="headerlink" title="3.2 参照完整性实验"></a>3.2 参照完整性实验</h3><h4 id="3-2-1-实验目的"><a href="#3-2-1-实验目的" class="headerlink" title="3.2.1 实验目的"></a>3.2.1 实验目的</h4><p>掌握参照完整性的定义和维护方法。</p><h4 id="3-2-2-实验内容和要求"><a href="#3-2-2-实验内容和要求" class="headerlink" title="3.2.2 实验内容和要求"></a>3.2.2 实验内容和要求</h4><p>定义参照完整性，定义参照完整性的违约处理，删除参照完整性。写出两种方式定义参照完整性的 SQL 语句：创建表时定义参照完整性、创建表后定义参照完整性。</p><h4 id="3-2-3-实验重点和难点"><a href="#3-2-3-实验重点和难点" class="headerlink" title="3.2.3 实验重点和难点"></a>3.2.3 实验重点和难点</h4><p>实验重点：创建表时定义参照完整性。<br />实验难点：参照完整性的违约处理定义。</p><h4 id="3-2-4-实验内容记录"><a href="#3-2-4-实验内容记录" class="headerlink" title="3.2.4 实验内容记录"></a>3.2.4 实验内容记录</h4><h5 id="3-2-4-1-创建表时定义参照完整性"><a href="#3-2-4-1-创建表时定义参照完整性" class="headerlink" title="3.2.4.1 创建表时定义参照完整性"></a>3.2.4.1 创建表时定义参照完整性</h5><p>在已有员工表的情况下，定义工资表。<br />列级参照完整性定义。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salaries (</span><br><span class="line">    emp_no      <span class="type">INT</span>             <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">REFERENCES</span> employees (emp_no),</span><br><span class="line">    salary      <span class="type">INT</span>             <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    from_date   <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    to_date     <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (emp_no, from_date)</span><br><span class="line">); </span><br></pre></td></tr></table></figure><p>注：经测试，MYSQL 定义列级外键约束无效。<br />表级参照完整性定义。<br />注：MYSQL 支持外键约束命名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salaries (</span><br><span class="line">    emp_no      <span class="type">INT</span>             <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    salary      <span class="type">INT</span>             <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    from_date   <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    to_date     <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (emp_no, from_date),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> FK_empno <span class="keyword">FOREIGN</span> KEY (emp_no) <span class="keyword">REFERENCES</span> employees(emp_no)</span><br><span class="line">); </span><br></pre></td></tr></table></figure><h5 id="3-2-4-2-创建表后定义参照完整性"><a href="#3-2-4-2-创建表后定义参照完整性" class="headerlink" title="3.2.4.2 创建表后定义参照完整性"></a>3.2.4.2 创建表后定义参照完整性</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salaries (</span><br><span class="line">    emp_no      <span class="type">INT</span>             <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    salary      <span class="type">INT</span>             <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    from_date   <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    to_date     <span class="type">DATE</span>            <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (emp_no, from_date)</span><br><span class="line">); </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> salaries</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_empno</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(emp_no) <span class="keyword">REFERENCES</span> employees(emp_no);</span><br></pre></td></tr></table></figure><h5 id="3-2-4-3-定义参照完整性的违约处理"><a href="#3-2-4-3-定义参照完整性的违约处理" class="headerlink" title="3.2.4.3 定义参照完整性的违约处理"></a>3.2.4.3 定义参照完整性的违约处理</h5><p>定义两张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments (</span><br><span class="line">  dept_no <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  dept_name <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (dept_no)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_dept (</span><br><span class="line">  emp_no <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  dept_no <span class="type">CHAR</span>(<span class="number">5</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> FK_deptno </span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (dept_no) </span><br><span class="line">  <span class="keyword">REFERENCES</span> departments(dept_no)</span><br><span class="line">  <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">  <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(emp_no)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注：如果要定义删除后的行为，则必须不能与已有的限制冲突（如不能定义 NOT NULL）。<br />插入两条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;00001&#x27;</span>, <span class="string">&#x27;Finance&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp_dept</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;10000&#x27;</span>, <span class="string">&#x27;00001&#x27;</span>);</span><br></pre></td></tr></table></figure><p>然后删除被参照表中的元组，之后参照表会变成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> emp_no <span class="operator">|</span> dept_no <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10000</span>  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br></pre></td></tr></table></figure><h5 id="3-2-4-4-删除参照完整性"><a href="#3-2-4-4-删除参照完整性" class="headerlink" title="3.2.4.4 删除参照完整性"></a>3.2.4.4 删除参照完整性</h5><p>删除 emp_dept 上的外码。<br />注：和书中写法稍有不同。<br />ALTER TABLE emp_dept DROP FOREIGN KEY FK_deptno; </p><h4 id="3-2-5-思考"><a href="#3-2-5-思考" class="headerlink" title="3.2.5 思考"></a>3.2.5 思考</h4><ul><li>对于自引用表，例如课程表（课程号、课程名、先修课程号、学分）中的先修课程号引用该表的课程号，请完成如下任务：<br />（1）写出课程表上的实体完整性和参照完整性。<br />（2）在考虑实体完整性约束的条件下，试举出几种录入课程数据的方法。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course (</span><br><span class="line">  cno <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">  cname <span class="type">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">  cpno <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">  ccredit <span class="type">SMALLINT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> course</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(cno);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> course</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_cpno</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(cpno) <span class="keyword">REFERENCES</span> course(cno);</span><br></pre></td></tr></table></figure>在录入数据时，可以按照引用的顺序录入数据（总是先录入不存在引用或引用已存在的数据），也可以临时移除完整性约束，在录入数据后，再添加完整性约束。<br />如果数据本身无法满足约束，则引入约束时会失败。<br />比如先加入数据：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;0001&#x27;</span>,<span class="string">&#x27;DataStructure&#x27;</span>,<span class="string">&#x27;0002&#x27;</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure>这一条数据存在依赖问题，此时再引入完整性约束，则会出现无法引入的情况。</li></ul><h3 id="3-3-用户自定义完整性实验"><a href="#3-3-用户自定义完整性实验" class="headerlink" title="3.3 用户自定义完整性实验"></a>3.3 用户自定义完整性实验</h3><h4 id="3-3-1-实验目的"><a href="#3-3-1-实验目的" class="headerlink" title="3.3.1 实验目的"></a>3.3.1 实验目的</h4><p>掌握用户自定义完整性的定义和维护方法。</p><h4 id="3-3-2-实验内容和要求"><a href="#3-3-2-实验内容和要求" class="headerlink" title="3.3.2 实验内容和要求"></a>3.3.2 实验内容和要求</h4><p>针对具体应用语义，选择 NULL、NOT NULL、DEFAULT、DEFAULT、UNIQUE、CHECK 等，定义属性上的约束条件。</p><h4 id="3-3-3-实验重点和难点"><a href="#3-3-3-实验重点和难点" class="headerlink" title="3.3.3 实验重点和难点"></a>3.3.3 实验重点和难点</h4><p>实验重点：NULL、NOT NULL、DEFAULT<br />实验难点：CHECK</p><h4 id="3-3-4-实验内容记录"><a href="#3-3-4-实验内容记录" class="headerlink" title="3.3.4 实验内容记录"></a>3.3.4 实验内容记录</h4><h5 id="3-3-4-1-定义属性-NULL、NOT-NULL-约束"><a href="#3-3-4-1-定义属性-NULL、NOT-NULL-约束" class="headerlink" title="3.3.4.1 定义属性 NULL、NOT NULL 约束"></a>3.3.4.1 定义属性 NULL、NOT NULL 约束</h5><p>注：默认约束即为 NULL 约束，即可以为 NULL 。<br />这里不作示例。</p><h5 id="3-3-4-2-定义属性-DEFAULT-约束"><a href="#3-3-4-2-定义属性-DEFAULT-约束" class="headerlink" title="3.3.4.2 定义属性 DEFAULT 约束"></a>3.3.4.2 定义属性 DEFAULT 约束</h5><p>DEFAULT 约束用于给定属性的默认值，即不提供值的时候自动填充的值。<br />这里不作示例。</p><h5 id="3-3-4-3-定义-UNIQUE-约束"><a href="#3-3-4-3-定义-UNIQUE-约束" class="headerlink" title="3.3.4.3 定义 UNIQUE 约束"></a>3.3.4.3 定义 UNIQUE 约束</h5><p>UNIQUE 约束即必须唯一。</p><h5 id="3-3-4-4-使用-CHECK-约束条件"><a href="#3-3-4-4-使用-CHECK-约束条件" class="headerlink" title="3.3.4.4 使用 CHECK 约束条件"></a>3.3.4.4 使用 CHECK 约束条件</h5><p>CHECK 可以跟表达式，并且可以引用多个属性。<br />如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">CHECK</span> (from_date <span class="operator">&lt;=</span> to_date),</span><br><span class="line">...</span><br><span class="line"><span class="keyword">CHECK</span> (grade <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">AND</span> grade <span class="operator">&lt;=</span><span class="number">100</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="4-触发器实验"><a href="#4-触发器实验" class="headerlink" title="4 触发器实验"></a>4 触发器实验</h2><h3 id="4-1-触发器实验"><a href="#4-1-触发器实验" class="headerlink" title="4.1 触发器实验"></a>4.1 触发器实验</h3><h4 id="4-1-实验目的"><a href="#4-1-实验目的" class="headerlink" title="4.1 实验目的"></a>4.1 实验目的</h4><p>掌握数据库触发器的设计和使用方法。</p><h4 id="4-2-实验内容和要求"><a href="#4-2-实验内容和要求" class="headerlink" title="4.2 实验内容和要求"></a>4.2 实验内容和要求</h4><p>定义 BEFORE 触发器和 AFTER 触发器。能够理解不同类型触发器的作用和执行原理，验证触发器的有效性。</p><h4 id="4-3-实验重点和难点"><a href="#4-3-实验重点和难点" class="headerlink" title="4.3 实验重点和难点"></a>4.3 实验重点和难点</h4><p>实验重点：触发器的定义。<br />实验难点：利用触发器实现较为复杂的用户自定义完整性。</p><h4 id="4-4-实验内容记录"><a href="#4-4-实验内容记录" class="headerlink" title="4.4 实验内容记录"></a>4.4 实验内容记录</h4><h5 id="4-4-1-AFTER-触发器"><a href="#4-4-1-AFTER-触发器" class="headerlink" title="4.4.1 AFTER 触发器"></a>4.4.1 AFTER 触发器</h5><p>AFTER 触发器可以用来维护一致性。<br />比如有一张员工总工资表，那么在加入新的工资记录后，需要更新总工资表。<br />总工资表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_salary_total (</span><br><span class="line">  emp_no <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  salary_total <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> FK_empno <span class="keyword">FOREIGN</span> KEY (emp_no)</span><br><span class="line">  <span class="keyword">REFERENCES</span> employees(emp_no)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>建立总工资表后，初始化一次数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp_salary_total</span><br><span class="line"><span class="keyword">SELECT</span> emp_no, <span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no;</span><br></pre></td></tr></table></figure><p>在总工资表上定义触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> TRI_salary_total_DELETE</span><br><span class="line">AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> salaries</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">UPDATE</span> emp_salary_total e</span><br><span class="line">  <span class="keyword">SET</span> e.salary_total <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> salaries s</span><br><span class="line">    <span class="keyword">WHERE</span> s.emp_no<span class="operator">=</span>OLD.emp_no</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">WHERE</span> e.emp_no<span class="operator">=</span>OLD.emp_no;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680280732126-d003ee13-5a34-4751-9fec-92fdce43c40e.png" alt="image.png"><br>下面进行验证：<br />先查询 10001 的总工资：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> emp_salary_total</span><br><span class="line"><span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="number">10001</span> $$</span><br></pre></td></tr></table></figure><p>得到总工资为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br><span class="line"><span class="operator">|</span> emp_no <span class="operator">|</span> salary_total <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">10001</span> <span class="operator">|</span>      <span class="number">344084</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680280674664-4c02bf70-cbd5-4157-8256-8c8a2ebfb9aa.png" alt="image.png"><br>从中删除一条数据：<br />DELETE FROM salaries  WHERE salary&#x3D;84917 AND emp_no&#x3D;10001 $$ <br />再查询总工资为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br><span class="line"><span class="operator">|</span> emp_no <span class="operator">|</span> salary_total <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">10001</span> <span class="operator">|</span>      <span class="number">259167</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680280825298-b2fdf130-0e74-4762-86d7-65bd84071a13.png" alt="image.png"><br>符合预期。<br />在触发器上不应定义过于复杂（耗时）的动作，例如本例中触发器执行了全扫描更新。更好的处理方式是利用被删除的行的信息来增量更新总工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> TRI_salary_total_DELETE</span><br><span class="line">AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> salaries</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">UPDATE</span> emp_salary_total e</span><br><span class="line">  <span class="keyword">SET</span> e.salary_total <span class="operator">=</span> e.salary_total <span class="operator">-</span> OLD.salary</span><br><span class="line">  <span class="keyword">WHERE</span> e.emp_no<span class="operator">=</span>OLD.emp_no;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure><p>此时再删除一条数据，<br />DELETE FROM salaries  WHERE salary&#x3D;85112 AND emp_no&#x3D;10001 $$ <br />然后查询总工资为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br><span class="line"><span class="operator">|</span> emp_no <span class="operator">|</span> salary_total <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">10001</span> <span class="operator">|</span>      <span class="number">174055</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------------+</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680280931483-27a0e6b0-c137-427c-aed7-2f8b07f9dcde.png" alt="image.png"><br>同样符合预期。</p><h5 id="4-4-2-BEFORE-触发器"><a href="#4-4-2-BEFORE-触发器" class="headerlink" title="4.4.2 BEFORE 触发器"></a>4.4.2 BEFORE 触发器</h5><p>BEFORE 触发器可以用来检查数据更新的合法性，可以用来实现比断言更为复杂的检查（断言只能定义一个 CHECK 子句）。<br />例如，加入一个日期检查，要求 to_date 必须大于 from_date 。<br />注：MYSQL 抛出异常的写法和书中给出的不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> TRI_salaries_INSERT</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> salaries</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span></span><br><span class="line">    v_msg <span class="type">VARCHAR</span>(<span class="number">200</span>);</span><br><span class="line">  IF (NEW.from_date <span class="operator">&gt;=</span> NEW.to_date) </span><br><span class="line">  <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">SET</span> v_msg <span class="operator">=</span> <span class="string">&#x27;to_date is EARLIER than from_date!&#x27;</span>;</span><br><span class="line">      SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> v_msg;</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>; $$</span><br></pre></td></tr></table></figure><p>然后插入一条一场数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salaries</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">10001</span>, <span class="number">15000</span>, <span class="string">&#x27;2020-03-01&#x27;</span>, <span class="string">&#x27;2020-01-01&#x27;</span>);</span><br></pre></td></tr></table></figure><p>会得到错误：<br />ERROR 1644 (HY000): to_date is EARLIER than from_date!<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680281651336-594eb446-94c1-45e3-8b46-64bed786580f.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 实验作业 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Experiment5</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment5/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment5/</url>
      
        <content type="html"><![CDATA[<h3 id="2-1-自主存取控制实验"><a href="#2-1-自主存取控制实验" class="headerlink" title="2.1 自主存取控制实验"></a>2.1 自主存取控制实验</h3><h4 id="2-1-1-实验目的"><a href="#2-1-1-实验目的" class="headerlink" title="2.1.1 实验目的"></a>2.1.1 实验目的</h4><p>掌握自主存取控制权限的定义和维护方法。</p><h4 id="2-1-2-实验内容和要求"><a href="#2-1-2-实验内容和要求" class="headerlink" title="2.1.2 实验内容和要求"></a>2.1.2 实验内容和要求</h4><p>定义用户、角色，分配权限给用户、角色，回收权限，以相应的用户名登陆数据库验证权限分配是否正确。选择一个应用场景，使用自主存取控制机制设计权限分配。可以采用两种方案。<br />方案一：采用 SYSTEM 超级用户登录数据库（对于 MYSQL(Linux) 则是 root），完成所有权限分配工作，然后用相应用户名登陆数据库以验证权限分配正确性；<br />方案二：采用 SYSTEM 用户登陆数据库创建三个部门经理用户，并分配相应的权限，然后分别用三个经理用户名登陆数据库，创建相应部门的 USER、ROLE ，并分配相应权限。</p><h4 id="2-1-3-实验重点和难点"><a href="#2-1-3-实验重点和难点" class="headerlink" title="2.1.3 实验重点和难点"></a>2.1.3 实验重点和难点</h4><p>实验重点：定义角色，分配权限和回收权限。<br />实验难点：实验方案二实现权限的再分配和回收。</p><h4 id="2-1-4-实验内容记录"><a href="#2-1-4-实验内容记录" class="headerlink" title="2.1.4 实验内容记录"></a>2.1.4 实验内容记录</h4><p>本次实验中，为财务部（finance）创建一个管理员，部门的管理员只有管理自己部门内部的员工的权限以及访问部门表（departments）、部门管理员表（dept_manager）的权限。<br />注：为了减少工作量，只为财务部门创建相关用户。其它部门的操作可以类比。</p><h5 id="2-1-4-1-建立视图"><a href="#2-1-4-1-建立视图" class="headerlink" title="2.1.4.1 建立视图"></a>2.1.4.1 建立视图</h5><p>数据库基本表没有区分不同的部门，因此通过视图来划分不同部门的员工。<br />先创建员工所在部门视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_emp_dept(emp_no, dept_no, dept_name) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> de.emp_no, d.dept_no, d.dept_name</span><br><span class="line"><span class="keyword">FROM</span> dept_emp de, departments d</span><br><span class="line"><span class="keyword">WHERE</span> de.dept_no<span class="operator">=</span>d.dept_no;</span><br></pre></td></tr></table></figure><p>然后为各个表创建部门视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_finance_employees <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees e, v_emp_dept ved</span><br><span class="line"><span class="keyword">WHERE</span> e.emp_no<span class="operator">=</span>ved.emp_no</span><br><span class="line"><span class="keyword">AND</span> ved.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_finance_salaries <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> s.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> salaries s, v_emp_dept ved</span><br><span class="line"><span class="keyword">WHERE</span> s.emp_no<span class="operator">=</span>ved.emp_no</span><br><span class="line"><span class="keyword">AND</span> ved.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_finance_dept_emp <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> de.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> dept_emp de, v_emp_dept ved</span><br><span class="line"><span class="keyword">WHERE</span> de.emp_no<span class="operator">=</span>ved.emp_no</span><br><span class="line"><span class="keyword">AND</span> ved.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_finance_titles <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> t.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> titles t, v_emp_dept ved</span><br><span class="line"><span class="keyword">WHERE</span> t.emp_no<span class="operator">=</span>ved.emp_no</span><br><span class="line"><span class="keyword">AND</span> ved.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680234223340-085decbc-3f28-49b5-ba86-8aaf0cca53da.png" alt="image.png"></p><h5 id="2-1-4-2-建立角色"><a href="#2-1-4-2-建立角色" class="headerlink" title="2.1.4.2 建立角色"></a>2.1.4.2 建立角色</h5><p>为财务部门建立一个经理角色（完全控制本部门数据，同时能查询其它部门的数据，能够为本部门职员分配权限），一个职员角色（可以插入和查询本部门数据）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE </span><br><span class="line">  role_finance_manager,</span><br><span class="line">  role_finance_staff;</span><br></pre></td></tr></table></figure><p>为角色分配权限。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680234278926-7b4e53d6-cf32-41e6-b0c6-b5dcaabe09f4.png" alt="image.png"><br>注：MYSQL 只有 WITH GRANT OPTION，并且行为是非级联权限收回。<br />先分配部门经理角色对本部门表的权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">ON</span> emplorees.v_finance_emplorees</span><br><span class="line"><span class="keyword">TO</span> role_finance_manager</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">ON</span> emplorees.v_finance_salaries</span><br><span class="line"><span class="keyword">TO</span> role_finance_manager</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">ON</span> emplorees.v_finance_dept_emp</span><br><span class="line"><span class="keyword">TO</span> role_finance_manager</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">ON</span> emplorees.v_finance_titles</span><br><span class="line"><span class="keyword">TO</span> role_finance_manager</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680234535045-76a72f18-2a63-4f43-ad38-75da9be06226.png" alt="image.png"><br>分配部门经理对其它部门表的查询权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> employees.<span class="operator">*</span></span><br><span class="line"><span class="keyword">TO</span> role_finance_manager;</span><br></pre></td></tr></table></figure><p>分配员工对本部门的权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> employees.v_finance_employees</span><br><span class="line"><span class="keyword">TO</span> role_finance_staff;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> employees.v_finance_salaries</span><br><span class="line"><span class="keyword">TO</span> role_finance_staff;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> employees.v_finance_dept_emp</span><br><span class="line"><span class="keyword">TO</span> role_finance_staff;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> employees.v_finance_titles</span><br><span class="line"><span class="keyword">TO</span> role_finance_staff;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680242656979-a39db53b-5e48-44aa-b46e-5e3a14a76381.png" alt="image.png"></p><h5 id="2-1-4-3-建立用户"><a href="#2-1-4-3-建立用户" class="headerlink" title="2.1.4.3 建立用户"></a>2.1.4.3 建立用户</h5><p>为财务部门建立一个经理用户和一个职员用户。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> user_manager</span><br><span class="line">IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> user_staff</span><br><span class="line">IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680234884215-a992df71-af07-4b44-918a-a34f32db0e99.png" alt="image.png"><br>将角色赋予用户。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> role_finance_manager</span><br><span class="line"><span class="keyword">TO</span> user_manager;</span><br><span class="line"><span class="keyword">GRANT</span> role_finance_staff</span><br><span class="line"><span class="keyword">TO</span> user_staff;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680242695962-87ee834c-ca8d-4597-85d8-1fbb61819e6d.png" alt="image.png"></p><h5 id="2-1-4-4-查询角色和用户的权限"><a href="#2-1-4-4-查询角色和用户的权限" class="headerlink" title="2.1.4.4 查询角色和用户的权限"></a>2.1.4.4 查询角色和用户的权限</h5><p>查询权限使用 SHOW GRANTS 。<br />查询角色的权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> role_finance_manager;</span><br><span class="line">MariaDB [employees]<span class="operator">&gt;</span> <span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> role_finance_manager;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> role_finance_manager                                                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;role_finance_manager&#x27;</span>                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> `employees`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;role_finance_manager&#x27;</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> `emplorees`.`v_finance_titles` <span class="keyword">TO</span> <span class="string">&#x27;role_finance_manager&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> `emplorees`.`v_finance_emplorees` <span class="keyword">TO</span> <span class="string">&#x27;role_finance_manager&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> `emplorees`.`v_finance_dept_emp` <span class="keyword">TO</span> <span class="string">&#x27;role_finance_manager&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> `emplorees`.`v_finance_salaries` <span class="keyword">TO</span> <span class="string">&#x27;role_finance_manager&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680243698048-ec407ef6-f218-4c28-a19a-dd51e103b561.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> role_finance_staff;</span><br><span class="line">MariaDB [employees]<span class="operator">&gt;</span> <span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> role_finance_staff;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> role_finance_staff                                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;role_finance_staff&#x27;</span>                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> `employees`.`v_finance_salaries` <span class="keyword">TO</span> <span class="string">&#x27;role_finance_staff&#x27;</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> `employees`.`v_finance_titles` <span class="keyword">TO</span> <span class="string">&#x27;role_finance_staff&#x27;</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> `employees`.`v_finance_employees` <span class="keyword">TO</span> <span class="string">&#x27;role_finance_staff&#x27;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> `employees`.`v_finance_dept_emp` <span class="keyword">TO</span> <span class="string">&#x27;role_finance_staff&#x27;</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680243715155-56b81b70-061a-4938-90d5-2b1eaacef868.png" alt="image.png"><br>查询用户的权限。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SHOW</span> <span class="variable constant_">GRANTS</span> <span class="variable constant_">FOR</span> user_manager; </span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680243578619-a8e7b3ec-214b-43f1-97c8-ff60f8a4fdce.png" alt="image.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SHOW</span> <span class="variable constant_">GRANTS</span> <span class="variable constant_">FOR</span> user_staff;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680243617755-dcc329a6-0aea-4f0e-9fb6-80af96a12f6a.png" alt="image.png"></p><h5 id="2-1-4-5-验证权限分配正确性"><a href="#2-1-4-5-验证权限分配正确性" class="headerlink" title="2.1.4.5 验证权限分配正确性"></a>2.1.4.5 验证权限分配正确性</h5><p>仅仅对职员用户进行尝试。<br />使用职员用户登录。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680244203280-d44a970a-fc43-4563-8b04-ccb79f26b53d.png" alt="image.png"><br>访问数据库时，会出现报错：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">ERROR</span> <span class="number">1044</span> (<span class="number">42000</span>): <span class="title class_">Access</span> denied <span class="keyword">for</span> user <span class="string">&#x27;user_staff&#x27;</span>@<span class="string">&#x27;%&#x27;</span> to database <span class="string">&#x27;employees&#x27;</span> </span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680245983642-0e9e4be6-6753-4705-a50c-6cdc1869760c.png" alt="image.png"><br>原因是角色未启用。 <a href="https://www.programminghunter.com/article/17522038636/#fn1">[1]</a><br>登录后，启用角色<br />此时查询表，为<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680245884969-152b1efc-41a3-4ebf-bcf8-88740b0225b0.png" alt="image.png"></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul><li>请分析 WITH CHECK OPTION、WITH GRANT OPTION、WITH ADMIN OPTION 有何区别和联系。</li></ul><p><strong>WITH CHECK OPTION 是视图选项，用于达到对视图进行更新时检查视图的条件的要求。</strong></p><ol><li>对于update,有with check option，要保证update后，数据要被视图查询出来 - <strong>数据要满足创建视图时所设定的where子句</strong>；</li><li>对于delete,有无with check option都一样；</li><li>对于insert,有with check option，要保证insert后，数据要被视图查询出来；</li><li>对于没有where 子句的视图，使用with check option是多余的。</li></ol><p>WITH GRANT OPTION 和 WITH ADMIN OPTION 在授权时使用，前者（WITH GRANT OPTION）在权限被撤销时，会级联撤销，后者不会级联撤销。</p><blockquote><p>不同点：</p><ul><li>with admin option 只能在赋予 system privilege 的时使用 </li><li>with grant option 只能在赋予 object privilege 的时使用 </li><li><strong>撤消带有admin option 的system privileges 时，连带的权限将保留</strong><br />例如：</li></ul><ol><li>DBA 给了CREATE TABLE 系统权限给JEFF WITH ADMIN OPTION</li><li>JEFF CREATES TABLE</li><li>JEFF grants the CREATE TABLE 系统权限给EMI</li><li>EMI CREATES A table</li><li>DBA 撤消CREATE TABLE 系统权限从JEFF<br />结果：<br />JEFF‘S TABLE 依然存在，但不能创建新的TABLE 了<br />EMI’S TABLE 依然存在，他还保留着CREATE TABLE 系统权限。</li></ol><ul><li><strong>撤消带有grant option 的object privileges 时，连带的权限也将撤消</strong><br />例如：</li></ul><ol><li>JEFF 给了SELECT object privileges 在EMP 上 WITH ADMIN OPTION</li><li>JEFF 给了SELECT 权限在EMP 上 TO EMI</li><li>后来，撤消JEFF的SELECT 权限</li></ol></blockquote><p>结果：<br />EMI 的权限也被撤消了</p><p><br />注：MYSQL 中只有 WITH GRANT OPTION ，且其行为类似 WITH ADMIN OPTION 。</p><ul><li>请结合上述实验示例分析使用角色进行权限分配有何优缺点。</li></ul><p><strong>优点：</strong><br />使用角色进行权限分配便于管理权限（一个角色对应一种权限，而不是一个用户对应一种权限）。<br />对于通常的系统，比如：存在多个用户拥有相同的权限，在分配的时候就要分别为这几个用户指定相同的权限，修改时也要为这几个用户的权限进行一一修改。有了角色后，我们只需要为该角色制定好权限后，将相同权限的用户都指定为同一个角色即可，<strong>便于权限管理。</strong><br />对于批量的用户权限调整，只需调整用户关联的角色权限，无需对每一个用户都进行权限调整，既<strong>大幅提升权限调整的效率，又降低了漏调权限的概率。</strong><br /><strong>缺点：</strong></p><ol><li>角色维护：使用角色进行权限分配需要对角色进行维护，包括添加、修改和删除角色，这可能会增加管理复杂性。</li><li>复杂性：如果角色与权限的关系非常复杂，那么使用角色进行权限分配可能会变得非常复杂。例如，不同用户之间的权限都互不相同，且用户数量较少，使用角色进行分配，就会复杂而且冗余</li><li>风险：如果角色的权限分配不当，可能会导致系统安全风险，因此需要谨慎使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 实验作业 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Experiment4</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment4/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment4/</url>
      
        <content type="html"><![CDATA[<h3 id="1-6-索引实验"><a href="#1-6-索引实验" class="headerlink" title="1.6 索引实验"></a>1.6 索引实验</h3><h4 id="1-6-1-实验目的"><a href="#1-6-1-实验目的" class="headerlink" title="1.6.1 实验目的"></a>1.6.1 实验目的</h4><p>掌握索引设计原则和技巧，能够创建合适的索引以提高数据库查询、统计分析效率。</p><h4 id="1-6-2-实验内容和要求"><a href="#1-6-2-实验内容和要求" class="headerlink" title="1.6.2 实验内容和要求"></a>1.6.2 实验内容和要求</h4><p>针对给定的数据库模式和具体应用需求，创建唯一索引、函数索引、复合索引等；修改索引；删除索引。设计相应的 SQL 查询验证索引有效性。学习利用 EXPLAIN 命令分析 SQL 查询是否使用了所创建的索引，并能够分析其原因，执行 SQL 查询并估算索引提高查询效率的百分比。要求实验数据集达到 10 万条记录以上的数据量，以便验证索引效果。</p><h4 id="1-6-3-实验重点和难点"><a href="#1-6-3-实验重点和难点" class="headerlink" title="1.6.3 实验重点和难点"></a>1.6.3 实验重点和难点</h4><p>实验重点：创建索引。<br />实验难点：设计 SQL 查询验证索引有效性。</p><h4 id="1-6-4-实验内容记录"><a href="#1-6-4-实验内容记录" class="headerlink" title="1.6.4 实验内容记录"></a>1.6.4 实验内容记录</h4><h5 id="1-6-4-1-创建唯一索引"><a href="#1-6-4-1-创建唯一索引" class="headerlink" title="1.6.4.1 创建唯一索引"></a>1.6.4.1 创建唯一索引</h5><ul><li>对员工表的员工号码建立唯一索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_emp_no <span class="keyword">ON</span> employees (emp_no); </span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679933176582-85913021-2923-4c8e-9ec0-1778735b01d6.png" alt="image.png"><br>注：主码列在创建表时会自动创建相应的索引。<br />注：在存在数据时，建立索引需要一定的时间。</li></ul><h5 id="1-6-4-2-创建复合索引"><a href="#1-6-4-2-创建复合索引" class="headerlink" title="1.6.4.2 创建复合索引"></a>1.6.4.2 创建复合索引</h5><ul><li>对员工表的名字建立复合索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> employees (first_name, last_name); </span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679933186976-2a25dab6-0eb3-472e-bb50-4b593088d385.png" alt="image.png"></li></ul><h5 id="1-6-4-3-创建长度函数索引"><a href="#1-6-4-3-创建长度函数索引" class="headerlink" title="1.6.4.3 创建长度函数索引"></a>1.6.4.3 创建长度函数索引</h5><p>MYSQL 函数索引暂不录入。</p><h5 id="1-6-4-4-创建聚簇索引"><a href="#1-6-4-4-创建聚簇索引" class="headerlink" title="1.6.4.4 创建聚簇索引"></a>1.6.4.4 创建聚簇索引</h5><p>MYSQL Innodb 不支持单独建立聚簇索引。在此不列出。</p><h5 id="1-6-4-5-创建-HASH-索引"><a href="#1-6-4-5-创建-HASH-索引" class="headerlink" title="1.6.4.5 创建 HASH 索引"></a>1.6.4.5 创建 HASH 索引</h5><ul><li>对员工的雇佣日期创建 HASH 索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_hash_hiredate <span class="keyword">USING</span> HASH <span class="keyword">ON</span> employees (hire_date); </span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679933200028-3cd2db1b-ff6b-4701-a45f-eb774a1dd621.png" alt="image.png"><br>注：MYSQL 创建 HASH 索引的语法和书中给出的语法稍有不同。</li></ul><h5 id="1-6-4-6-修改索引名称"><a href="#1-6-4-6-修改索引名称" class="headerlink" title="1.6.4.6 修改索引名称"></a>1.6.4.6 修改索引名称</h5><p>注：修改索引名称通过先删除再添加实现。</p><h5 id="1-6-4-7-查询表上的已有索引"><a href="#1-6-4-7-查询表上的已有索引" class="headerlink" title="1.6.4.7 查询表上的已有索引"></a>1.6.4.7 查询表上的已有索引</h5><ul><li>查询员工表上的已有索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> employees;</span><br><span class="line">MariaDB [employees]<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+------------+-------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>     <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name          <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+------------+-------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> employees <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> emp_no      <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">299290</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> employees <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> idx_emp_no        <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> emp_no      <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">299290</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> employees <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_name          <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> first_name  <span class="operator">|</span> A         <span class="operator">|</span>        <span class="number">2672</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> employees <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_name          <span class="operator">|</span>            <span class="number">2</span> <span class="operator">|</span> last_name   <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">299290</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> employees <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_hash_hiredate <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> hire_date   <span class="operator">|</span> A         <span class="operator">|</span>       <span class="number">10688</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+------------+-------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679933307982-4e49f5fd-9a35-499e-a815-b145f1d115aa.png" alt="image.png"></li></ul><h5 id="1-6-4-8-分析某个-SQL-语句执行时是否使用了索引"><a href="#1-6-4-8-分析某个-SQL-语句执行时是否使用了索引" class="headerlink" title="1.6.4.8 分析某个 SQL 语句执行时是否使用了索引"></a>1.6.4.8 分析某个 SQL 语句执行时是否使用了索引</h5><ul><li>分析从员工表上查询某个日期雇佣的员工是否使用了索引。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span>  <span class="keyword">FROM</span> employees  <span class="keyword">WHERE</span> hire_date<span class="operator">=</span><span class="string">&#x27;1990-01-01&#x27;</span>; </span><br></pre></td></tr></table></figure>得到结果如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [employees]<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span>  <span class="keyword">FROM</span> employees  <span class="keyword">WHERE</span> hire_date<span class="operator">=</span><span class="string">&#x27;1990-01-01&#x27;</span>; <span class="operator">+</span><span class="comment">------+-------------+-----------+------+-------------------+-------------------+---------+-------+------+-------+ | id   | select_type | table     | type | possible_keys     | key               | key_len | ref   | rows | Extra | +------+-------------+-----------+------+-------------------+-------------------+---------+-------+------+-------+ |    1 | SIMPLE      | employees | ref  | idx_hash_hiredate | idx_hash_hiredate | 3       | const |   65 |       | +------+-------------+-----------+------+-------------------+-------------------+---------+-------+------+-------+ 1 row in set (0.00 sec) </span></span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679933406477-c240b693-5e27-45d3-a059-f87ad816888f.png" alt="image.png"></li></ul><h5 id="1-6-4-9-验证索引效率"><a href="#1-6-4-9-验证索引效率" class="headerlink" title="1.6.4.9 验证索引效率"></a>1.6.4.9 验证索引效率</h5><p>首先验证复合索引，在有索引的情况下，统计指定名字的员工数目。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name<span class="operator">=</span><span class="string">&#x27;Georgi&#x27;</span> <span class="keyword">AND</span> last_name<span class="operator">=</span><span class="string">&#x27;Facello&#x27;</span>; </span><br></pre></td></tr></table></figure><p>得到结果为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679933463899-9c5da205-1f9b-4618-a614-89dda74df666.png" alt="image.png"><br>然后去掉复合索引，再次执行，结果为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679933611497-36d2bcea-87c6-4fdf-811e-5f833ef44030.png" alt="image.png"><br>结果显示复合索引提高了查询效率。<br />然后验证哈希索引，在有索引的情况下，统计指定雇佣日期的员工数目。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> hire_date<span class="operator">=</span><span class="string">&#x27;1990-01-01&#x27;</span>; </span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">65</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679933873462-894fad3b-ec25-4a83-9925-3426395b198f.png" alt="image.png"><br>去掉索引，然后在查询，结果为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">65</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679933946715-b31c89c6-b70f-4bf4-b2a2-3224aecd59e5.png" alt="image.png"><br>结果显示哈希索引提高了查询效率。</p><h4 id="1-6-5-思考"><a href="#1-6-5-思考" class="headerlink" title="1.6.5 思考"></a>1.6.5 思考</h4><ul><li>在一个表的多个字段上创建的复合索引，与在相应的每个字段上创建的多个简单索引有何异同？请设计相应的例子加以验证。</li></ul><p>可以直接创建两个在名字上的简单索引然后测试即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_first_name</span><br><span class="line"><span class="keyword">ON</span> employees(first_name);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_last_name</span><br><span class="line"><span class="keyword">ON</span> employees(last_name);</span><br><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> first_name<span class="operator">=</span><span class="string">&#x27;Georgi&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> last_name<span class="operator">=</span><span class="string">&#x27;Facello&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------+-------------+-----------+-------------+------------------------------+------------------------------+---------+------+------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>     <span class="operator">|</span> type        <span class="operator">|</span> possible_keys                <span class="operator">|</span> key                          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+-----------+-------------+------------------------------+------------------------------+---------+------+------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> employees <span class="operator">|</span> index_merge <span class="operator">|</span> idx_first_name,idx_last_name <span class="operator">|</span> idx_last_name,idx_first_name <span class="operator">|</span> <span class="number">66</span>,<span class="number">58</span>   <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">intersect</span>(idx_last_name,idx_first_name); <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+-----------+-------------+------------------------------+------------------------------+---------+------+------+-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679934103580-ed6ec537-b45d-4943-9339-396a1e175b64.png" alt="image.png"><br>也即 MYSQL 内部和执行了对多个单列索引合并为一个复合索引的优化，此时效率不受影响。<br />对于已定义的复合索引，从最左侧开始的列是可用的，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Facello&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+-----------+-------+---------------+----------+---------+------+--------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>     <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+-----------+-------+---------------+----------+---------+------+--------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> employees <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">124</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">299290</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+-----------+-------+---------------+----------+---------+------+--------+--------------------------+</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679934586947-0c62c110-0514-48e0-b241-b03036175e25.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679934604084-3cde6fae-42ab-46b9-8071-cebab4b8b096.png" alt="image.png"><br>这里在已定义了复合索引的情况下只查询第二个条件，发现索引没有被采用，而是进行了全表扫描。</p><h4 id="聚合索引"><a href="#聚合索引" class="headerlink" title="聚合索引"></a>聚合索引</h4><p><strong>查询时使用联合索引的一个字段，如果这个字段在联合索引中所有字段的第一个，那就会用到索引，否则就无法使用到索引。</strong><br />例如你有一个 学生表。<br />字段包含 学号， 班级， 姓名，性别， 出生年月日。<br />你创建一个 组合索引 （ 班级， 姓名）<br />那么</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  学生表  <span class="keyword">WHERE</span>  班级<span class="operator">=</span><span class="string">&#x27;2010级3班&#x27;</span>  <span class="keyword">AND</span>  姓名<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>  </span><br></pre></td></tr></table></figure><p>将使用索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  学生表  <span class="keyword">WHERE</span>  班级<span class="operator">=</span><span class="string">&#x27;2010级3班&#x27;</span>       </span><br></pre></td></tr></table></figure><p>将使用索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  学生表  <span class="keyword">WHERE</span>  姓名<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span> </span><br></pre></td></tr></table></figure><p> 将不使用索引。</p><h4 id="单独索引"><a href="#单独索引" class="headerlink" title="单独索引"></a>单独索引</h4><p>删除掉上面的索引<br />再创建两个 独立索引<br />索引1 （ 班级）<br />索引2 （ 姓名）<br />那么</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  学生表  <span class="keyword">WHERE</span>  班级<span class="operator">=</span><span class="string">&#x27;2010级3班&#x27;</span>  <span class="keyword">AND</span>  姓名<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>   </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将根据数据库的分析信息， 自动选择使用索引1或者索引2中的一个 （理论上会使用 索引2， 因为 姓名&#x3D;张三的人少， 优先找到所有 姓名为 张三的人以后， 然后再从这些数据中， 找班级 &#x3D; ‘2010级3班‘的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  学生表  <span class="keyword">WHERE</span>  班级<span class="operator">=</span><span class="string">&#x27;2010级3班&#x27;</span>       </span><br></pre></td></tr></table></figure><p>将使用索引1 .</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  学生表  <span class="keyword">WHERE</span>  姓名<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>      </span><br></pre></td></tr></table></figure><p>将使用索引2。</p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 实验作业 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Experiment3</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment3/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-3-数据高级查询实验"><a href="#1-3-数据高级查询实验" class="headerlink" title="1.3 数据高级查询实验"></a>1.3 数据高级查询实验</h3><h4 id="1-3-1-实验目的"><a href="#1-3-1-实验目的" class="headerlink" title="1.3.1 实验目的"></a>1.3.1 实验目的</h4><p>掌握 SQL 嵌套查询和集合查询等各种高级查询的设计方法等。</p><h4 id="1-3-2-实验内容和要求"><a href="#1-3-2-实验内容和要求" class="headerlink" title="1.3.2 实验内容和要求"></a>1.3.2 实验内容和要求</h4><p>针对 TPC-H 数据库，正确分析用户查询要求，设计各种嵌套查询和集合查询。</p><h4 id="1-3-3-实验重点和难点"><a href="#1-3-3-实验重点和难点" class="headerlink" title="1.3.3 实验重点和难点"></a>1.3.3 实验重点和难点</h4><p>实验重点：嵌套查询。<br />实验难点：相关子查询、多层 EXIST 嵌套查询。</p><h4 id="1-3-4-实验内容记录"><a href="#1-3-4-实验内容记录" class="headerlink" title="1.3.4 实验内容记录"></a>1.3.4 实验内容记录</h4><h5 id="1-3-4-1-IN-嵌套查询"><a href="#1-3-4-1-IN-嵌套查询" class="headerlink" title="1.3.4.1 IN 嵌套查询"></a>1.3.4.1 IN 嵌套查询</h5><ul><li>查询财务部门经理的工资记录。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.emp_no, first_name, last_name, salary, </span><br><span class="line">  s.from_date, s.to_date</span><br><span class="line"><span class="keyword">FROM</span> salaries s, employees e</span><br><span class="line"><span class="keyword">WHERE</span> s.emp_no<span class="operator">=</span>e.emp_no</span><br><span class="line"><span class="keyword">AND</span> s.emp_no <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> dm.emp_no</span><br><span class="line">    <span class="keyword">FROM</span> dept_manager dm, departments d</span><br><span class="line">    <span class="keyword">WHERE</span> d.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> d.dept_no<span class="operator">=</span>dm.dept_no</span><br><span class="line">);</span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679023408993-940c0352-5fc8-4880-a76c-f1a55c674dfe.png" alt="image.png"></li></ul><h5 id="1-3-4-2-单层-EXISTS-嵌套查询"><a href="#1-3-4-2-单层-EXISTS-嵌套查询" class="headerlink" title="1.3.4.2 单层 EXISTS 嵌套查询"></a>1.3.4.2 单层 EXISTS 嵌套查询</h5><p>注：带 EXISTS 谓词的子查询不一定能被其它形式的子查询等价替换。</p><ul><li>统计（曾经）在财务部门的员工数量。</li></ul><p>使用 EXISTS 谓词可以理解为找出这样的员工，该员工存在部门为财务的元组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> de.emp_no)</span><br><span class="line"><span class="keyword">FROM</span> dept_emp de</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> departments d</span><br><span class="line">  <span class="keyword">WHERE</span> d.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> d.dept_no<span class="operator">=</span>de.dept_no</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果用两表连接查询，可以实现相似的语义（语义存在细微区别，前者是存在语义，后者是计数语义）。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679189197623-24b6d300-0980-4093-9003-3a3e7362d080.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> de.emp_no)</span><br><span class="line"><span class="keyword">FROM</span> dept_emp de, departments d</span><br><span class="line"><span class="keyword">WHERE</span> de.dept_no<span class="operator">=</span>d.dept_no</span><br><span class="line"><span class="keyword">AND</span> d.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679189229053-e302be7e-2555-4c67-9b61-407efa59f10e.png" alt="image.png"></p><h5 id="1-3-4-3-两层-EXISTS-嵌套查询"><a href="#1-3-4-3-两层-EXISTS-嵌套查询" class="headerlink" title="1.3.4.3 两层 EXISTS 嵌套查询"></a>1.3.4.3 两层 EXISTS 嵌套查询</h5><p>注意：SQL 查询的结果是一个集合，实际上就是一层全称谓词。如果给出的条件中再出现全称谓词，则可以转换为存在谓词进行查询。<br />注意：嵌套查询如果进行了相关查询，则实际上就是一个外层和内层进行笛卡尔积然后对结果集合进行筛选（嵌套内层进行筛选）的过程。</p><ul><li>查询（曾经）在所有部门待过的员工。</li></ul><p>转换为，不存在这样的部门，员工没有待过。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> departments d</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> dept_emp de</span><br><span class="line">    <span class="keyword">WHERE</span> d.dept_no<span class="operator">=</span>de.dept_no</span><br><span class="line">    <span class="keyword">AND</span> e.emp_no<span class="operator">=</span>de.emp_no</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>要先看select的语句代表的含义<ol><li><code>SELECT * FROM departments d</code> 选择所有的部门 – 可以理解为遍历所有的部门</li><li><code>SELECT * FROM dept_emp de WHERE d.dept_no=de.dept_no AND e.emp_no=de.emp_no</code> 选择某个员工在某个部门的工作信息</li></ol></li><li>直观理解：从<code>not exists</code>的语义上理解：不存在一个部门，该员工没有待过（没有工作信息） -&gt;要查找在所有部门都工作过的员工</li><li>从内到外理解：对于每一个员工e，检查每一个部门d，判断有无工作记录<ol><li>第二层子查询：判断有无工作记录，如果没有工作记录，第六行的<code>not exists</code>返回为<code>true</code> -&gt; 存在这样一个部门d，该员工在该部门没有工作信息 -&gt;第一层子查询返回的结果不是为空，第三行的<code>not exists</code>为<code>false</code>，因此第一行的<code>selcet</code>就不会执行</li><li>第二层子查询：如果有工作记录，第六行的<code>not exists</code>返回为<code>false</code> -&gt; 不存在这样一个部门d，该员工在该部门没有工作信息 ，第一层子查询中的<code>select</code>不会执行 -&gt; 该员工在部门d中有工作过，但是无法保证在其他部门也有工作记录，所以第一层子查询会挑选一个新的部门d后，重新进入第二层子查询判断 -&gt; 全部判断完后，如果仍然没有部门，说明第三行第三行的<code>not exists</code>为<code>true</code>，因此第一行的<code>selcet</code>就会执行 -&gt;得到想要的结果</li></ol></li></ol><h5 id="1-3-4-4-FROM-子句中的嵌套查询"><a href="#1-3-4-4-FROM-子句中的嵌套查询" class="headerlink" title="1.3.4.4 FROM 子句中的嵌套查询"></a>1.3.4.4 FROM 子句中的嵌套查询</h5><p>FROM 子句中进行嵌套是将嵌套块生成临时表进行查询。</p><ul><li>统计所有员工的平均总工资。</li></ul><p>首先需要一张员工的总工资表，然后根据总工资表进行平均数计算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(total_salary)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> total_emp_no) avg</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> emp_no total_emp_no, <span class="built_in">SUM</span>(salary) total_salary</span><br><span class="line">  <span class="keyword">FROM</span> salaries</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no</span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span> total;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> avg         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">604887.4671</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679023386848-922a18bd-7dc2-40e2-9c2f-5bf458eb620c.png" alt="image.png"></p><h5 id="1-3-4-5-集合查询（交、并、差）"><a href="#1-3-4-5-集合查询（交、并、差）" class="headerlink" title="1.3.4.5 集合查询（交、并、差）"></a>1.3.4.5 集合查询（交、并、差）</h5><p>与集合运算的要求一致，<strong>集合查询时进行集合运算的集合必须具有相同的列数以及对应有相同的数据类型。</strong></p><ul><li><p>统计财务（Finance）部门和销售（Sales）部门的历史员工数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> emp_no)</span><br><span class="line"><span class="keyword">FROM</span> dept_emp de, departments d</span><br><span class="line"><span class="keyword">WHERE</span> de.dept_no<span class="operator">=</span>d.dept_no</span><br><span class="line"><span class="keyword">AND</span> d.dept_name <span class="keyword">IN</span> (<span class="string">&#x27;Finance&#x27;</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> emp_no)</span><br><span class="line"><span class="keyword">FROM</span> dept_emp de, departments d</span><br><span class="line"><span class="keyword">WHERE</span> de.dept_no<span class="operator">=</span>d.dept_no</span><br><span class="line"><span class="keyword">AND</span> d.dept_name <span class="keyword">IN</span> (<span class="string">&#x27;Sales&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> emp_no) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="operator">|</span>                  <span class="number">17346</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>                  <span class="number">52245</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679024060876-0dd8bd4e-c2bc-45d8-99a8-2634e8a3a407.png" alt="image.png"></p></li><li><p>查询在财务（Finance）部门和销售（Sales）部门都工作过的员工。</p></li></ul><p><strong>注：MYSQL 目前不支持交运算</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> de.emp_no</span><br><span class="line"><span class="keyword">FROM</span> dept_emp de, departments d</span><br><span class="line"><span class="keyword">WHERE</span> de.dept_no<span class="operator">=</span>d.dept_no</span><br><span class="line"><span class="keyword">AND</span> d.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> de.emp_no</span><br><span class="line"><span class="keyword">FROM</span> dept_emp de, departments d</span><br><span class="line"><span class="keyword">WHERE</span> de.dept_no<span class="operator">=</span>d.dept_no</span><br><span class="line"><span class="keyword">AND</span> d.dept_name<span class="operator">=</span><span class="string">&#x27;Sales&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="模拟交运算"><a href="#模拟交运算" class="headerlink" title="模拟交运算"></a>模拟交运算</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> emp_no)</span><br><span class="line"><span class="keyword">from</span> dept_emp de,departments d</span><br><span class="line"><span class="keyword">where</span> de.dept_no <span class="operator">=</span> d.dept_no</span><br><span class="line"><span class="keyword">and</span> d.dept_name <span class="operator">=</span> <span class="string">&#x27;Finance&#x27;</span></span><br><span class="line"><span class="keyword">and</span> emp_no <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> emp_no</span><br><span class="line"><span class="keyword">from</span> dept_emp de,departments d</span><br><span class="line"><span class="keyword">where</span> de.dept_no <span class="operator">=</span> d.dept_no</span><br><span class="line"><span class="keyword">and</span> d.dept_name <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679031071655-36a0a898-1259-4e7c-b4a7-4dd44311528f.png" alt="image.png"></p><h4 id="1-3-5-思考"><a href="#1-3-5-思考" class="headerlink" title="1.3.5 思考"></a>1.3.5 思考</h4><h5 id="试分析什么类型的查询可以用连接查询实现，什么类型的查询只能用嵌套查询实现？"><a href="#试分析什么类型的查询可以用连接查询实现，什么类型的查询只能用嵌套查询实现？" class="headerlink" title="试分析什么类型的查询可以用连接查询实现，什么类型的查询只能用嵌套查询实现？"></a>试分析什么类型的查询可以用连接查询实现，什么类型的查询只能用嵌套查询实现？</h5><p><strong>连接查询在算法实现上，一定可以通过嵌套循环实现，因此连接查询一定能被嵌套查询等价替换。由于嵌套查询在嵌套条件上提供了一些语义，因此嵌套查询不一定能被转换为连接查询。</strong><br />从语义上看，<strong>连接查询首先是对两个表进行笛卡尔积运算（不带条件的），然后对得到的元组集合进行条件筛选，因此连接查询适用于需要将多个表的属性关联起来的查询需求。嵌套查询则是外层表和内层表进行嵌套罗列，嵌套时可以使用 IN、ANY、ALL、EXISTS 谓词。</strong>这些谓词的使用使得嵌套查询语义不一定能被连接查询实现。<br />连接查询在算法实现上不一定需要通过嵌套循环实现，因此效率往往高于嵌套查询。如：<br />统计在财务（Finance）部门的员工人数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(e.emp_no)</span><br><span class="line"><span class="keyword">FROM</span> employees e, dept_emp de, departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.emp_no<span class="operator">=</span>de.emp_no</span><br><span class="line"><span class="keyword">AND</span> de.dept_no<span class="operator">=</span>d.dept_no</span><br><span class="line"><span class="keyword">AND</span> d.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(e.emp_no) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span>           <span class="number">17346</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(e.emp_no)</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> dept_emp de</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> departments d</span><br><span class="line">    <span class="keyword">WHERE</span> e.emp_no<span class="operator">=</span>de.emp_no</span><br><span class="line">    <span class="keyword">AND</span> de.dept_no<span class="operator">=</span>d.dept_no</span><br><span class="line">    <span class="keyword">AND</span> d.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span> </span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(e.emp_no) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span>           <span class="number">17346</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.40</span> sec)</span><br></pre></td></tr></table></figure><p>可以看出来，三个表的连接查询相比三个表的嵌套查询在速度上要快很多。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679189161622-cf87a30e-1b08-4574-a58f-05d1ea5081fb.png" alt="image.png"></p><h5 id="试分析不相关子查询和相关子查询的区别。"><a href="#试分析不相关子查询和相关子查询的区别。" class="headerlink" title="试分析不相关子查询和相关子查询的区别。"></a>试分析不相关子查询和相关子查询的区别。</h5><p>两者区别在于子查询是否引用外层查询的属性。若不引用，则两个查询完全隔离，相当于是两个独立的查询。<br /><strong>从实现上看，相关子查询由于存在相关引用，因此子查询被执行多次，而不相关子查询由于是一个独立的查询，因此只执行一次。</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679194870767-7df95a02-191d-4808-93a8-3fe401439677.png" alt="image.png"><br>相关子查询因为耗时过长，导致出现错误。<br />说明不相关子查询效率高于相关子查询。相关子查询可以嵌套在多个层次中，但是嵌套层次越多，效率越低。</p><h3 id="1-4-数据更新实验"><a href="#1-4-数据更新实验" class="headerlink" title="1.4 数据更新实验"></a>1.4 数据更新实验</h3><h4 id="1-4-1-实验目的"><a href="#1-4-1-实验目的" class="headerlink" title="1.4.1 实验目的"></a>1.4.1 实验目的</h4><p>熟悉数据库的数据更新操作，能够使用 SQL 语句对数据库进行数据的插入、修改、删除操作。</p><h4 id="1-4-2-实验内容和要求"><a href="#1-4-2-实验内容和要求" class="headerlink" title="1.4.2 实验内容和要求"></a>1.4.2 实验内容和要求</h4><p>针对 employees 数据库设计单元组插入、批量修改插入、修改数据和删除数据等 SQL 语句。理解和掌握 INSERT、UPDATE 和 DELETE 语法结构的各个组成成分，结合嵌套 SQL 子查询，分别设计几种不同形式的插入、修改和删除的语句，并调试成功。</p><h4 id="1-4-3-实验重点和难点"><a href="#1-4-3-实验重点和难点" class="headerlink" title="1.4.3 实验重点和难点"></a>1.4.3 实验重点和难点</h4><p>实验重点：插入、修改和删除数据的 SQL。<br />实验难点：与嵌套 SQL 子查询相结合的插入、修改和删除数据的 SQL 语句；利用一个表的数据来插入、修改和删除另外一个表的数据。</p><h4 id="1-4-4-实验内容记录"><a href="#1-4-4-实验内容记录" class="headerlink" title="1.4.4 实验内容记录"></a>1.4.4 实验内容记录</h4><h5 id="1-4-4-1-INSERT-基本语句"><a href="#1-4-4-1-INSERT-基本语句" class="headerlink" title="1.4.4.1 INSERT 基本语句"></a>1.4.4.1 INSERT 基本语句</h5><p>插入一条雇员记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">500000</span>,<span class="string">&#x27;1990-05-06&#x27;</span>,<span class="string">&#x27;San&#x27;</span>,<span class="string">&#x27;Zhang&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;2010-09-05&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(emp_no,birth_date,first_name,last_name,gender,hire_date)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">500000</span>,<span class="string">&#x27;1990-05-06&#x27;</span>,<span class="string">&#x27;San&#x27;</span>,<span class="string">&#x27;Zhang&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;2010-09-05&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="1-4-4-2-批量数据-INSERT-语句"><a href="#1-4-4-2-批量数据-INSERT-语句" class="headerlink" title="1.4.4.2 批量数据 INSERT 语句"></a>1.4.4.2 批量数据 INSERT 语句</h5><ul><li>创建一个男员工表和女员工表，并将所有男员工插入到男员工表，将所有女员工插入到女员工表。</li></ul><p>先创建两张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees_female </span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees_male</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679190726964-1c923626-8717-4180-8d95-3fa48c2d2ea3.png" alt="image.png"><br>注：这里的条件永不满足，用来复制表模式，而不复制任何数据。<br />然后将数据录入两张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees_female</span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.gender<span class="operator">=</span><span class="string">&#x27;F&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees_male</span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.gender<span class="operator">=</span><span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679191000028-7b98591f-f663-49ee-a32f-251ac25c709a.png" alt="image.png"></p><ul><li>创建一个部门员工人数统计表，并统计所有部门的历史员工人数。</li></ul><p>先创建表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept_emp_count(   dept_no <span class="type">CHAR</span>(<span class="number">4</span>),   emp_count <span class="type">INT</span>); </span><br></pre></td></tr></table></figure><p>然后批量录入数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept_emp_count </span><br><span class="line"><span class="keyword">SELECT</span> de.dept_no, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> emp_no)</span><br><span class="line"><span class="keyword">FROM</span> dept_emp de </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> de.dept_no;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679191180192-a911260a-516f-4448-83c1-9a403021ca8d.png" alt="image.png"></p><h5 id="1-4-4-3-UPDATE-语句（修改部分记录的部分列值）"><a href="#1-4-4-3-UPDATE-语句（修改部分记录的部分列值）" class="headerlink" title="1.4.4.3 UPDATE 语句（修改部分记录的部分列值）"></a>1.4.4.3 UPDATE 语句（修改部分记录的部分列值）</h5><ul><li>将所有 1985 年及以前入职，职位为 Assistant Engineer 的员工的职位修改为 Engineer 。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> titles t</span><br><span class="line"><span class="keyword">set</span> t.title <span class="operator">=</span> <span class="string">&#x27;Engineer&#x27;</span></span><br><span class="line"><span class="keyword">where</span> t.emp_no <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> e.emp_no</span><br><span class="line">    <span class="keyword">from</span> employees e</span><br><span class="line">    <span class="keyword">where</span> e.hire_date <span class="operator">&lt;</span> <span class="string">&#x27;1985-01-01&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679191795920-4935b898-6857-44af-989b-517f482a5517.png" alt="image.png"></li></ul><h5 id="1-4-4-4-UPDATE-语句（利用一个表的数据更新另一个表的数据）"><a href="#1-4-4-4-UPDATE-语句（利用一个表的数据更新另一个表的数据）" class="headerlink" title="1.4.4.4 UPDATE 语句（利用一个表的数据更新另一个表的数据）"></a>1.4.4.4 UPDATE 语句（利用一个表的数据更新另一个表的数据）</h5><ul><li>更新部门员工人数统计表（假设表已经存在）。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dept_emp_count decount</span><br><span class="line"><span class="keyword">SET</span> decount.emp_count <span class="operator">=</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> de.emp_no)</span><br><span class="line">  <span class="keyword">FROM</span> dept_emp de</span><br><span class="line">  <span class="keyword">WHERE</span> de.dept_no<span class="operator">=</span>decount.dept_no</span><br><span class="line">);</span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679192033840-b3ac49b0-e069-48fc-85e5-ded1c4310c63.png" alt="image.png"></li></ul><h5 id="1-4-4-5-DELETE-基本语句（删除给定条件的所有记录）"><a href="#1-4-4-5-DELETE-基本语句（删除给定条件的所有记录）" class="headerlink" title="1.4.4.5 DELETE 基本语句（删除给定条件的所有记录）"></a>1.4.4.5 DELETE 基本语句（删除给定条件的所有记录）</h5><ul><li>删除 2000 年以前的工资记录。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">WHERE</span> from_date <span class="operator">&lt;</span> <span class="string">&#x27;2000-01-01&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> to_date <span class="operator">&lt;</span> <span class="string">&#x27;2000-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679192144174-84cc8842-5ac1-4b94-92a8-c40334d9586b.png" alt="image.png"></li></ul><h4 id="1-4-5-思考"><a href="#1-4-5-思考" class="headerlink" title="1.4.5 思考"></a>1.4.5 思考</h4><h5 id="请分析数据库模式更新和数据更新-SQL-语句的异同。"><a href="#请分析数据库模式更新和数据更新-SQL-语句的异同。" class="headerlink" title="请分析数据库模式更新和数据更新 SQL 语句的异同。"></a>请分析数据库模式更新和数据更新 SQL 语句的异同。</h5><p>两者的关键字不同，更新模式使用 ALTER TABLE ，更新数据使用 UPDATE 。<br />数据库模式更新用到的 sql 语句有 create, drop, alter 等，它们可以创建或者删除表、视图、索引等对象，或者修改它们的属性或者约束。<br />数据更新用到的 sql 语句有 insert, update, delete 等，它们可以向表中插入新的记录，或者修改或者删除已有的记录。</p><h5 id="请分析数据库系统除了-INSERT、UPDATE-和-DELETE-等基本的数据更新语句之外，还有哪些可以用来更新数据库基本表数据的-SQL-语句？"><a href="#请分析数据库系统除了-INSERT、UPDATE-和-DELETE-等基本的数据更新语句之外，还有哪些可以用来更新数据库基本表数据的-SQL-语句？" class="headerlink" title="请分析数据库系统除了 INSERT、UPDATE 和 DELETE 等基本的数据更新语句之外，还有哪些可以用来更新数据库基本表数据的 SQL 语句？"></a>请分析数据库系统除了 INSERT、UPDATE 和 DELETE 等基本的数据更新语句之外，还有哪些可以用来更新数据库基本表数据的 SQL 语句？</h5><p>如 truncate 。<br />merge into 语句，可以根据一个表或者视图中的数据，对另一个表中的数据进行插入、修改或者删除操作。<br />truncate 语句，可以快速地删除表中的所有数据，但是不影响表的结构和约束。<br />drop 语句，可以删除整个表及其相关的对象，例如索引、触发器等。<br />这些 sql 语句在不同的数据库系统中可能有不同的用法和限制，您需要根据您使用的数据库系统来选择合适的语句。<br />merge into 语句的基本语法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> 目标表</span><br><span class="line"><span class="keyword">using</span> 源表</span><br><span class="line"><span class="keyword">on</span> (匹配条件)</span><br><span class="line"><span class="keyword">when</span> matched <span class="keyword">then</span> <span class="keyword">update</span> <span class="keyword">set</span> 目标表.字段 <span class="operator">=</span> 源表.字段</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">not</span> matched <span class="keyword">then</span> <span class="keyword">insert</span> (目标表.字段) <span class="keyword">values</span> (源表.字段)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，目标表和源表可以是实际的表、视图或者子查询，匹配条件是用来判断两个表中的数据是否相同的条件，update 和 insert 是用来指定当数据匹配或者不匹配时要执行的操作。</p><ul><li>如果目标表有源表没有的数据，则保留该部分数据</li><li>如果源表有目标表没有的数据，触发<code>not matched</code>进行插入</li><li>如果源表的数据和目标表的数据相同，触发<code>matched</code>进行更新</li></ul><h3 id="1-5-视图实验"><a href="#1-5-视图实验" class="headerlink" title="1.5 视图实验"></a>1.5 视图实验</h3><h4 id="1-5-1-实验目的"><a href="#1-5-1-实验目的" class="headerlink" title="1.5.1 实验目的"></a>1.5.1 实验目的</h4><p>熟悉 SQL 语言有关视图的操作，能够熟练使用 SQL 语句来创建需要的视图，定义数据库外模式，并能使用所创建的视图实现数据管理。</p><h4 id="1-5-2-实验内容和要求"><a href="#1-5-2-实验内容和要求" class="headerlink" title="1.5.2 实验内容和要求"></a>1.5.2 实验内容和要求</h4><p>针对给定的数据库模式，以及相应的应用需求，创建视图和带 WITH CHECK OPTION 的视图，并验证 WITH CHECK OPTION 选项的有效性。理解和掌握视图消解执行原理，掌握可更新视图和不可更新视图的区别。</p><h4 id="1-5-3-实验重点和难点"><a href="#1-5-3-实验重点和难点" class="headerlink" title="1.5.3 实验重点和难点"></a>1.5.3 实验重点和难点</h4><p>实验重点：创建视图。<br />实验难点：可更新的视图和不可更新的视图之区别，WITH CHECK OPTION 的验证。</p><h4 id="1-5-4-实验内容记录"><a href="#1-5-4-实验内容记录" class="headerlink" title="1.5.4 实验内容记录"></a>1.5.4 实验内容记录</h4><h5 id="1-5-4-1-创建视图（省略视图列名）"><a href="#1-5-4-1-创建视图（省略视图列名）" class="headerlink" title="1.5.4.1 创建视图（省略视图列名）"></a>1.5.4.1 创建视图（省略视图列名）</h5><ul><li>创建男性员工视图。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_emploree_male <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.gender<span class="operator">=</span><span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679243398174-3690032f-47b9-4501-9ccd-fc8da3533240.png" alt="image.png"></li></ul><h5 id="1-5-4-2-创建视图（不能省略列名的情况）"><a href="#1-5-4-2-创建视图（不能省略列名的情况）" class="headerlink" title="1.5.4.2 创建视图（不能省略列名的情况）"></a>1.5.4.2 创建视图（不能省略列名的情况）</h5><p><strong>如果目标列不是单纯的属性名（如聚集函数或表达式），则应该给出列名。</strong></p><ul><li>创建部门历史员工总数的视图。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_dept_emp_num(dept_no, emp_count) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_no, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> emp_no)</span><br><span class="line"><span class="keyword">FROM</span> dept_emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_no;</span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679243719772-d7e6677a-9809-4caa-8813-3df83a9e81b6.png" alt="image.png"></li></ul><h5 id="1-5-4-3-创建视图（WITH-CHECK-OPTION）"><a href="#1-5-4-3-创建视图（WITH-CHECK-OPTION）" class="headerlink" title="1.5.4.3 创建视图（WITH CHECK OPTION）"></a>1.5.4.3 创建视图（WITH CHECK OPTION）</h5><p>WITH CHECK OPTION 使得在对视图进行操作时，会验证操作是否符合视图的条件。<br />例如，对男性员工视图进行插入操作，插入一个女员工信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span></span><br><span class="line">v_emploree_male</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">500000</span>,<span class="string">&#x27;1990-05-06&#x27;</span>,<span class="string">&#x27;San&#x27;</span>,<span class="string">&#x27;Zhang&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;2010-09-05&#x27;</span>);</span><br></pre></td></tr></table></figure><p>由男性员工视图没有 WITH CHECK OPTION 语句，因此插入成功，这使得视图的封装性被破坏。<br />加入选项：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_emploree_male_check <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.gender<span class="operator">=</span><span class="string">&#x27;M&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><p>再执行插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span></span><br><span class="line">v_emploree_male_check</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">500000</span>,<span class="string">&#x27;1990-05-06&#x27;</span>,<span class="string">&#x27;San&#x27;</span>,<span class="string">&#x27;Zhang&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;2010-09-05&#x27;</span>);</span><br></pre></td></tr></table></figure><p>会得到错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">1369</span> (HY000): <span class="keyword">CHECK</span> OPTION failed <span class="string">&#x27;employees.v_emploree_male_check&#x27;</span> </span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679243791818-8285f56e-002b-4cb7-b455-eb4a045fd25a.png" alt="image.png"></p><h5 id="1-5-4-4-不可更新视图"><a href="#1-5-4-4-不可更新视图" class="headerlink" title="1.5.4.4 不可更新视图"></a>1.5.4.4 不可更新视图</h5><p><strong>如果为行列子集视图，则一定是可以更新的（如男性员工视图）。<br />如果不是，则不一定可以更新，如属性为聚集函数或表达式（如部门员工总数视图）。</strong></p><ul><li>尝试修改财务（Finance）部门员工总数为 0 并观察报错。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> v_dept_emp_num vden</span><br><span class="line"><span class="keyword">SET</span> emp_count<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> vden.dept_no<span class="operator">=</span>(</span><br><span class="line">  <span class="keyword">SELECT</span> d.dept_no</span><br><span class="line">  <span class="keyword">FROM</span> departments</span><br><span class="line">  <span class="keyword">WHERE</span> d.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Code: <span class="number">1064.</span> You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;dept_emp&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure>得到报错：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679243925611-36dbec92-f815-4218-82c0-208c629cf5b0.png" alt="image.png"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">1288</span> (HY000): The target <span class="keyword">table</span> vden <span class="keyword">of</span> the <span class="keyword">UPDATE</span> <span class="keyword">is</span> <span class="keyword">not</span> updatable</span><br></pre></td></tr></table></figure></li></ul><h5 id="1-5-4-5-删除视图"><a href="#1-5-4-5-删除视图" class="headerlink" title="1.5.4.5 删除视图"></a>1.5.4.5 删除视图</h5><p>删除未被引用的视图，直接删除即可。</p><ul><li>删除部门员工总数视图和男性员工视图。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> v_dept_emp_num; </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> v_emploree_male; </span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679243973020-bc4fc0b1-e068-421b-8a4b-d3a8d5a512af.png" alt="image.png"><br>删除视图时 CASCADE 语句的作用：<br />先建立两个视图：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_e_1 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> emp_no,birth_date,gender</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_e_2 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> emp_no,gender</span><br><span class="line"><span class="keyword">FROM</span> v_e_1;</span><br></pre></td></tr></table></figure>直接删除 v_e_1，<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> v_e_1; </span><br></pre></td></tr></table></figure>对于 MYSQL ，删除成功，但是会引起 v_e_2 查询报错。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">1356</span> (HY000): <span class="keyword">View</span> <span class="string">&#x27;employees.v_e_2&#x27;</span> <span class="keyword">references</span> invalid <span class="keyword">table</span>(s) <span class="keyword">or</span> <span class="keyword">column</span>(s) <span class="keyword">or</span> <span class="keyword">function</span>(s) <span class="keyword">or</span> definer<span class="operator">/</span>invoker <span class="keyword">of</span> <span class="keyword">view</span> lack rights <span class="keyword">to</span> use them </span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679273756944-ae45ce01-b022-4470-a1bf-62bcd1155ea5.png" alt="image.png"><br>不论使用RESTRICT 短语还是 CASCADE 短语结果都是一样。</li></ul><h4 id="1-5-5-思考"><a href="#1-5-5-思考" class="headerlink" title="1.5.5 思考"></a>1.5.5 思考</h4><ul><li>请分析视图和基本表在使用方面有哪些异同，并设计相应的例子加以验证。</li></ul><p><strong>视图的数据来源于最原始的基本表，也即视图本身不存放数据。<br />视图不一定都是可以修改的。</strong></p><ul><li>请具体分析修改基本表的结构对相应的视图会产生何种影响？</li></ul><p><strong>修改基本表后，可能导致视图不能正常工作。</strong><br />先创建一个测试表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> d1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> departments;</span><br></pre></td></tr></table></figure><p>并创建基于测试表的一个视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_d1 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> d1;</span><br></pre></td></tr></table></figure><p>然后调整测试表的结构，这里先尝试调整列的数据类型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> d1</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> dept_no <span class="type">INT</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Code: <span class="number">1366.</span> Incorrect <span class="type">integer</span> <span class="keyword">value</span>: <span class="string">&#x27;d009&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;dept_no&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>调整会触发警告，数据变为 0 。相应的视图也会同步改变。<br />如果删除一列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> d1</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> dept_name;</span><br></pre></td></tr></table></figure><p>此时查询视图会报告错误。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679245118264-f31a0a91-e74d-4222-ba31-1d2b18e58ae3.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error Code: <span class="number">1356.</span> <span class="keyword">View</span> <span class="string">&#x27;new_schema.v_d1&#x27;</span> <span class="keyword">references</span> invalid <span class="keyword">table</span>(s) <span class="keyword">or</span> <span class="keyword">column</span>(s) <span class="keyword">or</span> </span><br><span class="line"><span class="keyword">function</span>(s) <span class="keyword">or</span> definer<span class="operator">/</span>invoker <span class="keyword">of</span> <span class="keyword">view</span> lack rights <span class="keyword">to</span> use them</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 实验作业 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Experiment2</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment2/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-2-1-实验目的"><a href="#1-2-1-实验目的" class="headerlink" title="1.2.1 实验目的"></a>1.2.1 实验目的</h4><p>掌握 SQL 程序设计基本规范，熟练运用 SQL 语言实现数据基本查询，包括单表查询、分组统计查询和连接查询。</p><h4 id="1-2-2-实验内容和要求"><a href="#1-2-2-实验内容和要求" class="headerlink" title="1.2.2 实验内容和要求"></a>1.2.2 实验内容和要求</h4><p>针对 TPC-H 数据库设计各种表单查询 SQL 语句、分组统计查询语句；设计单个表针对自身的连接查询，设计多个表的连接查询。理解和掌握 SQL 查询语句各个字句的特点和作用，按照 SQL 程序设计规范写出具体的 SQL 查询语句，并调试通过。<br />说明：简单地说，SQL 程序设计规范包含 SQL 关键字大写、表名、属性名、存储过程名等标识符大小写混合、SQL 程序书写缩紧排列等变成规范。</p><h4 id="1-2-3-实验重点和难点"><a href="#1-2-3-实验重点和难点" class="headerlink" title="1.2.3 实验重点和难点"></a>1.2.3 实验重点和难点</h4><p>实验重点：分组统计查询、单表自身连接查询、多表连接查询。<br />实验难点：区分元组过滤条件和分组过滤条件；确定连接属性，正确设计连接条件。</p><h4 id="1-2-4-实验内容记录"><a href="#1-2-4-实验内容记录" class="headerlink" title="1.2.4 实验内容记录"></a>1.2.4 实验内容记录</h4><h5 id="1-2-4-1-单表查询（查询）"><a href="#1-2-4-1-单表查询（查询）" class="headerlink" title="1.2.4.1 单表查询（查询）"></a>1.2.4.1 单表查询（查询）</h5><ul><li>查询部门信息。</li></ul><p><code>SELECT dept_no, dept_name  FROM departments; </code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678879897133-a1a6396f-0c9d-476c-ad79-1ce5f83ae967.png" alt="image.png"></p><h5 id="1-2-4-2-单表查询（选择）"><a href="#1-2-4-2-单表查询（选择）" class="headerlink" title="1.2.4.2 单表查询（选择）"></a>1.2.4.2 单表查询（选择）</h5><ul><li>查询雇佣日期为 1990-01-01 的所有男性员工信息。</li></ul><p><code>SELECT *  FROM employees WHERE hire_date=&#39;1990-01-01&#39;    AND gender=&#39;M&#39;; </code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678879994792-4df39114-cab2-4b99-9ea1-56cf52f69342.png" alt="image.png"></p><h5 id="1-2-4-3-不带分组过滤条件的分组统计查询"><a href="#1-2-4-3-不带分组过滤条件的分组统计查询" class="headerlink" title="1.2.4.3 不带分组过滤条件的分组统计查询"></a>1.2.4.3 不带分组过滤条件的分组统计查询</h5><ul><li>查询所有员工的工资总额。</li></ul><p><code>SELECT emp_no, SUM(salary) FROM salaries GROUP BY emp_no; </code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678880255637-dec5e790-f38c-4565-a947-49b84ddde0c6.png" alt="image.png"></p><h5 id="1-2-4-4-带分组过滤条件的分组统计查询"><a href="#1-2-4-4-带分组过滤条件的分组统计查询" class="headerlink" title="1.2.4.4 带分组过滤条件的分组统计查询"></a>1.2.4.4 带分组过滤条件的分组统计查询</h5><ul><li>查询工资总额不低于 100 万的所有员工的工资总额。</li></ul><p><code>SELECT emp_no, SUM(salary) FROM salaries GROUP BY emp_no HAVING SUM(salary) &gt;= 1000000;</code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678880319152-6dcc8aa6-4b07-4982-bf7e-c67b91cae0f7.png" alt="image.png"> </p><h5 id="1-2-4-5-两表连接查询（普通连接）"><a href="#1-2-4-5-两表连接查询（普通连接）" class="headerlink" title="1.2.4.5 两表连接查询（普通连接）"></a>1.2.4.5 两表连接查询（普通连接）</h5><ul><li>查询所有 1990 年入职的员工职位。</li></ul><p><code>SELECT DISTINCT e.emp_no, first_name, last_name, hire_date, title FROM employees e, titles t WHERE e.emp_no=t.emp_no    AND hire_date     BETWEEN &#39;1990-01-01&#39;     AND &#39;1990-12-31&#39;;</code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678880670792-bd463012-7024-477a-8c27-ac82cf4307ec.png" alt="image.png"></p><h4 id="1-2-5-思考"><a href="#1-2-5-思考" class="headerlink" title="1.2.5 思考"></a>1.2.5 思考</h4><ul><li>不在 GROUP BY 子句中出现的属性，是否可以出现在 SELECT 子句中？请举例并上机验证。</li></ul><p>析：<br />GROUP BY 用于按相同属性分组，用来细化聚集函数的作用对象。<strong>使用 GROUP BY 子句后，查询结果集中每个分组只有一个元组</strong>，因此对于没有出现在 GROUP BY 子句中的属性，在 SELECT 子句中出现会出现问题。举例如：<br />查询所有员工的总工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no, <span class="built_in">SUM</span>(salary), salary</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no;</span><br></pre></td></tr></table></figure><p><code>**Error Code**: 1055. Expression #3 of SELECT list is not in GROUP BY clause and **contains nonaggregated column &#39;new_schema.salaries.salary&#39; which is not functionally dependent on columns in GROUP BY clause**; this is incompatible with sql_mode=only_full_group_by</code><br />会出现报错情况，认为<code>salary</code>无法通过<code>group by</code>进行聚合</p><ul><li>请举例说明分组统计查询中 WHERE 和 HAVING 有何区别？</li></ul><p>两者区别在于作用对象不同，<strong>WHERE 作用于基本表或视图，HAVING 作用于组。</strong>举例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no, <span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(salary)<span class="operator">&gt;</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678881202345-a0c2c2d9-7892-4e2e-866a-5b9c99c27234.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no, <span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">SUM</span>(salary)<span class="operator">&gt;</span><span class="number">1000000</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no;</span><br></pre></td></tr></table></figure><p><code>**ERROR** 1111 (HY000): Invalid use of group function</code><br /><strong>WHERE 子句中不能使用聚集函数作为条件表达式。</strong></p><p>连接查询速度是影响关系数据库性能的关键因素。请讨论如何提高连接查询速度，并进行实验验证。<br /><strong>连接操作中最慢的是嵌套循环算法，如果有序，或者有索引，则可以进行优化。</strong><br /><strong>如果连接条件只有等值比较，则容易优化（有序双指针比较）；</strong><br /><strong>如果连接条件能够建立索引，且事先已建立索引，则容易优化；</strong><br />举例：<br />查询在 1992-01-01 入职的员工及其所在部门信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> e.emp_no, d.dept_name, e.hire_date</span><br><span class="line">  <span class="keyword">FROM</span> employees e, dept_emp de, departments d</span><br><span class="line">  <span class="keyword">WHERE</span> e.emp_no<span class="operator">=</span>de.emp_no</span><br><span class="line">  <span class="keyword">AND</span> de.dept_no<span class="operator">=</span>d.dept_no</span><br><span class="line">  <span class="keyword">AND</span> e.hire_date<span class="operator">=</span><span class="string">&#x27;1992-01-01&#x27;</span></span><br><span class="line">) <span class="keyword">AS</span> C;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678959159777-a11a1443-ec8e-48e2-a004-e40e00145fce.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> e.emp_no, d.dept_name, e.hire_date</span><br><span class="line">  <span class="keyword">FROM</span> employees e, dept_emp de, departments d</span><br><span class="line">  <span class="keyword">WHERE</span> e.emp_no<span class="operator">=</span>de.emp_no</span><br><span class="line">  <span class="keyword">AND</span> de.dept_no<span class="operator">=</span>d.dept_no</span><br><span class="line">  <span class="keyword">AND</span> e.first_name<span class="operator">=</span><span class="string">&#x27;Georgi&#x27;</span></span><br><span class="line">) <span class="keyword">AS</span> C;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678958985322-6820c529-7411-4d1f-9490-1cab43323f9a.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> e.emp_no, d.dept_name, e.hire_date</span><br><span class="line">  <span class="keyword">FROM</span> employees e, dept_emp de, departments d</span><br><span class="line">  <span class="keyword">WHERE</span> e.emp_no<span class="operator">=</span>de.emp_no</span><br><span class="line">  <span class="keyword">AND</span> de.dept_no<span class="operator">=</span>d.dept_no</span><br><span class="line">  <span class="keyword">AND</span> d.dept_name<span class="operator">=</span><span class="string">&#x27;Finance&#x27;</span></span><br><span class="line">) <span class="keyword">AS</span> C;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678959020919-d5067188-b10f-4218-9f52-b8154137e91a.png" alt="image.png"><br>可以看出，对于存在 UNIQUE 完整性限制的属性，连接速度提升非常大。</p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 实验作业 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Experiment1</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment1/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A/Experiment1/</url>
      
        <content type="html"><![CDATA[<h1 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h1><h2 id="1-1-5-思考1"><a href="#1-1-5-思考1" class="headerlink" title="1.1.5 思考1"></a>1.1.5 思考1</h2><p>SQL 语法规定，双引号括定的符号串为对象名称，单引号括定的符号串为常量字符串，那么什么情况下需要用双引号来界定对象名呢？请实验验证。</p><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>验证双引号在<strong>ANSI_QUOTES 模式</strong>下有不同的作用。如果启用了 ANSI_QUOTES 模式，则双引号不能用来表示字符串，而只能用来表示对象；如果没有启用 ANSI_QUOTES 模式，则双引号可以用来表示字符串。</p><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>MySQL 不是默认了 ANSI_QUOTES 模式，这个模式需要手动设置。可以通过以下语句来查看或修改当前的 sql_mode：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前的 sql_mode</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@sql</span>_mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改当前的 sql_mode</span></span><br><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;ANSI_QUOTES&#x27;</span>; <span class="comment">-- 启用 ANSI_QUOTES 模式</span></span><br><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>; <span class="comment">-- 关闭 ANSI_QUOTES 模式</span></span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;ANSI_QUOTES&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@sql</span>_mode;</span><br><span class="line"><span class="keyword">SELECT</span> `first_name` <span class="keyword">FROM</span> employees; <span class="comment">-- 是各种人名</span></span><br><span class="line"><span class="keyword">SELECT</span> &quot;first_name&quot; <span class="keyword">FROM</span> employees; <span class="comment">-- 是各种人名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;first_name&#x27;</span> <span class="keyword">FROM</span> employees; <span class="comment">-- 全是first_name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> `first_name` <span class="keyword">FROM</span> employees; <span class="comment">-- 是各种人名</span></span><br><span class="line"><span class="keyword">SELECT</span> &quot;first_name&quot; <span class="keyword">FROM</span> employees; <span class="comment">-- 全是first_name</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;first_name&#x27;</span> <span class="keyword">FROM</span> employees; <span class="comment">-- 全是first_name</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@sql</span>_mode;</span><br></pre></td></tr></table></figure><p>简写代码如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;ANSI_QUOTES&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@sql</span>_mode,`first_name`,&quot;first_name&quot;,<span class="string">&#x27;first_name&#x27;</span> <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@sql</span>_mode,`first_name`,&quot;first_name&quot;,<span class="string">&#x27;first_name&#x27;</span> <span class="keyword">FROM</span> employees; </span><br></pre></td></tr></table></figure><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678544232237-34db908e-e5cd-437e-9ba5-e770ee4e6c50.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678544218995-09dc0b41-c65a-416b-a24f-4f31159327a4.png" alt="image.png"></p><ol><li>在ANSI_QUOTES模式下时，双引号所代表的都是<strong>对象</strong>，可以从<code>employees</code>表中取到各种数据</li><li>在空白模式下，双引号所代表的是<strong>字符串</strong>，无法从<code>employees</code>表中取到各种数据</li><li>不论在ANSI_QUOTES模式下还是在空白模式下，反引号所代表的都是<strong>对象</strong>，单引号所代表的都是<strong>字符串</strong></li></ol><h3 id="结论与分析"><a href="#结论与分析" class="headerlink" title="结论与分析"></a>结论与分析</h3><ol><li>验证的方法是在 SQL 语句中使用双引号来界定对象名，并执行 SQL 语句，看是否能正确运行。如果能正确运行，说明双引号的作用是有效的；如果报错，说明双引号的作用是无效的或者不被支持</li><li>在 MySQL 中，对象名就是指数据库中的组成部分，比如表，索引，视图等的名字</li><li>对象是用来标识和引用数据库中的组成部分，字符串是用来表示文本或者其他数据</li></ol><h2 id="1-1-5-思考2"><a href="#1-1-5-思考2" class="headerlink" title="1.1.5 思考2"></a>1.1.5 思考2</h2><p>数据库对象的完整引用是“服务器名.数据库名.模式名.对象名”，但通常可以省略服务器名和数据库名，甚至模式名，直接用对象名访问对象即可。请设计相应的实验验证基本表及其列的访问方法。</p><h3 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h3><p>验证可以省略服务器名和数据库名，甚至模式名，直接用对象名访问对象</p><h3 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> new_schema.dept_emp; <span class="comment">-- 省略服务器名和数据库名，得到所有的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept_emp; <span class="comment">-- 省略服务器名和数据库名和模式名，得到表中的所有数据</span></span><br></pre></td></tr></table></figure><h3 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678543963942-f3cf4a8b-146f-45d9-b2c3-778af2dfd1e7.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678543976380-e45b24e0-50ba-4bb1-bc38-90928a4fa2e2.png" alt="image.png"></p><p>输入上面两行代码，所得到的结果都是一样的，这说明我们可以使用完整引用，也可以使用省略的引用来访问表中的数据</p><h3 id="结论与分析-1"><a href="#结论与分析-1" class="headerlink" title="结论与分析"></a>结论与分析</h3><p>在 SQL Server 中，数据库对象的完整引用是“服务器名.数据库名.模式名.对象名”。</p><ul><li>数据库名：指定了包含该对象的数据库的名称。</li><li>模式名：指定了包含该对象的模式的名称。模式是一组逻辑结构，用于组织和管理数据库中的对象。</li><li>对象名：指定了要访问的对象（例如表、视图或存储过程）的名称。</li></ul><p>我们既可以使用<strong>完整引用</strong>，也可以使用<strong>省略部分引用</strong>的方式来访问数据。</p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 实验作业 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>混淆的知识点</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E6%B7%B7%E6%B7%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E6%B7%B7%E6%B7%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680277560139-1356b3d3-42b0-4edd-b98e-b56c6cf74e44.jpeg" alt="1343964917_2755.jpg"><br>列级约束有六种：主键Primary key、外键foreign key 、唯一 unique、检查 check 、默认default 、非空&#x2F;空值 not null&#x2F; null<br />表级约束有四种：主键、外键、唯一、检查</p><h2 id="列级约束和表级约束的区别"><a href="#列级约束和表级约束的区别" class="headerlink" title="列级约束和表级约束的区别"></a>列级约束和表级约束的区别</h2><ul><li>列级约束：只能应用于一列上。</li><li>表级约束：可以应用于一列上，也可以应用在一个表中的多个列上。</li></ul><p>（即：<strong>如果你创建的约束涉及到该表的多个属性列，则必须创建的是表级约束</strong>（必须定义在表级上）；否则既可以定义在列级上也可以定义在表级上此时只是SQL语句格式不同而已）</p><ul><li>列级约束：包含在列定义中，直接跟在该列的其它定义之后 ，用空格分隔；不必指定列名  </li><li>表级约束：与列定义相互独立，不包含在列定义中；与定义用‘，’分隔；必须指出要约束的列的名称</li></ul><p>（注：因为在创建列级约束时，只需将创建列约束的语句添加到该字段（列）的定义子句后面；而在创建表级约束时，需要将创建表级约束的语句添加到各个字段（列）定义语句的后面，因为并不是每个定义的字段都要创建约束，所以<strong>必须指明需要创建的约束的列名。</strong>）</p><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>PRIMARY KEY约束<br />PRIMARY KEY约束用于定义基本表的主键，起唯一标识作用，其值不能为NULL，也不能重复，以此来保证实体的完整性。<br />PRIMARY KEY与UNIQUE约束类似，通过建立唯一索引来保证基本表在主键列取值的唯一性，但它们之间存在着很大的区别：<br />①在一个基本表中<strong>只能定义一个PRIMARY KEY约束，但可定义多个UNIQUE约束；</strong><br />②对于指定为PRIMARY KEY的一个列或多个列的组合，<strong>其中任何一个列都不能出现空值</strong>，而对于<strong>UNIQUE</strong>所约束的唯一键，则<strong>允许为空</strong>。<br />注意：不能为同一个列或一组列既定义UNIQUE约束，又定义PRIMARY KEY约束。<br />PRIMARY KEY既可用于列约束，也可用于表约束。<br />PRIMARY KEY用于定义列约束时，其语法格式如下：<code>CONSTRAINT &lt;约束名&gt; PRIMARY KEY</code><br />PRIMARY KEY用于定义表约束时，即将某些列的组合定义为主键，其语法格式如下：<code>[CONSTRAINT &lt;约束名&gt;] PRIMARY KEY (&lt;列名&gt;[&#123;&lt;列名&gt;&#125;])</code></p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>外部键约束用于强制参照完整性，提供单个字段或者多个字段的参照完整性。 FOREIGN KEY约束指定某一个列或一组列作为外部键，其中，包含外部键的表称为从表(参照表)，包含外部键所引用的主键或唯一键的表称主表(被参照表)。<br />系统保证从表在外部键上的取值要么是主表中某一个主键值或唯一键值，要么取空值。以此保证两个表之间的连接，确保了实体的参照完整性。<br />FOREIGN KEY既可用于列约束，也可用于表约束，<br />其语法格式为：<br />      [CONSTRAINT &lt;约束名&gt;] FOREIGN KEY                    REFERENCES &lt;主表名&gt; (&lt;列名&gt;[{&lt;列名&gt;}])<br>当使用外部键约束时，应该考虑以下几个因素：<br />①外部键约束提供了字段参照完整性。<br />②外部键从句中的字段数目和每个字段指定的数据类型必须和REFERENCES从句中的字段相匹配。<br />③外部键约束不能自动创建索引，需要用户手动创建。<br />④用户想要修改外部键约束的数据，必须有对外部键约束所参考表的SELECT权限或者REFERENCES权限。<br />⑤参考同一表中的字段时，必须只使用REFERENCES子句，不能使用外部键子句。<br />⑥一个表中最多可以有31个外部键约束。<br />⑦在临时表中，不能使用外部键约束。<br />⑧主键和外部键的数据类型必须严格匹配。</p><h2 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h2><p>UNIQUE约束用于指明基本表在某一列或多个列的组合上的取值必须唯一。<br />定义了UNIQUE约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。<br />唯一键允许为空，但系统为保证其唯一性，最多只可以出现一个NULL值。<br />UNIQUE既可用于列约束，也可用于表约束。<br />UNIQUE用于定义列约束时，其语法格式如下：<code>[CONSTRAINT &lt;约束名&gt;] UNIQUE</code><br />唯一性约束用于指定一个或者多个列的组合的值具有唯一性，以防止在列中输入重复的值。当使用唯一性约束时，需要考虑以下几个因素：<br />①使用唯一性约束的字段允许为空值。<br />②一个表中可以允许有多个唯一性约束。<br />③可以把唯一性约束定义在多个字段上。<br />④唯一性约束用于强制在指定字段上创建一个唯一性索引。<br />⑤缺省情况下，创建的索引类型为非聚簇索引。<br />unique约束是用来确保不受主键约束列上的数据的唯一性.<br />unique与primary key的区别在于:</p><ol><li>unique约束主要用于<strong>非主键的一列或多列上要求数据唯一</strong></li><li>unique约束<strong>允许该列上存在NULL值,而主键决不允许出现</strong></li><li>可以在一个表<strong>创建多个unique约束,而在一个表上只能够设置一个主键</strong></li></ol><h2 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h2><p>CHECK约束用来检查字段值所允许的范围，如，一个字段只能输入整数，而且限定在0-100的整数，以此来保证域的完整性。<br />CHECK既可用于列约束，也可用于表约束，<br />其语法格式为：<code>[CONSTRAINT &lt;约束名&gt;] CHECK (&lt;条件&gt;)</code><br />一个列级检查约束只能与限制的字段有关；一个表级检查约束只能与限制的表中字段有关。<br />一个表中可以定义多个检查约束。<br />每个CREATE TABLE语句中每个字段只能定义一个检查约束。<br />在多个字段上定义检查约束，则必须将检查约束定义为表级约束。<br />当执行INSERT语句或者UPDATE语句时，检查约束将验证数据。<br />检查约束中不能包含子查询。</p><h2 id="缺省约束"><a href="#缺省约束" class="headerlink" title="缺省约束"></a>缺省约束</h2><p>使用缺省约束时，应该注意以下几点：<br />每个字段只能定义一个缺省约束。<br />如果定义的缺省值长于其对应字段的允许长度，那么输入到表中的缺省值将被截断。<br />不能加入到带有IDENTITY属性或者数据类型为timestamp的字段上。<br />如果字段定义为用户定义的数据类型，而且有一个缺省绑定到这个数据类型上，则不允许该字段有缺省约束。</p><h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>NULL&#x2F;NOT NULL<br />是否允许该字段的值为NULL。<br />NULL值不是0也不是空白，更不是填入字符串“NULL”，而是表示“不知道”、“不确定”或“没有数据”的意思。<br />当某一字段的值一定要输入才有意义的时候，则可以设置为NOT NULL。<br />如主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用<br />只能用于定义列约束，<br />其语法格式如下：[CONSTRAINT &lt;约束名&gt; ][NULL|NOT NULL]</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>3.1.5中提到：所有列级完整性约束都可以改写为表级完整性约束，而表级完整性约束不一定能改写为列级完整性约束。<br />不过貌似：不是所有的列级约束都可以改写成表级约束的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee (</span><br><span class="line"> emp_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> emp_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;unknown&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><del>可以改写为以下语句，使用了表级约束：</del><br />在workbench中报错了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee (</span><br><span class="line"> emp_id <span class="type">int</span>,</span><br><span class="line"> emp_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"> <span class="keyword">CONSTRAINT</span> nn_emp_id <span class="keyword">NOT</span> <span class="keyword">NULL</span> (emp_id),</span><br><span class="line"> <span class="keyword">CONSTRAINT</span> df_emp_name <span class="keyword">DEFAULT</span> <span class="string">&#x27;unknown&#x27;</span> (emp_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h1><h2 id="外键处理"><a href="#外键处理" class="headerlink" title="外键处理"></a>外键处理</h2><p>外键找不到合理的引用的时候：</p><ul><li>一种是先设置为NULL，这样就不会违反外键约束，但是会导致数据的不完整性，因为外键的作用是表示两个表之间的关联关系，如果外键为空，就无法表示这种关系。</li><li>另一种是先插入被参照表中的数据，这样就可以保证外键有有效的引用，也可以保证数据的完整性，但是会增加操作的复杂度，因为需要多次插入数据。</li></ul><p>如果是表内引用，也就是说参照表和被参照表是同一个表，那么先插入被参照表中的数据的方法就不太可行，因为这样会造成循环依赖的问题。例如，如果你是我的引用，我的引用是你，那么我要先插入你的数据，你要先插入我的数据，这样就无法进行。<br />在这种情况下，一种可能的方法是<strong>先插入外键为空的数据，然后再更新外键的值。</strong></p><h2 id="外键语法"><a href="#外键语法" class="headerlink" title="外键语法"></a>外键语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_dept (</span><br><span class="line">  emp_no <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  dept_no <span class="type">CHAR</span>(<span class="number">5</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> FK_deptno </span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (dept_no) </span><br><span class="line">  <span class="keyword">REFERENCES</span> departments(dept_no)</span><br><span class="line">  <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">  <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(emp_no)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这段代码的原理是，它定义了一个外键约束，指定了当参照表（departments）中的dept_no被删除或更新时，引用表（employee）中的dept_no应该如何处理。<br />ON DELETE SET NULL表示当参照表中的dept_no被删除时，引用表中的dept_no将被设置为NULL。<br />ON UPDATE SET NULL表示当参照表中的dept_no被更新时，引用表中的dept_no也将被设置为NULL。<br /><strong>这样做的目的是为了保持数据的一致性和完整性，避免出现无效的引用或孤立的记录</strong></p><h2 id="cascade和restrict"><a href="#cascade和restrict" class="headerlink" title="cascade和restrict"></a>cascade和restrict</h2><p>cascade和restrict是在定义外键时指定的两种选项，它们影响了当被参照表中的数据发生变化时，参照表中的数据如何处理。<br /><strong>cascade表示级联操作，即当被参照表中的数据被删除或更新时，参照表中的数据也会相应地被删除或更新。</strong><br /><strong>restrict表示受限操作，即当被参照表中的数据被删除或更新时，如果参照表中有对应的数据，就不允许进行删除或更新操作。</strong><br />举例来说，假设有两个表：学生表和课程表，如下所示：<br />学生表：</p><table><thead><tr><th><strong>sno</strong></th><th><strong>sname</strong></th><th><strong>ssex</strong></th><th><strong>sdept</strong></th></tr></thead><tbody><tr><td>2021</td><td>张三</td><td>男</td><td>计算机</td></tr><tr><td>2022</td><td>李四</td><td>女</td><td>数学</td></tr><tr><td>2023</td><td>王五</td><td>男</td><td>物理</td></tr></tbody></table><p>课程表：</p><table><thead><tr><th><strong>cno</strong></th><th><strong>cname</strong></th><th><strong>cpno</strong></th></tr></thead><tbody><tr><td>0001</td><td>数据结构</td><td>NULL</td></tr><tr><td>0002</td><td>算法设计</td><td>0001</td></tr><tr><td>0003</td><td>操作系统</td><td>NULL</td></tr><tr><td>0004</td><td>编译原理</td><td>0003</td></tr><tr><td>0005</td><td>数据库系统</td><td>NULL</td></tr></tbody></table><p>在这个例子中，课程表中的cpno列是一个外键，它引用了课程表中的cno列，表示先修课的编号。<br />如果定义外键时指定了on delete cascade，那么当删除课程表中的一条数据时，比如：<br />DELETE FROM course WHERE cno &#x3D; ‘0001’;<br />那么课程表中所有cpno为0001的数据也会被一起删除，即算法设计这门课也会被删除。<br />如果定义外键时指定了on delete restrict，那么当删除课程表中的一条数据时，比如：<br />DELETE FROM course WHERE cno &#x3D; ‘0001’;<br />那么如果课程表中有cpno为0001的数据，就不允许进行删除操作，会报错。只有当没有任何数据引用了0001时，才能删除数据结构这门课。</p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter02 - 关系数据库</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter02%20-%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter02%20-%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="ch08-关系、关系模式和关系数据库"><a href="#ch08-关系、关系模式和关系数据库" class="headerlink" title="ch08 关系、关系模式和关系数据库"></a>ch08 关系、关系模式和关系数据库</h1><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p><strong>域是一组具有相同数据类型的值的集合</strong>，可以是有穷的也可以是无穷的，是一种单一的数据类型的取值范围<br />复合数据类型：简单数据类型的复合</p><h2 id="笛卡尔积（Cartesian-Product）"><a href="#笛卡尔积（Cartesian-Product）" class="headerlink" title="笛卡尔积（Cartesian Product）"></a>笛卡尔积（Cartesian Product）</h2><p>给定一组域D1，D2笛卡尔积为<br />D1×D2×…×Dn＝｛（d1，d2，…，dn）｜di属于Di，i＝1，2，…，n｝</p><ul><li>所有域的所有取值（每个域中选取一个合适的值）的一个组合。</li><li>不能重复 – 集合的基本要求</li><li><strong>Di和Dj的域是可以相同的</strong>，例如都是int，一个代表年龄，一个代表得分，是可以组合成一个复杂数据类型。</li><li>笛卡尔积中每一个元素（d1，d2，…，dn）叫作一个n元组（n-tuple）或简称<strong>元组</strong></li><li>笛卡尔积元素（d1，d2，…，dn）中的每一个值di叫作一个<strong>分量</strong></li><li>若Di（i＝1，2，…，n）为有限集，<strong>域中所包含的值的个数称为域的基数，</strong>其基数为mi （i ＝ 1，2，… ，n），则D1×D2×…×Dn的基数M为：M&#x3D;mi的连乘；</li><li>元祖也是一个集合，是无序的。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686571577001-6bec2715-679c-4edd-a29c-fdd22cfa1b9f.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686571587217-b7f168ac-c915-4c63-b02a-de7f790a7ad7.png" alt="image.png"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686571619507-3ac00f8b-e806-43cd-bf53-a1ce7dde06b5.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686571628891-be392bbd-64c9-4bd6-a8d3-2ff57a55cd16.png" alt="image.png"></p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>D1×D2×…×Dn的子集叫作在域D1，D2，…，Dn上的关系，表示为R（D1，D2，…，Dn）。<br />R ：关系名<br />n ：关系的目或度（Degree）</p><ul><li>当n&#x3D;1时，称该关系为单元关系（Unary relation）或一元关系                         </li><li>当n&#x3D;2时，称该关系为二元关系（Binary relation）</li></ul><p><strong>关系可以是空集</strong>。对关系进行增删后，关系就会改变。所以是<strong>只在当下</strong>作用，是对<strong>客观世界某一时刻</strong>的状态的正确匹配。<br />关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>关系中不同列可以对应相同的域</li><li>为了加以区分，必须对<strong>每列起一个名字</strong>，称为属性（Attribute）</li><li>n目关系必有n个属性</li><li>不同的属性可以共享一个域。age和score都可以是int域的</li></ul><h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>码反映了<strong>数据的依赖关系</strong><code>F</code> ：属性间数据的依赖关系的集合，说明了有哪些码可以挑选<br />候选码（Candidate key）</p><ul><li>若关系中的某一属性组的值能<strong>唯一地标识一个元组</strong>，<strong>而其子集不能</strong>，则称该属性组为候选码。在学生中，假设性别、年龄、学号的组成的元祖可以区分其他学生，则这三个是候选码。</li><li>候选码是有穷属性的子集，候选码是可穷举的。</li><li>简单的情况：候选码可以只包含一个属性</li><li>最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）。关系是一个集合，所以不会出现相同的元祖。</li></ul><p>主码</p><ul><li>若一个关系有多个候选码，则选定其中一个为主码<strong>（Primary key）</strong></li></ul><p>主属性</p><ul><li><strong>候选码的诸属性</strong>称为主属性（Prime attribute）</li><li><strong>不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute）</strong></li></ul><h3 id="关系的类别"><a href="#关系的类别" class="headerlink" title="关系的类别"></a>关系的类别</h3><p>对关系操作得到的结果也是一个关系  – &gt; 可以实现流水线操作</p><ul><li>基本关系（基本表或基表）实际存在的表，是<strong>实际存储数据的逻辑表示</strong></li><li>查询表<strong>查询结果对应的表</strong></li><li>视图表由基本表或其他视图表导出的表，是虚表，<strong>不对应实际存储的数据。</strong><ul><li>知道更少的内容，开发更具有效率</li><li>更高的安全性</li><li>可以掩盖部分元组、也可以掩盖部分属性，也可以都掩盖部分。</li><li>实际上是在一个集合中挑选子集的过程，并对子集处理，是<strong>实现外模式</strong>的一种手段</li></ul></li></ul><h3 id="基本关系的性质"><a href="#基本关系的性质" class="headerlink" title="基本关系的性质"></a>基本关系的性质</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677809343460-f0a8a333-0f92-4d06-aa33-d56e7a7efe83.png" alt="image.png"></p><h3 id="关系模式与关系"><a href="#关系模式与关系" class="headerlink" title="关系模式与关系"></a>关系模式与关系</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677809551385-9376105d-0cd1-4c5a-9c32-9de032fc9cac.png" alt="image.png"><br>关系模式</p><ul><li>对关系的描述</li><li><strong>静态的、稳定的</strong></li></ul><p>关系</p><ul><li>关系模式在某一时刻的状态或内容</li><li><strong>动态的、随时间不断变化的</strong></li></ul><p>关系模式和关系往往笼统称为关系通过上下文加以区别</p><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>关系数据库</p><ul><li>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</li></ul><p>关系数据库的型与值</p><ul><li>关系数据库的型: 关系数据库模式，是对关系数据库的描述</li><li>关系数据库的值: <strong>关系模式在某一时刻对应的关系的集合</strong>，通常称为关系数据库</li></ul><h1 id="ch09-关系的完整性"><a href="#ch09-关系的完整性" class="headerlink" title="ch09 关系的完整性"></a>ch09 关系的完整性</h1><h2 id="三类完整性约束"><a href="#三类完整性约束" class="headerlink" title="三类完整性约束"></a>三类完整性约束</h2><p>实体完整性和参照完整性关系</p><ul><li>模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持</li></ul><p>用户定义的完整性</p><ul><li>应用领域需要遵循的约束条件，体现了具体领域中的语义约束</li></ul><h2 id="实体完整性-Entity-Integrity"><a href="#实体完整性-Entity-Integrity" class="headerlink" title="实体完整性 Entity Integrity"></a>实体完整性 Entity Integrity</h2><p>实体完整性规则（Entity Integrity）— <strong>确保不能犯错</strong>，不能先取<code>Null</code>，然后再对<code>Null</code>取值。如果有多个<code>Null</code>，就无法正常赋值了。</p><ul><li>若属性A是基本关系R的主码属性，则属性A不能取空值</li><li>空值就是“不知道”或“不存在”或“无意义”的值</li><li>主码有属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体</li></ul><p>例：选修（学号，课程号，成绩）</p><ul><li>“学号、课程号”为主码</li><li>“学号”和“课程号”两个属性都不能取空值 — <strong>主码的任意一个属性值不能为空</strong></li></ul><p>对于实体完整性规则说明如下：</p><ol><li>实体完整性规则<strong>是针对基本关系而言的。</strong>一个基本表通常对应现实世界的一个实体集。例如学生关系对应于学生的集合。</li><li><strong>现实世界中的实体是可区分的，即它们具有某种唯一性标识。</strong>例如每个学生都是独立的个体，是不一样的。</li><li>相应地，<strong>关系模型中以主码作为唯一性标识。</strong></li><li>主码中的属性即主属性不能取空值。<strong>如果主码存在一个属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体</strong>，这与第(2)点相矛盾，因此这个规则称为实体完整性。</li></ol><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><h3 id="关系间的引用"><a href="#关系间的引用" class="headerlink" title="关系间的引用"></a>关系间的引用</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686572115932-4691bfb2-42cb-480c-a42e-78ffe62c1dba.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686572125974-6544e5ce-78e0-415e-898d-c7c92eb91c1f.png" alt="image.png"></p><h3 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h3><p>设<strong>F是基本关系R的一个或一组属性</strong>，但<strong>不是关系R的码</strong>。如果<strong>F与基本关系S的主码Ks相对应</strong>，则称F是R的外码（Foreign Key）</p><ul><li>基本关系R称为参照关系（Referencing  Relation）</li><li>基本关系S称为被参照关系（Referenced Relation）或目标关系（Target Relation）</li></ul><p>其中</p><ul><li>关系R和S不一定是不同的关系</li><li>目标关系S的主码Ks和参照关系的外码F必须定义在同一个（或一组）域上</li><li><strong>外码并不一定要与相应的主码同名</strong><ul><li>当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别</li></ul></li></ul><p>A表中有外码指向B，则</p><ol><li><strong>创建时需要先创建B，因为A是依赖B存在的</strong></li><li><strong>删除时需要先删除A，因为如果先删除B，则A依赖B就会出错</strong>。</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677810264884-e5852903-9f77-4214-8ed8-dd6b43acc035.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686572557695-1acfa379-ada0-4cd0-a337-c84275cd3c33.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686572570391-d135270e-f9f1-4b1d-b671-b814124a58da.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686572610280-69453209-32eb-452c-9b04-be4e9edbc9c8.png" alt="image.png"></p><h3 id="参照完整性规则"><a href="#参照完整性规则" class="headerlink" title="参照完整性规则"></a>参照完整性规则</h3><ul><li>若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：</li><li><strong>或者取空值（F的每个属性值均为空值）：F中有一个为空值，则所有的都为空值。因为R的外码F实际上是映射了S的主码Ks，而Ks不能为空。所以，如果F中有空值，则必须不存在这种对应关系，否则会导致Ks也为空。</strong></li><li><strong>或者等于S中某个元组的主码值</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677810447025-65ca0f92-4b2d-4a11-94c7-92f08da63f4c.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677810452691-7291607a-ac85-4fb2-9434-97591d1e6a93.png" alt="image.png"></p><h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><ul><li>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</li><li>关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能</li><li>例：课程（课程号，课程名，学分）<ul><li>“课程号”属性必须取唯一值非主属性</li><li>“课程名”也不能取空值“</li><li>学分”属性只能取值{1，2，3，4}</li></ul></li><li><strong>数据对象本身是不是业务逻辑的一部分</strong></li></ul><h1 id="ch10-关系操作和关系代数"><a href="#ch10-关系操作和关系代数" class="headerlink" title="ch10 关系操作和关系代数"></a>ch10 关系操作和关系代数</h1><h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><p>设关系模式为R(A1，A2，…，An)</p><ul><li>它的一个关系设为R</li><li>t属于R表示t是R的一个元组</li><li>t[Ai]则表示元组t中相应于属性Ai的一个分量</li><li>若A&#x3D;{Ai1，Ai2，…，Aik}，其中Ai1，Ai2，…，Aik是A1，A2，…，An中的一部分，则A称为属性列或属性组。</li><li>t[A]&#x3D;(t[Ai1]，t[Ai2]，…，t[Aik])表示元组t在属性列A上诸分量的集合。</li><li>A ̅则表示{A1，A2，…，An}中去掉{Ai1，Ai2，…，Aik}后剩余的属性组。</li></ul><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677737657887-8fcadc45-452e-4b93-891e-9f534b78c017.png" alt="image.png"></p><h3 id="并操作"><a href="#并操作" class="headerlink" title="并操作"></a>并操作</h3><p>其实就是同一个关系下的两个实例进行并操作<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677738240562-a38bb5d4-564e-4194-aac2-d6c4057f46bc.png" alt="image.png"></p><h3 id="差操作"><a href="#差操作" class="headerlink" title="差操作"></a>差操作</h3><p>不满足交换律<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677738299901-dfdef3e6-1f2e-4132-8e14-9497d170fb69.png" alt="image.png"></p><h3 id="交操作"><a href="#交操作" class="headerlink" title="交操作"></a>交操作</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677738341366-70434831-22b4-4ff6-a9a8-4468d66445e4.png" alt="image.png"></p><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><ul><li>通过两个关系，构成更大的关系。</li><li>不需要两个关系是同一个关系集合</li><li>关系的笛卡尔积是值的笛卡尔积。域的笛卡尔积和值的笛卡尔积的区别？</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677738489743-8e321f2f-3002-4b46-8e6d-039c8e60acf5.png" alt="image.png"><br>举例<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677738543078-a670f256-e0e2-4139-9ca6-07335422a6a0.png" alt="image.png"></p><h3 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677811187612-bca20ca6-34e5-4ce4-b9f5-49589b1966f3.png" alt="image.png"></p><ul><li>属性组是所有属性的一个子集</li><li><code>t[Ai]</code>表示的是一个分量，<code>t[A]</code>表示的是一个分量的集合</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677810964052-25f39660-fdc3-4241-9339-a9916c383254.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677810970986-18571cce-b255-479e-a7c5-adc3a9d3eaea.png" alt="image.png"></p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><ul><li>结果中属性是完备的，只是减少了元祖的数量。</li><li>操作的结果也是一个集合</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677738747979-b47bc772-faab-4a7b-a5e3-3d7e79d3438a.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677738902094-1451aa9b-a756-4402-b93b-d9d6c9fdacc2.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686575246423-6576045f-af5e-4e96-acb9-75d3b515adde.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686575256318-01b2afdf-58cd-40ea-a806-4f5555d79688.png" alt="image.png"></p><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>挑选一部分的属性，排除掉对应解决问题没有作用的属性<br />因为关系是一个集合，所以删除了特定列后，会导致重复的元祖出现，需要额外操作。属于投影的副作用<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677739046408-1cdb6fb8-0b31-4c1f-accb-3bc8afe01b3b.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686575314519-fdd4bb1e-4802-495d-9ee5-a66c4ee862b2.png" alt="image.png"></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677739385848-096f1beb-a848-457e-820e-bd0e39472992.png" alt="image.png"></p><ol><li>等值连接：A可以是年龄，B是价格，A、B属性值相等，就可以连接。A B并不一定要相等</li><li>自然连接：A B中是相同的含义、相同的域，只是隶属于不同关系</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677739584661-7bd4cd66-103d-443a-9f99-01e28632c3c8.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677739813112-556e68ac-f251-4300-9a61-5c381f5e170f.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677811604722-b2bff014-2c9e-454e-95b4-9bc396aee860.png" alt="image.png"><br>R的第四个元组和S的第五个元组都是<strong>悬浮元组</strong></p><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677740696900-73ff8395-273a-47bd-bfe1-5a8edd230a56.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677811929654-5daa923c-a026-40b6-96a9-36d90cd42fbc.png" alt="image.png"></p><h3 id="除操作"><a href="#除操作" class="headerlink" title="除操作"></a>除操作</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686576270841-05dedc96-ca6c-4e75-b8fa-5a5b9ed31af5.png" alt="image.png"><br><a href="https://blog.csdn.net/Imomoco/article/details/102727039">数据库-——关系代数的除法运算</a><br><strong>除操作是同时从行和列的角度进行运算</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677741325599-e8be8b05-de57-4123-aa17-7948ea68bdfd.png" alt="image.png"></p><ol><li>棕黄方框只有一个</li><li>蓝绿色方框的a1都满足BC中的</li><li>通过<strong>象集</strong>的概念理解</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677741400756-73e18140-8318-48a7-b63c-cf5083227cfc.png" alt="image.png"></p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><ol><li>先投影，保留需要的列</li><li>通过除法</li></ol><p><code>sno</code>学号<code>cno</code>课程号<code>sc</code>选修关系<code>cpno</code>先行课<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677741586927-10e365ce-9aad-4526-922f-b85f5a3884b0.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677741594062-5ad2f0fe-a239-48ea-9115-7248d2bd328f.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677741616884-91212c9e-4ab6-4123-84f0-ec045f58628a.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter03 - 关系数据库标准语言SQL</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter03%20-%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter03%20-%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="ch11-SQL概述"><a href="#ch11-SQL概述" class="headerlink" title="ch11 SQL概述"></a>ch11 SQL概述</h1><p>SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言<br />SQL是一个通用的、功能极强的关系数据库语言</p><ul><li>综合统一</li><li>高度非过程化：不关心过程是如何实现的</li><li>面向集合的操作方式</li><li>以同一种语法结构提供两种使用方法：嵌入式、单独使用</li><li>语言简洁，易学易用</li></ul><h2 id="SQL的特点"><a href="#SQL的特点" class="headerlink" title="SQL的特点"></a>SQL的特点</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677742624341-ab0efbb9-f461-40d8-bf2e-2ba513cfec46.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677742634077-72219a25-8bce-4bdd-bcee-e8359a8af9c9.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686576594621-f56ea613-fd53-4867-915c-454850c56dda.png" alt="image.png"></p><h2 id="三级模式、两层映射"><a href="#三级模式、两层映射" class="headerlink" title="三级模式、两层映射"></a>三级模式、两层映射</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677743327422-5f3350a3-92d5-4e4e-bac0-4cc7b4fe6bc2.png" alt="image.png"></p><h1 id="ch12-SQL数据定义"><a href="#ch12-SQL数据定义" class="headerlink" title="ch12 SQL数据定义"></a>ch12 SQL数据定义</h1><h2 id="层次化的数据库对象命名机制"><a href="#层次化的数据库对象命名机制" class="headerlink" title="层次化的数据库对象命名机制"></a>层次化的数据库对象命名机制</h2><ul><li>一个关系数据库管理系统的实例（Instance）中可以建立多个数据库</li><li>一个数据库中可以建立多个模式</li><li>一个模式下通常包括多个表、视图和索引等数据库对象</li></ul><p>实例：对数据库进行管理，提供权限等功能<br />模式：相互隔离的用于区分的应用域</p><ul><li>单模式</li><li>多模式</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678341970381-6e6a0cd8-f7e5-428b-ace2-3a32e5c27152.png" alt="image.png"></p><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686576722418-a411ae2a-da36-472d-9ea0-94250758906a.png" alt="image.png"></p><h2 id="定义模式"><a href="#定义模式" class="headerlink" title="定义模式"></a>定义模式</h2><p>定义模式实际上定义了一个命名空间。<br />在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。<br />在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。</p><ul><li>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;  [&lt;表定义子句&gt;| &lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686576874667-ae05138d-434a-4ce1-88d7-80aae71c8c3e.png" alt="image.png"></p><h2 id="删除模式"><a href="#删除模式" class="headerlink" title="删除模式"></a>删除模式</h2><p>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</p><ul><li>CASCADE（级联）<ul><li><strong>删除模式的同时把该模式中所有的数据库对象全部删</strong></li></ul></li><li>RESTRICT（限制）<ul><li><strong>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。</strong></li><li><strong>仅当该模式中没有任何下属的对象时才能执行</strong>。</li></ul></li></ul><p>DROP SCHEMA ZHANG CASCADE;</p><ul><li>删除模式ZHANG</li><li>同时该模式中定义的表TAB1也被删除</li></ul><h2 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h2><p>CREATE TABLE &lt;表名&gt;  (<br />&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]      <br />[,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] <br />   …      [,&lt;表级完整性约束条件&gt; ] );</p><ul><li>&lt;表名&gt;：所要定义的基本表的名字</li><li>&lt;列名&gt;：组成该表的各个属性（列）</li><li><strong>&lt;列级完整性约束条件&gt;：涉及相应属性列的完整性约束条件</strong></li><li>**&lt;表级完整性约束条件&gt;：涉及一个或多个属性列的完整性约束条件 **</li><li>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。</li></ul><p>通俗理解：schema是文件夹，表是文件<br />数据类型：用来描述域<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678343157994-af74cdc3-a5f5-4e6f-854b-0a9a103276c5.png" alt="image.png"></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>SQL中域的概念用数据类型来实现<br />定义表的属性时需要指明其数据类型及长度 <br />选用哪种数据类型 </p><ul><li>取值范围</li><li><strong>要做哪些运算：要结合具体的应用场景选择合适的数据类型</strong><table><thead><tr><th><strong>数据类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>CHAR(<em>n</em>),CHARACTER(<em>n</em>)</strong></td><td><strong>长度为n的定长字符串</strong></td></tr><tr><td><strong>VARCHAR(<em>n</em>), CHARACTERVARYING(<em>n</em>)</strong></td><td><strong>最大长度为n的变长字符串</strong></td></tr><tr><td><strong>CLOB</strong></td><td><strong>字符串大对象</strong></td></tr><tr><td><strong>BLOB</strong></td><td><strong>二进制大对象</strong></td></tr><tr><td><strong>INT，INTEGER</strong></td><td><strong>长整数（4字节）</strong></td></tr><tr><td><strong>SMALLINT</strong></td><td><strong>短整数（2字节）</strong></td></tr><tr><td><strong>BIGINT</strong></td><td><strong>大整数（8字节）</strong></td></tr><tr><td><strong>NUMERIC(<em>p_，_d</em>)</strong></td><td><strong>定点数，由_p_位数字（不包括符号、小数点）组成，小数后面有_d_位数字</strong></td></tr><tr><td><strong>DECIMAL(<em>p</em>, <em>d</em>), DEC(<em>p</em>, <em>d</em>)</strong></td><td><strong>同NUMERIC</strong></td></tr><tr><td><strong>REAL</strong></td><td><strong>取决于机器精度的单精度浮点数</strong></td></tr><tr><td><strong>DOUBLE PRECISION</strong></td><td><strong>取决于机器精度的双精度浮点数</strong></td></tr><tr><td><strong>FLOAT(<em>n</em>)</strong></td><td><strong>可选精度的浮点数，精度至少为_n_位数字</strong></td></tr><tr><td><strong>BOOLEAN</strong></td><td><strong>逻辑布尔量</strong></td></tr><tr><td><strong>DATE</strong></td><td><strong>日期，包含年、月、日，格式为YYYY-MM-DD</strong></td></tr><tr><td><strong>TIME</strong></td><td><strong>时间，包含一日的时、分、秒，格式为HH:MM:SS</strong></td></tr><tr><td><strong>TIMESTAMP</strong></td><td><strong>时间戳类型</strong></td></tr><tr><td><strong>INTERVAL</strong></td><td><strong>时间间隔类型</strong></td></tr></tbody></table></li></ul><h2 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686577178866-6671b410-f3c2-4787-b5af-9fa0f7c39f0a.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678344286467-00f9deea-0992-48fb-b59d-0e7125a8ae80.png" alt="image.png"></p><ul><li>[例3.8] 向Student表增加“入学时间”列，其数据类型为日期型<ul><li>ALTER TABLE Student ADD S_entrance DATE;</li><li>不管基本表中原来是否已有数据，新增加的列一律为空值</li></ul></li><li>[例3.9] 将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。<ul><li>ALTER TABLE Student ALTER COLUMN Sage INT;</li></ul></li><li>[例3.10] 增加课程名称必须取唯一值的约束条件。<ul><li>ALTER TABLE Course ADD UNIQUE(Cname);</li></ul></li></ul><h3 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h3><p>DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］;</p><ul><li>RESTRICT：删除表是有限制的。<ul><li>欲删除的基本表不能被其他表的约束所引用</li><li>如果存在依赖该表的对象，则此表不能被删除</li></ul></li><li>CASCADE：删除该表没有限制。<ul><li>在删除基本表的同时，相关的依赖对象一起删除</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686577522856-017c2ffe-2287-497a-9718-8215dde920aa.png" alt="image.png"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><code>order by</code>是实在的排序<br />查询次数和更新次数不一致：例如姓名。<br />建立索引的目的：加快查询速度</p><ul><li>由数据库管理员或表的拥有者建立：数据库管理员可以看到各种表的增删改查的记录，从而建立更方便查询的索引</li><li>由关系数据库管理系统自动完成维护</li><li>关系数据库管理系统自动使用合适的索引作为存取路径，用户不必也<strong>不能显式地选择索引：非过程性（没有精确的步骤）的解释语言</strong></li></ul><p>如果查询次数很低，就没有必要建立索引<br />数据库索引有多种类型，常见索引包括顺序文件上的索引、B+树索引、散列（hash)索引、位图索引等。</p><ul><li>顺序文件上的索引：是针对按指定属性值升序或降序存储的关系，在该属性上建立一个顺序索引文件，索引文件由属性值和相应的元组指针组成。</li><li>B+树索引：是将索引属性组织成B+树形式，B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。</li><li>散列索引：是建立若干个桶，将索引属性按照其散列函数值映射到相应桶中，桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。</li><li>位图索引：是用位向量记录索引属性中可能出现的值，每个位向量对应一个可能值。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686577612009-c200c616-fadc-4505-abb0-87086a881dc6.png" alt="image.png"><br>[例3.13] 为学生-课程数据库中的Student，Course，SC三个表建立索引。Student表按学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建唯一索引</p><ul><li>CREATE UNIQUE INDEX  Stusno ON Student(Sno);</li><li>CREATE UNIQUE INDEX  Coucno ON Course(Cno);</li><li>CREATE UNIQUE INDEX  SCno ON SC(Sno ASC,Cno DESC);</li></ul><h2 id="修改-x2F-删除索引"><a href="#修改-x2F-删除索引" class="headerlink" title="修改&#x2F;删除索引"></a>修改&#x2F;删除索引</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686577638624-965c6a1f-fd38-404d-8aa4-1a9605553d1a.png" alt="image.png"></p><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678346748253-1db916a4-2dec-4de3-9585-1ce0c4db5b12.png" alt="image.png"></p><h1 id="ch13-SQL数据查询（单表）"><a href="#ch13-SQL数据查询（单表）" class="headerlink" title="ch13 SQL数据查询（单表）"></a>ch13 SQL数据查询（单表）</h1><p><a href="https://blog.csdn.net/ryan007liu/article/details/91441479">Mysql中having和where的区别</a><br><a href="https://www.cnblogs.com/fanguangdexiaoyuer/p/6268211.html">SQL中Where与Having的区别</a><br><strong>having与where的区别:</strong></p><ul><li>having是在分组后对数据进行过滤</li><li>where是在分组前对数据进行过滤</li><li>having后面可以使用聚合函数</li><li>where后面不可以使用聚合</li><li>在查询过程中执行顺序：<strong>from&gt;where&gt;group（含聚合）&gt;having&gt;order&gt;select</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678347237895-a58ed045-32a7-491d-af1e-cd755df337cb.png" alt="image.png"><br>SELECT子句：指定要显示的属性列FROM子句：指定查询对象（基本表或视图）<br />WHERE子句：指定查询条件<br />GROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。<br />HAVING短语：只有满足指定条件的组才予以输<br />出ORDER BY子句：对查询结果表按指定列值的升序或降序排序<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678347542154-5ed4de0e-eb5b-4a66-968c-c236915a41a2.png" alt="image.png"></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>在SQL中，DISTINCT和ALL是两个可选的关键字，用于指定SELECT语句返回的结果集是否包含重复的值。</p><ul><li>DISTINCT表示<strong>只返回不同的值，即去除重复的记录。</strong>例如，SELECT DISTINCT name FROM Websites 返回Websites表中name字段的不同值</li><li>ALL表示<strong>返回所有的值，包括重复的记录。这是默认的行为</strong>，即不指定关键字时等同于使用ALL。例如，SELECT ALL name FROM Websites 返回Websites表中name字段的所有值</li></ul><h2 id="is和-x3D-的不同"><a href="#is和-x3D-的不同" class="headerlink" title="is和&#x3D;的不同"></a>is和&#x3D;的不同</h2><ul><li><strong>is 用于判断是否为null值，而 &#x3D; 不能判断null值。</strong></li><li><strong>Null不等于任何值，在&#x3D;  !&#x3D;中始终都代表着false</strong></li><li>is 不能用于比较数值或字符串，而 &#x3D; 可以。</li><li>is 是一个逻辑运算符，而 &#x3D; 是一个关系运算符。</li></ul><p><strong>如果要判断一个字段是否为null，应该用is null或is not null，而不是&#x3D; null或!&#x3D; null。</strong>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--正确写法</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">--错误写法</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="operator">=</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>如果要判断一个字段是否为true或false，可以用is true或is false，也可以用&#x3D; true或&#x3D; false。但是如果字段为null，那么is true和&#x3D; true的结果不同。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--假设有一个表格如下：</span></span><br><span class="line">id <span class="operator">|</span> flag</span><br><span class="line"><span class="number">1</span>  <span class="operator">|</span> <span class="literal">true</span></span><br><span class="line"><span class="number">2</span>  <span class="operator">|</span> <span class="literal">false</span></span><br><span class="line"><span class="number">3</span>  <span class="operator">|</span> <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查询flag为true的记录：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> flag <span class="keyword">is</span> <span class="literal">true</span>; <span class="comment">--返回id为1的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> flag <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">--返回id为1的记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查询flag不为true的记录：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> flag <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">true</span>; <span class="comment">--返回id为2和3的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> flag <span class="operator">!=</span> <span class="literal">true</span>; <span class="comment">--只返回id为2的记录，因为null和true不相等也不不相等。</span></span><br></pre></td></tr></table></figure><p>如果要比较两个数值或字符串是否相等，应该用&#x3D;而不是is。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--假设有一个表格如下：</span></span><br><span class="line">id <span class="operator">|</span> name </span><br><span class="line"><span class="number">1</span>  <span class="operator">|</span> Alice </span><br><span class="line"><span class="number">2</span>  <span class="operator">|</span> Bob </span><br><span class="line"><span class="number">3</span>  <span class="operator">|</span> Charlie</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询name为Alice的记录：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>; <span class="comment">--返回id为1的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> name <span class="keyword">is</span> <span class="string">&#x27;Alice&#x27;</span>; <span class="comment">--报错，因为is不能用于比较字符串。</span></span><br></pre></td></tr></table></figure><p>假设有一个学生表格如下：</p><table><thead><tr><th><strong>id</strong></th><th><strong>name</strong></th><th><strong>age</strong></th></tr></thead><tbody><tr><td>1</td><td>Alice</td><td>18</td></tr><tr><td>2</td><td>Bob</td><td>19</td></tr><tr><td>3</td><td>Charlie</td><td>null</td></tr></tbody></table><p>如果你想查询年龄为null的学生，你应该用这样的语句：<br /><code>select * from student where age is null; </code><br />这样就会返回id为3的记录。<br />如果你用这样的语句：<br /><code>select * from student where age = null; </code><br />那么就不会返回任何记录，因为<strong>null不等于null，也不等于任何其他值。</strong></p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686588591333-9b807bff-3e2e-457a-af0c-a862da098385.png" alt="image.png"><br><code>DISTINCT</code>去重<br /><code>BETWEEN …  AND  … </code>               <code>NOT BETWEEN  …  AND  …</code><br /><code>IN &lt;值表&gt;,  NOT IN &lt;值表&gt;</code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686588732445-bd2121af-609f-4f0a-83f6-5fd6e864c0a9.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686588807801-66567716-2316-4685-b522-5abd8c9ddc62.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686588816158-31e35d3e-7b8f-4b55-bf89-11c3a4e4bd0c.png" alt="image.png"></p><h2 id="多重条件查询"><a href="#多重条件查询" class="headerlink" title="多重条件查询"></a>多重条件查询</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686589097642-e5ab9e42-ef01-4658-a78f-d6f4011c9464.png" alt="image.png"></p><h2 id="对查询结果排序"><a href="#对查询结果排序" class="headerlink" title="对查询结果排序"></a>对查询结果排序</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686589122775-34c66b33-56a7-4dd7-803e-4855f7f4b976.png" alt="image.png"></p><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p><strong>聚集函数只能用于select字句和group by中的having字句中</strong><br />当聚集函数遇到空值时，除COUNT (*) 外，都跳过空值而只处理非空值<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678783302432-fab21781-8843-49e0-8630-8a79ebedd16e.png" alt="image.png"></p><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><p>GROUP BY子句分组：细化聚集函数的作用对象</p><ul><li>如果未对查询结果分组，<strong>聚集函数将作用于整个查询结果</strong></li><li>对查询结果分组后，**聚集函数将分别作用于每个组 **</li><li>按指定的一列或多列值分组，值相等的为一组</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678882600130-665332f6-a66b-4285-8150-0b6a049736d4.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678882784963-5b29044e-7e82-454b-af2a-eaa8bb850222.png" alt="image.png"></p><h1 id="ch14-SQL数据查询（连接）"><a href="#ch14-SQL数据查询（连接）" class="headerlink" title="ch14 SQL数据查询（连接）"></a>ch14 SQL数据查询（连接）</h1><h2 id="等值连接-x2F-自然连接"><a href="#等值连接-x2F-自然连接" class="headerlink" title="等值连接&#x2F;自然连接"></a>等值连接&#x2F;自然连接</h2><p>两张表的笛卡尔积，然后筛选即可。<br />连接操作是引用关系和被引用关系之间的操作<br />自然连接：外码和关键字的<strong>含义相同</strong><br />等值连接：外码和关键字的<strong>含义不同</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678785347938-0d461836-1d02-484a-b4d5-19bed80f5c4f.png" alt="image.png"></p><h2 id="连接操作的执行过程"><a href="#连接操作的执行过程" class="headerlink" title="连接操作的执行过程"></a>连接操作的执行过程</h2><h3 id="嵌套循环法"><a href="#嵌套循环法" class="headerlink" title="嵌套循环法"></a>嵌套循环法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678785691471-f430cb0c-aba7-4363-9fd7-f05e8a4454b2.png" alt="image.png"></p><h3 id="排序合并法"><a href="#排序合并法" class="headerlink" title="排序合并法"></a>排序合并法</h3><p>归并排序<br />连接方法的选择由数据库自身决定，对程序员透明，并<strong>不清楚，也不关心</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678785805500-166ecbd9-51ce-4460-9638-857d119aad7c.png" alt="image.png"><br>连接：在更大的表上进行过滤、选择</p><h2 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h2><p>对自身连接的表的操作是<strong>只读操作，从自身派生出新的关系</strong><br />两个元组之间相互引用：先设置为null，再插入。形和值的约束<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678786044092-3e6e1238-854c-4147-a2ed-a70d93d89dce.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686638276773-7e609822-5d9e-446d-8944-5bb42d0cb703.png" alt="image.png"></p><h2 id="左右外连"><a href="#左右外连" class="headerlink" title="左右外连"></a>左右外连</h2><ul><li><code>null</code>是有意义的</li><li>两个关系R和S在做自然连接时，关系R中某些元组有可能<strong>在S中不存在公共属性上值相等</strong>的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组。</li><li>左连接：保留连接符左侧的悬浮元组，<strong>列出左边关系中的所有元组，右表不匹配的为NULL</strong></li><li>右连接：保留连接符右侧的悬浮元组，<strong>列出右边关系中的所有元组，左表不匹配的为NULL</strong></li><li>LEFT JOIN 关键字从左表（table1）返回所有的行，<strong>即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678786511861-f0c93880-81e0-45e7-ab6c-6778b6bde745.png" alt="image.png"></p><h2 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686638367044-e8181317-b043-4dc1-a597-a61db543464e.png" alt="image.png"></p><h1 id="ch15-SQL数据查询（嵌套）"><a href="#ch15-SQL数据查询（嵌套）" class="headerlink" title="ch15 SQL数据查询（嵌套）"></a>ch15 SQL数据查询（嵌套）</h1><p>一个SELECT-FROM-WHERE语句称为一个查询块<br />将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678786825925-3b593b06-056d-405b-a873-a92002b5e078.png" alt="image.png"><br>嵌套的使用是基于一系列的假设，一旦假设的改变，就无法成功实现了，同时比较难理解<br /><code>order by</code> <strong>只是用于结果的展示，不影响语义</strong>，所以不能使用<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678786785290-e4307a35-7e3e-4f66-8d67-653b33494940.png" alt="image.png">S<br />嵌套查询：</p><ul><li><p>习惯性控制具体的数据</p></li><li><p>能思路简单的完成任务 — 要根据别人的思路走，难以用数学论证等价</p></li><li><p>不相关子查询：子查询的查询条件不依赖于父查询由里向外 逐层处理。</p><ul><li>即<strong>每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。</strong></li></ul></li><li><p>相关子查询：子查询的查询条件依赖于父查询</p><ul><li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表，并通过SELECT挑选对应的属性</li><li>然后再取外层表的下一个元组</li><li>重复这一过程，直至外层表全部检查完为止</li><li><strong>可以理解为外层查询是一个for循环遍历，提供特定的属性值给内层查询</strong></li></ul></li></ul><h3 id="不相关子查询"><a href="#不相关子查询" class="headerlink" title="不相关子查询"></a>不相关子查询</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678884526141-8bd5c4f0-889b-435e-8f55-c840ee324861.png" alt="image.png"></p><h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>求解相关子查询不能像求解不相关子查询那样一次将子查询求解出来，然后求解父查询。<strong>内层查询由于与外层查询有关,因此必须反复求值。</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678884364227-e11b60e5-bc7e-493c-a48a-0d9c555dbb26.png" alt="image.png"></p><h3 id="带有ANY（SOME）或ALL谓词的子查询"><a href="#带有ANY（SOME）或ALL谓词的子查询" class="headerlink" title="带有ANY（SOME）或ALL谓词的子查询"></a>带有ANY（SOME）或ALL谓词的子查询</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678948907513-ab1fd3c0-a35d-4033-bfa6-59400c59dfd2.png" alt="image.png"></p><h3 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678948932505-a0077c58-f842-437d-83db-00169da63ac0.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">where</span> <span class="keyword">exists</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept d <span class="keyword">where</span>  deptno <span class="operator">&lt;</span><span class="number">30</span> <span class="keyword">and</span> d.deptno <span class="operator">=</span> e.deptno ；</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>首先执行外查询 select * from emp e，然后取出第一行数据，将数据中的部门编号传给内查询</li><li>内查询执行select * from dept d where deptno &lt;30 and d.deptno &#x3D; e.deptno ；看是否查询到结果，查询到，则返回true，否则返回false；比如传来的是30，则不满足deptno &lt;30 and d.deptno &#x3D; 30，返回false</li><li>内查询返回true，则该行数据保留，作为结果显示；反之，返回false，则不作结果显示</li><li>逐行查询，看内查询是否查到数据，是否保留作结果显示</li></ol><p>如果上述内查询为： select * from dept d where deptno &lt;30<br />因为该语句都会查询到有结果，每一行都返回true，所以会查询到的是全部员工信息<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678948963092-a9935515-3b5a-41d4-b85e-f4aed157e4bf.png" alt="image.png"></p><h3 id="两层EXISTS的嵌套子查询"><a href="#两层EXISTS的嵌套子查询" class="headerlink" title="两层EXISTS的嵌套子查询"></a>两层EXISTS的嵌套子查询</h3><p>注意：SQL 查询的结果是一个集合，实际上就是一层全称谓词。如果给出的条件中再出现全称谓词，则可以转换为存在谓词进行查询。<br />注意：嵌套查询如果进行了相关查询，则实际上就是一个外层和内层进行笛卡尔积然后对结果集合进行筛选（嵌套内层进行筛选）的过程。</p><ul><li>查询（曾经）在所有部门待过的员工。</li></ul><p>转换为，不存在这样的部门，员工没有待过。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> departments d</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> dept_emp de</span><br><span class="line">    <span class="keyword">WHERE</span> d.dept_no<span class="operator">=</span>de.dept_no</span><br><span class="line">    <span class="keyword">AND</span> e.emp_no<span class="operator">=</span>de.emp_no</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>要先看select的语句代表的含义<ol><li><code>SELECT * FROM departments d</code> 选择所有的部门 – 可以理解为遍历所有的部门</li><li><code>SELECT * FROM dept_emp de WHERE d.dept_no=de.dept_no AND e.emp_no=de.emp_no</code> 选择某个员工在某个部门的工作信息</li></ol></li><li>直观理解：从<code>not exists</code>的语义上理解：不存在一个部门，该员工没有待过（没有工作信息） -&gt;要查找在所有部门都工作过的员工</li><li>从内到外理解：对于每一个员工e，检查每一个部门d，判断有无工作记录<ol><li>第二层子查询：判断有无工作记录，如果没有工作记录，第六行的<code>not exists</code>返回为<code>true</code> -&gt; 存在这样一个部门d，该员工在该部门没有工作信息 -&gt;第一层子查询返回的结果不是为空，第三行的<code>not exists</code>为<code>false</code>，因此第一行的<code>selcet</code>就不会执行</li><li>第二层子查询：如果有工作记录，第六行的<code>not exists</code>返回为<code>false</code> -&gt; 不存在这样一个部门d，该员工在该部门没有工作信息 ，第一层子查询中的<code>select</code>不会执行 -&gt; 该员工在部门d中有工作过，但是无法保证在其他部门也有工作记录，所以第一层子查询会挑选一个新的部门d后，重新进入第二层子查询判断 -&gt; 全部判断完后，如果仍然没有部门，说明第三行第三行的<code>not exists</code>为<code>true</code>，因此第一行的<code>selcet</code>就会执行 -&gt;得到想要的结果</li></ol></li></ol><h1 id="ch16-SQL数据查询（集合）"><a href="#ch16-SQL数据查询（集合）" class="headerlink" title="ch16 SQL数据查询（集合）"></a>ch16 SQL数据查询（集合）</h1><p>**参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同 **</p><h2 id="并操作-UNION"><a href="#并操作-UNION" class="headerlink" title="并操作 UNION"></a>并操作 UNION</h2><p>对于填入同一张表的数据：业务逻辑上应该相同。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678948314946-e541ccf6-e7dc-4496-88e2-5c90991c6782.png" alt="image.png"></p><h2 id="交操作-INTERSECT"><a href="#交操作-INTERSECT" class="headerlink" title="交操作 INTERSECT"></a>交操作 INTERSECT</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678948534537-1329d71c-7653-446f-a8c8-a819e0533393.png" alt="image.png"></p><h2 id="差操作-EXCEPT"><a href="#差操作-EXCEPT" class="headerlink" title="差操作 EXCEPT"></a>差操作 EXCEPT</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678948525831-57f95f6e-b175-49a0-ae67-4c27b856f5a1.png" alt="image.png"></p><h1 id="ch17-SQL数据查询（基于派生表）"><a href="#ch17-SQL数据查询（基于派生表）" class="headerlink" title="ch17 SQL数据查询（基于派生表）"></a>ch17 SQL数据查询（基于派生表）</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678949337283-b70e6583-3fd7-4ea1-a103-c2b2e7659f1c.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678949342819-89d545b6-280a-4d98-a723-890f3e001e82.png" alt="image.png"></p><h1 id="ch18-SQL数据更新-插入"><a href="#ch18-SQL数据更新-插入" class="headerlink" title="ch18 SQL数据更新-插入"></a>ch18 SQL数据更新-插入</h1><h2 id="插入元组"><a href="#插入元组" class="headerlink" title="插入元组"></a>插入元组</h2><p>将新元组插入指定表中，语句格式<br />INSERTINTO &lt;表名&gt; [(&lt;属性列1&gt;[,&lt;属性列2 &gt;…)]<br />VALUES (&lt;常量1&gt; [,&lt;常量2&gt;]… );</p><ul><li>INTO子句<ul><li>指定要插入数据的表名及属性列</li><li>属性列的顺序<strong>可与表定义中的顺序不一致</strong></li><li>没有指定属性列：表示要插入的是一条完整的元组，且<strong>属性列属性与表定义中的顺序一致</strong></li><li>指定部分属性列：插入的元组在其余属性列上取空值</li></ul></li><li>VALUES子句 提供的值必须与INTO子句匹配<ul><li>值的个数</li><li>值的类型</li></ul></li></ul><p>在关系型数据库中可以避免犯错误 - <strong>保姆型的</strong>，所以必须要提供限制，处理错误的方式交给：核（数据库）<br />NOSQL：不用约束形，代价是处理错误的方式交给：壳（应用）<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686639322051-f3114eef-1b52-4df0-bf01-a5aa6a51346b.png" alt="image.png"></p><h2 id="插入子查询"><a href="#插入子查询" class="headerlink" title="插入子查询"></a>插入子查询</h2><p>语句格式 <br />INSERT  INTO &lt;表名&gt;  [(&lt;属性列1&gt; [,&lt;属性列2&gt;…  )] <br /><strong>子查询</strong>;<br />INTO子句</p><ul><li><strong>子查询SELECT子句目标列必须与INTO子句匹配</strong><ul><li>值的个数</li><li>值的类型</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678951255982-212d039a-784c-4d09-9890-d6c2a52bc2ef.png" alt="image.png"></p><h1 id="ch19-SQL数据更新-修改"><a href="#ch19-SQL数据更新-修改" class="headerlink" title="ch19 SQL数据更新-修改"></a>ch19 SQL数据更新-修改</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678951349911-ef7d77cf-1b0f-4142-851e-effc367e7fb2.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678951436075-66bd4f43-ba8c-4fd4-956c-4716c3ef0794.png" alt="image.png"></p><h2 id="修改数据与完整性"><a href="#修改数据与完整性" class="headerlink" title="修改数据与完整性"></a>修改数据与完整性</h2><p>关系数据库管理系统在执行修改语句时会检查修改操作是否破坏表上已定义的完整性规则</p><ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性 <ul><li>NOT NULL约束 </li><li>UNIQUE约束 </li><li>值域约束</li></ul></li></ul><h1 id="ch20-SQL数据更新-删除"><a href="#ch20-SQL数据更新-删除" class="headerlink" title="ch20 SQL数据更新-删除"></a>ch20 SQL数据更新-删除</h1><p><code>delete</code>和<code>drop</code>有区别<br /><a href="https://blog.csdn.net/wuyoudeyuer/article/details/96143574">sql数据库中的 delete 与drop的区别</a><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678951683414-55912f75-7fe0-4adf-9cfc-5a7ddddc9220.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678951699500-b7659688-afde-4264-b329-0d5572eb18fe.png" alt="image.png"></p><h1 id="ch21-SQL中的空值"><a href="#ch21-SQL中的空值" class="headerlink" title="ch21 SQL中的空值"></a>ch21 SQL中的空值</h1><p>空值就是“不知道”或“不存在”或“无意义”的值。<br />一般有以下几种情况：</p><ul><li>该属性应该有一个值，但目前不知道它的具体值：我的对象（x）</li><li>该属性不应该有值：猫的平均学分绩点</li><li>由于某种原因不便于填写：涉及填写个人隐私的信息</li></ul><h2 id="空值的产生"><a href="#空值的产生" class="headerlink" title="空值的产生"></a>空值的产生</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686640015421-e0e4b7d0-7781-4b95-b90f-136a5a2aac49.png" alt="image.png"></p><h2 id="空值的判断"><a href="#空值的判断" class="headerlink" title="空值的判断"></a>空值的判断</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686640042695-ec42ac27-841a-4100-819a-ca234ecaaa55.png" alt="image.png"></p><h2 id="空值的约束条件"><a href="#空值的约束条件" class="headerlink" title="空值的约束条件"></a>空值的约束条件</h2><p>属性定义（或者域定义）中</p><ul><li>有NOT NULL约束条件的不能取空值</li><li><strong>加了UNIQUE限制的属性不能取空值</strong>：如果插入学号是null，可能学号已经重复了，则违反了unique的限制</li><li>码属性不能取空值</li></ul><h2 id="空值的算术运算、比较运算和逻辑运算"><a href="#空值的算术运算、比较运算和逻辑运算" class="headerlink" title="空值的算术运算、比较运算和逻辑运算"></a>空值的算术运算、比较运算和逻辑运算</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678952644166-f7f098f1-1351-4ee6-ba8a-1b362d2ef7ca.png" alt="image.png"></p><ul><li>空值与另一个值（包括另一个空值）的算术运算的结果为空值</li><li>空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。</li><li>有UNKNOWN后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑</li><li>处理空值，需要显式的使用<code>is null</code> 或者<code>is not null</code></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678952560490-624a2fab-f3a2-4d06-a72b-ee1862dc791e.png" alt="image.png"></p><h1 id="ch22-视图"><a href="#ch22-视图" class="headerlink" title="ch22 视图"></a>ch22 视图</h1><p>create table创建<br />create view创建的是数据结构，有什么不同？<br />视图的特点：</p><ul><li>虚表，是从一个或几个基本表（或视图）导出的表</li><li>只存放视图的定义，不存放视图对应的数据</li><li>基表中的数据发生变化，从视图中查询出的数据也随之改变</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678952816270-d613ec58-5fa5-45a8-9ef9-8b0a4d24c9b8.png" alt="image.png"></p><h2 id="建立视图"><a href="#建立视图" class="headerlink" title="建立视图"></a>建立视图</h2><p>组成视图的属性列名：全部省略或全部指定</p><ul><li>全部省略: 由子查询中SELECT目标列中的诸字段组成</li><li>明确指定视图的所有列名:<ul><li>某个目标列是聚集函数或列表达式</li><li>多表连接时选出了几个同名列作为视图的字段</li><li>需要在视图中为某个列启用新的更合适的名字</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686640520129-5220a35a-2f04-4b89-9ae6-ce35a5e00273.png" alt="image.png"></p><h3 id="行列子集视图"><a href="#行列子集视图" class="headerlink" title="行列子集视图"></a>行列子集视图</h3><p>[例3.85]建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生 。  <br />CREATE VIEW IS_Student  <br />AS   <br />SELECT Sno,Sname,Sage <br />FROM  Student  <br />WHERE  Sdept&#x3D; ‘IS’  <br />WITH CHECK OPTION;</p><ul><li>定义IS_Student视图时加上了WITH CHECK OPTION子句，<strong>对该视图进行插入、修改和删除操作时，RDBMS会自动加上Sdept&#x3D;’IS’的条件。</strong></li><li>若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，我们称这类视图为行列子集视图。</li><li>IS_Student视图就是一个行列子集视图。</li></ul><p>操作视图就是操作基本表</p><h3 id="基于多个表的视图"><a href="#基于多个表的视图" class="headerlink" title="基于多个表的视图"></a>基于多个表的视图</h3><p>[例3.86]  建立信息系选修了1号课程的学生的视图（包括学号、姓名、成绩）。        </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S1(Sno,Sname,Grade)        </span><br><span class="line"><span class="keyword">AS</span>         </span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Grade        </span><br><span class="line"><span class="keyword">FROM</span>  Student,SC       </span><br><span class="line"> <span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span> <span class="keyword">AND</span>                       </span><br><span class="line">Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span>                       </span><br><span class="line">SC.Cno<span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="基于视图的视图"><a href="#基于视图的视图" class="headerlink" title="基于视图的视图"></a>基于视图的视图</h3><p>[例3.87]  建立信息系选修了1号课程且成绩在90分以上的学生的视图。        </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S2        </span><br><span class="line"><span class="keyword">AS</span>        </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Grade        </span><br><span class="line"><span class="keyword">FROM</span>  IS_S1        </span><br><span class="line"><span class="keyword">WHERE</span>  Grade<span class="operator">&gt;=</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure><h3 id="基于表达式的视图"><a href="#基于表达式的视图" class="headerlink" title="基于表达式的视图"></a>基于表达式的视图</h3><p>[例3.88]  定义一个反映学生出生年份的视图。        </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> BT_S(Sno,Sname,Sbirth)        </span><br><span class="line"><span class="keyword">AS</span>         </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,<span class="number">2014</span><span class="operator">-</span>Sage        </span><br><span class="line"><span class="keyword">FROM</span>  Student;</span><br></pre></td></tr></table></figure><h3 id="分组视图"><a href="#分组视图" class="headerlink" title="分组视图"></a>分组视图</h3><p>[例3.89]  将学生的学号及平均成绩定义为一个视图   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREAT  <span class="keyword">VIEW</span>     S_G(Sno,Gavg)             </span><br><span class="line"><span class="keyword">AS</span>               </span><br><span class="line"><span class="keyword">SELECT</span> Sno,<span class="built_in">AVG</span>(Grade)             </span><br><span class="line"><span class="keyword">FROM</span>  SC             </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure><h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><p>语句的格式：    DROP  VIEW  &lt;视图名&gt;[CASCADE];</p><ul><li>该语句从数据字典中删除指定的视图定义</li><li>如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除</li><li><strong>删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686640923455-461b2d10-665e-4bfb-b6f9-8c5d39251c5e.png" alt="image.png"></p><h2 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h2><ul><li>用户角度：查询视图与查询基本表相同</li><li>关系数据库管理系统实现视图查询的方法</li></ul><p>视图消解法（View Resolution）</p><ul><li>进行有效性检查</li><li>转换成等价的对基本表的查询</li><li>执行修正后的查询</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686640993973-068b6fab-701f-4697-8dd0-8b8bb878bd66.png" alt="image.png"><br>where语句后面不能接聚集函数，where的执行顺序先于聚集函数的执行顺序<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686641012061-5f304569-5979-4f0e-a9b2-39c8aa8964da.png" alt="image.png"></p><h2 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679552964333-3d81b36b-cc74-4e7d-a118-131c10cd395b.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679553002093-fa43906d-a3ab-4c3b-9afc-cd6bcca155a2.png" alt="image.png"></p><h2 id="不可更新视图"><a href="#不可更新视图" class="headerlink" title="不可更新视图"></a>不可更新视图</h2><ul><li><strong>有多对一的关系，不能更新</strong>：成绩 &#x3D; 平时成绩 * a1 + 期末成绩 * a2，直接更新成绩</li><li>没有判断做逆运算的函数：四舍五入的函数</li><li><strong>一个不允许更新的视图上定义的视图也不允许更新</strong></li></ul><p>要玩一些比较花的操作：</p><ul><li>解决方案符合业务方案吗？</li><li>不同数据库对这种情况处理方式不同，如果需要进行数据库的移植，会出错</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679553086600-5f892622-ed8d-4046-841f-4b7246e72171.png" alt="image.png"><br>例如：修改平均成绩为90，但是基表中的成绩无法修改，因为是多对一的映射</p><h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><h3 id="视图能够简化用户的操作"><a href="#视图能够简化用户的操作" class="headerlink" title="视图能够简化用户的操作"></a>视图能够简化用户的操作</h3><p>当视图中数据不是直接来自基本表时，定义视图能够简化用户的操作</p><ul><li>基于多张表连接形成的视图</li><li>基于复杂嵌套查询的视图</li><li>含导出属性的视图</li></ul><h3 id="视图使用户能以多种角度看待同一数据"><a href="#视图使用户能以多种角度看待同一数据" class="headerlink" title="视图使用户能以多种角度看待同一数据"></a>视图使用户能以多种角度看待同一数据</h3><ul><li>视图机制能使不同用户以不同方式看待同一数据</li><li>适应数据库共享的需要</li></ul><h3 id="视图对重构数据库提供了一定程度的逻辑独立性"><a href="#视图对重构数据库提供了一定程度的逻辑独立性" class="headerlink" title="视图对重构数据库提供了一定程度的逻辑独立性"></a>视图对重构数据库提供了一定程度的逻辑独立性</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686641428332-77aefc9e-b91a-473c-a0b8-cf427e73a511.png" alt="image.png"></p><h3 id="视图能够对机密数据提供安全保护"><a href="#视图能够对机密数据提供安全保护" class="headerlink" title="视图能够对机密数据提供安全保护"></a>视图能够对机密数据提供安全保护</h3><p>对不同用户定义不同视图，使每个用户只能看到他有权看到的数据</p><h3 id="适当的利用视图可以更清晰的表达查询"><a href="#适当的利用视图可以更清晰的表达查询" class="headerlink" title="适当的利用视图可以更清晰的表达查询"></a>适当的利用视图可以更清晰的表达查询</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686641365013-95771888-d1d9-411a-8acb-08dcfbe757dc.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter04 - 数据库安全性</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter04%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter04%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="ch24-存取控制"><a href="#ch24-存取控制" class="headerlink" title="ch24 存取控制"></a>ch24 存取控制</h1><p>数据库安全最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据，这主要通过数据库系统的存取控制机制实现。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679991967570-4a2e38e9-cac6-4f7a-90e1-6b6b71170989.png" alt="image.png"></p><ol><li>在自主存取控制方法中，用户对<strong>于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限</strong>，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制<strong>非常灵活</strong>。</li><li>在强制存取控制方法中，<strong>每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。</strong>对于任意一个对象，只有具有合法许可证的用户才可以存取。强制存取控制因此相对<strong>比较严格</strong>。</li></ol><h2 id="自主存取控制-DAC"><a href="#自主存取控制-DAC" class="headerlink" title="自主存取控制 DAC"></a>自主存取控制 DAC</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679992981293-0871ea92-aa7b-4dca-ae95-ebf9e0cf28e3.png" alt="image.png"><br>用户权限是由两个要素组成的：<strong>数据库对象和操作类型</strong>。定义一个用户的<strong>存取权限</strong>就是要定义这个用户可以<strong>在哪些数据库对象上进行哪些类型的操作</strong>。在数据库系统中，定义存取权限称为授权（authorization)。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680194012124-4400a431-c8da-438e-b37c-347fad68b161.png" alt="image.png"><br>列权限包括SELECT、REFERENCES、INSERT、UPDATE,其含义与表权限类似。需要说明的是,<strong>对列的UPDATE权限指对于表中存在的某一列的值可以进行修改。</strong>当然，有了这个权限之后，在修改的过程中还要<strong>遵守表在创建时定义的主码及其他约束。</strong>列上的 INSERT权限指用户可以插入一个元组，对于该插入的元组，授权用户可以插入指定的值（因为已经给了对应的列的选权限了），其他列或者为空，或者为默认值（因为没有给对应的列的权限）。<strong>在给用户授予列INSERT权限时，一定要包含主码的INSERT权限，否则用户的插入动作会因为主码为空而被拒绝。</strong><br /><code>INSERT INTO customers (customer_id, customer_name) VALUES (NULL, &#39;John Doe&#39;); </code><br />在这个例子中，我们向名为<strong>customers</strong>的表格中插入了一行数据。由于我们没有被授予主码的INSERT权限，所以我们无法为主码指定一个值。因此，我们将主码的值设置为NULL。但是，由于主码为空，这个插入操作将被拒绝。</p><h3 id="授权：授予与收回"><a href="#授权：授予与收回" class="headerlink" title="授权：授予与收回"></a>授权：授予与收回</h3><h4 id="GRANT"><a href="#GRANT" class="headerlink" title="GRANT"></a>GRANT</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680226865954-99f22fb5-0061-43b3-a5fa-5dfd37837ca1.png" alt="image.png"><br>其语义为：将对指定操作对象的指定操作权限授予指定的用户。发出该GRANT语句的可以是<strong>数据库管理员</strong>，也可以是该<strong>数据库对象创建者(即属主owner)<strong>，还可以是</strong>已经拥有该权限的用户</strong>。接受权限的用户可以是<strong>一个或多个具体用户</strong>，也可以是<strong>PUBLIC</strong>，即<strong>全体用户</strong>。<br />如果指定了 <strong>WITH GRANT OPTION</strong>子句，则获得某种权限的用户还可以<strong>把这种权限再授予其他的用户</strong>。<br />如果没有指定 WITH GRANT OPTION子句，则获得某种权限的用户只能使用该权限，不能传播该权限。<br />SQL标准允许具有WITH GRANT OPTION的用户把<strong>相应权限</strong>或其<strong>子集</strong>传递授予其他用户，但<strong>不允许循环授权</strong>，即被授权者不能把权限再授回给授权者或其祖先<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680226954469-73346430-efe1-49a5-a67f-7445c75da13e.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680227168088-8840b751-ba45-477a-b022-3d14e0484344.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680226998249-0c141607-c7ee-4e74-908f-7dcc30129e95.png" alt="image.png"><br>GRANT语句</p><ul><li>可以一次向一个用户授权</li><li>可以一次向多个用户授权，如例4.2</li><li>可以一次传播多个同类对象的权限，如例4.2</li><li>可以一次完成对基本表和属性列这些不同对象的授权，如例4.4</li></ul><h4 id="REVOKE"><a href="#REVOKE" class="headerlink" title="REVOKE"></a>REVOKE</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680227231281-27e91b58-d94c-49a1-b28f-a3988550d8fe.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680227891842-90f9d462-c128-4cb8-9768-9a6c140a91f5.png" alt="image.png"><br>SQL提供了非常灵活的授权机制。数据库管理员拥有对数据库中所有对象的所有权限,并可以根据实际情况将不同的权限授予不同的用户。<br />用户对自己建立的基本表和视图拥有全部的操作权限，并且可以用GRANT 语句把其中某些权限授予其他用户。被授权的用户如果有“继续授权”的许可，还可以把获得的权限再授予其他用户。<br />所有授予出去的权力在必要时又都可以用REVOKE 语句收回。<br />可见，<strong>用户可以“自主”地决定将数据的存取权限授予何人、决定是否也将“授权”的权限授予别人。因此称这样的存取控制是自主存取控制。</strong></p><h4 id="创建数据库模式的权限"><a href="#创建数据库模式的权限" class="headerlink" title="创建数据库模式的权限"></a>创建数据库模式的权限</h4><p>GRANT和 REVOKE 语句<strong>向用户授予或收回对数据的操作权限</strong>。对创建<strong>数据库模式类</strong>的数据库对象的授权则由数据库管理员在创建用户时实现。<br />CREATE USER语句一般格式如下:<br /><code>CREATE USER&lt;username&gt;[WITH] [DBA|RESOURCE|CONNECT];</code><br />对CREATE USER语句说明如下：</p><ul><li>只有系统的超级用户才有权创建一个新的数据库用户。</li><li>新创建的数据库用户有三种权限：CONNECT、RESOURCE和DBA。</li></ul><p>CREATE USER命令中如果没有指定创建的新用户的权限，默认该用户拥有CONNECT 权限。</p><ul><li>拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库。由数据库管理员或其他用户授予他应有的权限，根据获得的授权情况他可以对数据库对象进行权限范围内的操作。</li><li>拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主，但不能创建模式，不能创建新的用户。数据库对象的属主可以使用GRANT 语句把该对象上的存取权限授予其他用户。</li><li>拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等;DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680228586471-13109b09-b82e-493f-a6f9-863155cf1973.png" alt="image.png"></p><h3 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h3><p><strong>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。</strong>因此可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过程。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680228893318-1facf0e8-6945-4364-9877-caa633be46da.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680229031125-b02bfcd9-1de7-44b7-b816-1ee57ecc8255.png" alt="image.png"><br><code>R1</code>相当于一个权限的集合<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680229006264-13052ea4-7133-4800-b9e2-32bcf9f4815b.png" alt="image.png"></p><h3 id="自主存取控制缺点"><a href="#自主存取控制缺点" class="headerlink" title="自主存取控制缺点"></a>自主存取控制缺点</h3><p>离散，分布式的，各管各的权限。收回了A的权限，但是A可能从其他方面拿到了权限。<br />可能存在数据的“无意泄露”</p><ul><li>原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记</li><li>解决：对系统控制下的所有主客体实施强制存取控制策略</li></ul><p>自主存取控制（MAC）能够通过授权机制有效地控制对敏感数据的存取。但是由于用户对数据的存取权限是“自主”的，<strong>用户可以自由地决定将数据的存取权限授予何人，以及决定是否也将“授权”的权限授予别人。在这种授权机制下，仍可能存在数据的“无意泄露”。</strong><br />比如，甲将自己权限范围内的某些数据存取权限授权给乙，甲的意图是仅允许乙本人操纵这些数据。但甲的这种安全性要求并不能得到保证，因为乙一旦获得了对数据的权限，就可以将数据备份，获得自身权限内的副本，并在不征得甲同意的前提下传播副本。造成这一问题的根本原因就在于，<br />这种机制<strong>仅仅通过对数据的存取权限来进行安全控制,而数据本身并无安全性标记。</strong>要解决这一问题，就需要对系统控制下的所有主客体实施强自主存取控制(MAC)</p><h2 id="强制存取控制-MAC"><a href="#强制存取控制-MAC" class="headerlink" title="强制存取控制 MAC"></a>强制存取控制 MAC</h2><p>不再让权限管理成为离散式的，而是统一放在一起综合考量。<br />数据对象：数据库、表……<br />将用户、数据拆分为不同级别，以某种明确的方式定义两者的读写映射。<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679992689286-73f9338d-1920-41e3-a851-d6b230bbf02f.png" alt="1679992684606.png"><br>适用于：<strong>密级明确</strong>，因为灵活性低，所以适合有明确标准的</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</p><ul><li>主体是系统中的活动实体<ul><li>数据库管理系统所管理的实际用户</li><li>代表用户的各进程</li></ul></li><li>客体是系统中的被动实体，受主体操纵 <ul><li>文件、基本表、索引、视图</li></ul></li></ul><h3 id="敏感度标记"><a href="#敏感度标记" class="headerlink" title="敏感度标记"></a>敏感度标记</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679992785932-0078c93f-db1b-4fd1-8ba4-aa1de45bc04c.png" alt="image.png"><br>小兵（低权限）可以写可信的，通报给上级 — 由下至上可以写<br />将军讨论时，写信不小心泄漏到公开信（小兵）— 由上至下不可以写<br />机密同一级别：红军发起，那么蓝军也能看到 — 需要使用不同存取控制方式</p><h3 id="强制存取控制规则"><a href="#强制存取控制规则" class="headerlink" title="强制存取控制规则"></a>强制存取控制规则</h3><p>强制存取控制规则</p><ul><li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体</li><li>仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体</li><li>强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。<blockquote><p>假如A的级别大于B，即A拥有的保密信息等级更高，此时如果A有对B的写入权限，那么很可能会将保密信息写入B，B的等级较低，会将保密信息传播，造成泄密。<br>所以只有小于等于时才能写入，保证秘密不向下传播扩散，只向上保留。<br>EX1:校长知道的东西最多,大家说的话,校长都能看见.但是,校长看见了A的悄悄话，想要告诉跟A一个宿舍的B，却办不到，因为第二条规则。意思是校长只能把A说的发布给跟他同级的或者比他级别还高的。这就是保证秘密不向下传播扩散，只向上保留。</p></blockquote></li></ul><h3 id="DAC-MAC"><a href="#DAC-MAC" class="headerlink" title="DAC + MAC"></a>DAC + MAC</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679993583920-21a2dbb6-64a7-4312-8efe-a7513fb75475.png" alt="image.png"></p><h1 id="ch25-视图机制、审计、数据加密及其他"><a href="#ch25-视图机制、审计、数据加密及其他" class="headerlink" title="ch25 视图机制、审计、数据加密及其他"></a>ch25 视图机制、审计、数据加密及其他</h1><h2 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h2><p>需求：学生信息分别给对应宿舍长</p><ul><li>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护</li><li>间接地实现支持存取谓词的用户权限定义</li><li>对数据进行筛选，获得对部分元组的权限</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680229517840-83fd3a7f-adc2-493e-b737-e1b6bcf85926.png" alt="image.png"></p><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><ul><li>审计功能把用户对数据库的<strong>所有操作自动记录下来放入审计日志</strong>（auditlog）中。</li><li>审计员可以<strong>利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。</strong>还可以通过对审计日志分析，对潜在的威胁提前采取措施加以防范。</li></ul><p>审计通常是<strong>很费时间和空间</strong>的,所以数据库管理系统往往都将审计设置为可选特征，允许数据库管理员<strong>根据具体应用对安全性的要求灵活地打开或关闭审计功能。</strong>审计功能主要用于安全性要求较高的部门。<br />可审计事件有服务器事件、系统权限、语句事件及模式对象事件，还包括用户鉴别、自主访问控制和强制访问控事件。换句话说，它能对普通和特权用户行为、各种表操作、身份鉴别、自主和强制访问控制等操作进行审计。它既能审计成功操作，也能审计失败操作。<br />记录：有意义的操作和数据库状态<br />作用：分析操作是否异常<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679993891585-0a44161f-2c09-41ae-9060-dbbe7cb94537.png" alt="image.png"></p><h3 id="审计事件"><a href="#审计事件" class="headerlink" title="审计事件"></a>审计事件</h3><ul><li>服务器事件：审计数据库服务器发生的事件，包含数据库服务器的启动、停止、数据库服务器配置文件的重新加载。</li><li>系统权限：对系统拥有的结构或模式对象进行操作的审计，要求该操作的权限是通过系统权限获得的。</li><li>语句事件：对SQL语句，如DDL、DML、DQL(Data Query Language，数据查询语言)及 DCL语句的审计。</li><li>模式对象事件：对特定模式对象上进行的SELECT 或 DML操作的审计。模式对象包括表、视图、存储过程、函数等。模式对象不包括依附于表的索引、约束、触发器、分区表等。</li></ul><h3 id="审计功能"><a href="#审计功能" class="headerlink" title="审计功能"></a>审计功能</h3><ul><li>基本功能，提供多种审计查阅方式:基本的、可选的、有限的，等等。</li><li>提供多套审计规则，审计规则一般在数据库初始化时设定，以方便审计员管理。</li><li>提供审计分析和报表功能。</li><li>审计日志管理功能，<ul><li>防止审计员误删审计记录，审计日志必须先转储后删除</li><li>对转储的审计记录文件提供完整性和保密性保护</li><li>只允许审计员查阅和转储审计记录，<strong>不允许任何用户新增和修改审计记</strong>；等等。</li></ul></li><li>系统提供查询审计设置及审计记录信息的专门视图。对于系统权限级别、语句级别及模式对象级别的审计记录也可通过相关的系统表直接查看。（就是说不同级别，不同类型的审计信息有不同的表专门查看）</li></ul><h3 id="审计级别"><a href="#审计级别" class="headerlink" title="审计级别"></a>审计级别</h3><p>审计一般可以分为用户级审计和系统级审计。</p><ul><li>用户级审计是任何用户可设置的审计<ul><li>主要是用户针对自己创建的数据库表或视图进行审计</li><li>记录所有用户对这些表或视图的一切成功和（或)不成功的访问要求以及各种类型的SQL操作。</li></ul></li><li>系统级审计<ul><li>只能由数据库管理员设置</li><li>用以监测成功或失败的登录要求、监测授权和收回操作以及其他数据库级权限下的操作。</li></ul></li></ul><h3 id="审计语句"><a href="#审计语句" class="headerlink" title="审计语句"></a>审计语句</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680230125340-7754540b-2f78-4b16-bc54-51415d34c617.png" alt="image.png"><br>审计设置以及审计日志一般都存储在数据字典中。必须把审计开关打开(即把系统参数 audit_trail 设为true)，才可以在系统表SYS_AUDITTRAIL中查看到审计信息。<br /><strong>数据库安全审计系统提供了一种事后检查的安全机制。</strong>安全审计机制将特定用户或者特定对象相关的操作记录到系统审计日志中，作为后续对操作的查询分析和追踪的依据。通过审计机制,可以约束用户可能的恶意操作。</p><h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679994688934-810d10f7-d9f4-40f1-9535-caffa98b59ac.png" alt="image.png"></p><h3 id="存储加密"><a href="#存储加密" class="headerlink" title="存储加密"></a>存储加密</h3><p>透明：需要软硬件资源<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679994769803-4906bcd7-ec20-4de3-af50-40f599b77ae1.png" alt="image.png"></p><h3 id="传输加密"><a href="#传输加密" class="headerlink" title="传输加密"></a>传输加密</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679994829208-b566d54b-9be3-44dd-b21e-eff88222fdd7.png" alt="image.png"></p><h2 id="其他安全性保护"><a href="#其他安全性保护" class="headerlink" title="其他安全性保护"></a>其他安全性保护</h2><p>推理控制：</p><ul><li>推理访问方式：通过自己的URL，推理别人的URL，得到别人的数据。解决：乱序映射或者权限控制</li><li>推理数据内容：对答案，知道我的成绩，推理出他的成绩</li></ul><p>隐蔽信道：附加需要传递的数据</p><ul><li>文件系统：要求传递图片 — 在图片中嵌入docx文档</li><li>插入数据会产生0,1的结果返回，多次访问能够形成0 1 串</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679994921080-9499f3b2-1f9f-4d29-9c83-907653d62000.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter05 - 数据库完整性</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter05%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter05%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="ch26-数据库完整性"><a href="#ch26-数据库完整性" class="headerlink" title="ch26 数据库完整性"></a>ch26 数据库完整性</h1><p>用户定义的完整性：<code>not null``unique</code> 数据类型的定义、域的定义<br />将一张大表拆分成两张表（性能要求）：检查两张表的属性<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679996497075-363694f6-912c-40b3-b4db-31d08f144e37.png" alt="image.png"></p><ol><li>如果数据库不进行检查，则共享数据库时，会出错。Api甲的接口检查不完备，会导致Api乙接口取到的数据不完备。</li><li>具有共性（在不同应用域中都要进行检查）的数据中数据库中进行检查<ol><li>学号 – 和学生紧密相关。不论在哪个应用域使用和学生有关的数据，都需要检查学号 — 所以可以做数据库中检查</li><li>不挂科（在奖学金评比的应用域中） – 则不是在数据库中进行检查，而是在特定的应用域中检查</li></ol></li><li><strong>当前完整性检查，哪些数据是和主体本质相关的，哪些数据是和应用域相关的</strong></li></ol><h2 id="完整性-VS-安全性"><a href="#完整性-VS-安全性" class="headerlink" title="完整性 VS 安全性"></a>完整性 VS 安全性</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679997128609-cb8b9047-3e75-4d1e-b2ac-9a61e7e8e81e.png" alt="image.png"></p><h2 id="完整性机制"><a href="#完整性机制" class="headerlink" title="完整性机制"></a>完整性机制</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1679997223787-02104430-0490-4e8e-adc0-35c0607b1091.png" alt="image.png"><br>事务提交：要么all，要么nothing</p><h1 id="ch27-实体完整性"><a href="#ch27-实体完整性" class="headerlink" title="ch27 实体完整性"></a>ch27 实体完整性</h1><p>关系模型的实体完整性CREATE  TABLE中用PRIMARY KEY定义</p><ul><li><strong>单属性构成的码有两种说明方法</strong><ul><li>定义为列级约束条件</li><li>定义为表级约束条件</li></ul></li><li><strong>对多个属性构成的码只有一种说明方法</strong><ul><li>定义为表级约束条件</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686646100819-0513d1b0-f785-40f5-a7ee-8589893ff5de.png" alt="image.png"></p><h2 id="实体完整性检查"><a href="#实体完整性检查" class="headerlink" title="实体完整性检查"></a>实体完整性检查</h2><p>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：</p><ul><li>检查<strong>主码值是否唯一</strong>，如果不唯一则拒绝插入或修改</li><li>检查<strong>主码的各个属性是否为空</strong>，只要有一个为空就拒绝插入或修改</li></ul><h3 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680156613575-cd39eb29-6df5-403c-99a3-55eb3be0e871.png" alt="image.png"></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680156723777-03371981-64e1-4757-a757-ac209770af2a.png" alt="image.png"></p><h1 id="ch28-参照完整性"><a href="#ch28-参照完整性" class="headerlink" title="ch28 参照完整性"></a>ch28 参照完整性</h1><p>关系模型的参照完整性定义</p><ul><li>在CREATE TABLE中用FOREIGN KEY 短语定义哪些列为外码</li><li><strong>用REFERENCES 短语指明这些外码参照哪些表的主码。</strong></li></ul><p>意义：<br />现实世界中的实体之间往往存在着某种联系，在关系模型中，实体以及实体之间的联系都是用关系来表示的，这样就自然存在着关系与关系之间的引用<br />参照完整性就是<strong>描述实体之间的联系的</strong>，一般是指多个实体或关系之间的关联关系<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680157434426-2bfa94df-877f-42b7-b744-e4119347cf14.png" alt="image.png"><br>SC：选修记录</p><h2 id="参照完整性检查"><a href="#参照完整性检查" class="headerlink" title="参照完整性检查"></a>参照完整性检查</h2><p>一个参照完整性将两个表中的相应元组联系起来<br /><strong>对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查</strong><br />例如，对表SC和Student有四种可能破坏参照完整性的情况 :</p><ul><li>SC表中增加一个元组，该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</li><li>修改SC表中的一个元组，修改后该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</li><li>从Student表中删除一个元组，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</li><li>修改Student表中一个元组的Sno属性，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等 。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680157302490-24d389ad-aa74-4e14-aa63-c6c86edf82e5.png" alt="image.png"><br>删除课程 – 学生的选修记录也为空</p><h2 id="违约处理"><a href="#违约处理" class="headerlink" title="违约处理"></a>违约处理</h2><p>在处理参照完整性，设为null时，需要小心是否会导致用户完整性、主体完整性的破坏<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680157614410-bcae9d98-c89e-482b-a91f-fba70d378da8.png" alt="image.png"><br>例如，有下面2个关系    <br />学生（学号，姓名，性别，专业号，年龄） ，专业号是外码   <br />专业（专业号，专业名）<br />假设专业表中某个元组被删除，专业号为12<br />按照设置为空值的策略，就要把学生表中专业号&#x3D;12的<strong>所有元组的专业号设置为空值</strong><br />**对应语义：某个专业删除了，该专业的所有学生专业未定，等待重新分配专业 **<br />参照主体出问题时，没有特别的语义<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680157686219-eea51142-84ab-40fa-9697-4feb5f924651.png" alt="image.png"></p><h2 id="外码空值问题"><a href="#外码空值问题" class="headerlink" title="外码空值问题"></a>外码空值问题</h2><p>这里讲解一下外码能否接受空值的问题。<br /><strong>外码变成空值</strong></p><ul><li><strong>是否符合现实的语义</strong></li><li><strong>是否是作为主属性</strong></li></ul><p>例如，学生表中“专业号”是外码，按照应用的实际情况可以取空值，表示这个学生的专业尚未确定。但在学生一选课数据库中，关系Student为被参照关系，其主码为Sno；SC为参照关系，Sno为外码，它能否取空值呢？答案是否定的。因为Sno为SC的主属性,按照实体完整性Sno不能为空值。若SC的Sno为空值，则<strong>语义是：表明尚不存在的某个学生，或者某个不知学号的学生，选修了某门课程，其成绩记录在 Grade列中。</strong>这与学校的应用环境是不相符的，因此SC的Sno列不能取空值。同样，SC的 Cno是外码，也是<del>SC（书中有错）</del> Course的主属性，也不能取空值，因为<strong>语义会变为：学生选了一门课程，但是该课程没有课程号</strong><br />因此<strong>对于参照完整性，除了应该定义外码，还应定义外码列是否允许空值。</strong><br />一般地，当对参照表和被参照表的操作违反了参照完整性时，系统选用默认策略，即拒绝执行。如果想让系统采用其他策略则必须在创建参照表时显式地加以说明。<br />但，外码也是可以为空值的<br /><strong>外码可以为空，但只能在参照表里为空</strong><br />举个栗子<br />学生(学生号，专业号)专业号是外码<br />专业(专业名，专业号）专业号是主码<br />在《学生》关系中，<strong>语义上：专业号为空表示还未给该学生分配专业。</strong><br />但是！<br />在《专业》关系中，专业号不能为空(实体完整性）</p><h1 id="ch29-用户定义的完整性"><a href="#ch29-用户定义的完整性" class="headerlink" title="ch29 用户定义的完整性"></a>ch29 用户定义的完整性</h1><ul><li>属性的约束：只涉及到单一属性 – 年龄：18-35、检测住址是否合法</li><li>元组的约束：涉及到不同属性的约束 – 男生不能住在4栋、检测住址和身份证号是否对应</li></ul><p>体现的是：数据之间相互约束，体现的是<strong>一般性</strong>，而不是特殊性。特殊性的约束要交给应用程序自身<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680158148971-585d317e-c110-4ac4-bd94-6d6aa7f4d863.png" alt="image.png"><br>拒绝执行：是因为数据库无法对不同的错误进行统一的处理。男生住在4栋：是性别不对还是地址不对。</p><h2 id="属性上的约束"><a href="#属性上的约束" class="headerlink" title="属性上的约束"></a>属性上的约束</h2><h3 id="列值非空"><a href="#列值非空" class="headerlink" title="列值非空"></a>列值非空</h3><p>数据类型的检查：可以看做是属性上的约束，但是非常粗糙<br />例如：对年龄进行char类型的限制<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680158349595-81a2d183-09ef-4b76-88c4-5562c67bacf9.png" alt="image.png"></p><h3 id="列值唯一"><a href="#列值唯一" class="headerlink" title="列值唯一"></a>列值唯一</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680158430340-1fbec041-4693-4ddb-84c0-5722ca33fd2c.png" alt="image.png"></p><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680158401878-72436834-1696-45c3-b3c1-eb7ddbb2a477.png" alt="image.png"><br>char是单字节还是双字节，在不同数据库中有不同的定义<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680158455939-1cf27c13-f4c2-4937-8482-5fb1c9965969.png" alt="image.png"></p><h2 id="元组上的约束"><a href="#元组上的约束" class="headerlink" title="元组上的约束"></a>元组上的约束</h2><p>涉及：非常多的属性<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680158573007-a5f920c1-866c-4a4e-abd8-f43c77119c61.png" alt="image.png"></p><h2 id="完整性约束命名子句"><a href="#完整性约束命名子句" class="headerlink" title="完整性约束命名子句"></a>完整性约束命名子句</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680158645235-6a88a0e2-4140-49bb-bfd8-0bd93fe322d5.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680266928753-af471055-9400-4d4e-b227-46f9699773b2.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680266867536-9a3eb7c7-c78e-4afe-adca-8475785adaee.png" alt="image.png"></p><h1 id="ch30-断言"><a href="#ch30-断言" class="headerlink" title="ch30 断言"></a>ch30 断言</h1><ol><li>涉及到的是多个表的完整性约束</li><li>不是所有的数据库都支持。相对来说比较麻烦</li><li>表现的业务逻辑有限</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680158832626-8eda596f-5637-4954-8f02-d6b100a95dd9.png" alt="image.png"><br>例子：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680267928080-7c6d44bd-cee8-42f5-a52f-bbde2ee7e670.png" alt="image.png"></p><ol><li><code>group by</code>可以接多个参数，按照一一组合的方式进行分组</li><li><code>all</code>表示遍历所有，每一个都必须满足相关条件</li><li>在执行相应语句时，会检查断言是否成立</li></ol><h1 id="ch31-触发器"><a href="#ch31-触发器" class="headerlink" title="ch31 触发器"></a>ch31 触发器</h1><blockquote><p><strong>触发器（trigger）是用户定义在关系表上的一类由事件驱动的特殊过程。</strong>一旦定义，触发器将被保存在数据库服务器中。任何用户对表的增、删、改操作均由服务器自动激活相应的触发器，在关系数据库管理系统核心层进行集中的完整性控制。触发器类似于约束,但是比约束更加灵活，可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力。</p></blockquote><p>面向过程的<br />变量可以在触发条件、触发动作体中使用<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680268644619-5b3b8585-d2e6-4c88-92ff-7b6fecaafce8.png" alt="image.png"></p><blockquote><ul><li>尖括号（&lt; &gt;）表示必须填写的内容，如&lt;触发器名&gt;、&lt;触发事件&gt;、&lt;表名&gt;等。</li><li>大括号（{ }）表示必须从其中选择一个选项，如{BEFORE | AFTER}、{ROW | STATEMENT}等。</li><li>中括号（[ ]）表示可选的内容，如[WHEN &lt;触发条件&gt;]等。</li></ul></blockquote><p>慎用<br /><code>all or nothing</code>特性</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol><li><strong>只有表的拥有者，即创建表的用户才可以在表上创建触发器</strong>，并且一个表上只能创建一定数量的触发器。触发器的具体数量由具体的关系数据库管理系统在设计时确定。</li><li>触发器名</li></ol><p>触发器名可以包含模式名，也可以不包含模式名。同一模式下，触发器名必须是唯一的，并且触发器名和表名必须在同一模式下。</p><ol start="3"><li>表名</li></ol><p><strong>触发器只能定义在基本表上，不能定义在视图上</strong>。当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器，因此<strong>该表也称为触发器的目标表</strong>。</p><ol start="4"><li>触发事件</li></ol><p><strong>触发事件可以是 INSERT、DELETE 或 UPDATE,也可以是这几个事件的组合</strong>，如INSERT OR DELETE等，还可以是UPDATE OF &lt;触发列，…&gt;，即进一步指明修改哪些列时激活触发器。<strong>AFTER&#x2F;BEFORE是触发的时机</strong>。AFTER表示在触发事件的操作执行之后激活触发器;BEFORE表示在触发事件的操作执行之前激活触发器。</p><ol start="5"><li>触发器类型</li></ol><p>触发器按照所触发动作的间隔尺寸可以分为<strong>行级触发器(FOR EACH ROW)和语句级触发器（FOR EACH STATEMENT)。</strong></p><ol start="6"><li>触发条件</li></ol><p>触发器被激活时，只有当触发条件为真时触发动作体才执行;否则触发动作体不执行。<strong>如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行</strong></p><ol start="7"><li>触发动作体</li></ol><p><strong>触发动作体可以是一个匿名PL&#x2F;SQL过程块    也可以是对已创建存储过程的调用</strong><br />如果是行级触发器，用户都可以在过程体中<strong>使用NEW和OLD引用事件之后的新值和事件之前的旧值</strong>。<br /><strong>如果是语句级触发器，则不能在触发动作体中使用NEW ROW或OLD ROW进行引用</strong>，如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680161375450-fd8a7979-7091-40f3-8778-1594933ab9ad.png" alt="image.png"><br><strong>语句级触发器是指一条SQL语句触发一次；</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680268619405-ea91768a-5264-4e8f-8aac-3c271d44853f.png" alt="image.png"><br><strong>行级触发器是指一条SQL语句影响的每一行触发一次。</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680161569418-bc2914f0-f4aa-4ffe-bd49-7d1947db1b61.png" alt="image.png"><br>业务逻辑：修改分数不能提高太多</p><ol><li>是某一个应用中特有的，如果只是本科生的教务处有限制，研究生院不是这样的限制，则不能在触发器中完成</li><li>整个大学有规定所有成绩修改增幅不能超过规定，可以使用触发器，将相关数据放在对应表中</li></ol><p>本应该在应用中完成的，都在触发器中完成了。</p><ol><li>减少了网络之间的交互和数据传输，有可能性能变好了</li><li>但是如果数据库是和别人共享的<ol><li>别人使用相关表时，可能无意识的导致触发器</li><li>使用<code>before</code>操作，进行限制，会导致其他使用者插入数据（如1.1倍分数时）被拒绝，<strong>对语义有所影响</strong></li><li>相当于在数据库中加入了一个公共的业务逻辑，但是不一定被其他使用者所接受</li></ol></li></ol><h2 id="激活触发器"><a href="#激活触发器" class="headerlink" title="激活触发器"></a>激活触发器</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680162232986-a9f1c31a-484e-4f39-bf1e-6850c7763063.png" alt="image.png"></p><h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1680162259907-86aed474-2042-4c12-8d59-f0740679cbf6.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter07 - 数据库设计</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter07%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter07%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="ch37-数据库设计概述"><a href="#ch37-数据库设计概述" class="headerlink" title="ch37 数据库设计概述"></a>ch37 数据库设计概述</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686731636094-9252c6ed-aa8d-48ee-9f97-4477e91df238.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686731651743-7b9e2e8a-151d-44a3-b540-7d2d7e6b4d17.png" alt="image.png"><br>需求分析阶段：综合各个用户的应用需求<br />概念设计阶段： 形成独立于机器特点，独立于各个数据库管理系统产品的概念模式（E-R图）<br />逻辑设计阶段：</p><ol><li>首先将E-R图转换成具体的数据库产品支持的数据模型，如关系模型，形成数据库逻辑模式</li><li>然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图（View），形成数据的外模式</li></ol><p>物理设计阶段：根据数据库管理系统特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式</p><h1 id="ch38-需求分析"><a href="#ch38-需求分析" class="headerlink" title="ch38 需求分析"></a>ch38 需求分析</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>需求分析就是分析用户的要求<br />是设计数据库的起点结果<br />是否准确地反映了用户的实际要求，将直接影响到后面各个阶段的设计，并影响到设计结果是否合理和实用<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681204809736-284c58de-10f4-4e94-ab76-3686adf06970.png" alt="image.png"></p><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><ul><li>数据字典是关于数据库中数据的描述，即元数据，不是数据本身</li><li>数据字典在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善</li><li>数据字典是进行详细的数据收集和数据分析所获得的主要结果</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681204871053-0d137ff6-e91c-49c9-9e4e-73a19ed00dfc.png" alt="image.png"></p><h1 id="ch39-概念模型和ER模型"><a href="#ch39-概念模型和ER模型" class="headerlink" title="ch39 概念模型和ER模型"></a>ch39 概念模型和ER模型</h1><h2 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h2><p>在需求分析阶段所得到的应用需求应该首先抽象为信息世界的结构，然后才能更好、更准确地用某一数据库管理系统实现这些需求。<br />概念模型的主要特点是:</p><ul><li>能真实、充分地反映现实世界，包括事物和事物之间的联系，能满足用户对数据的处理要求，是现实世界的一个真实模型。</li><li>易于理解，可以用它和不熟悉计算机的用户交换意见。用户的积极参与是数据库设计成功的关键。</li><li>易于更改，当应用环境和应用要求改变时容易对概念模型修改和扩充。</li><li>易于向关系、网状、层次等各种数据模型转换。</li></ul><p>概念模型是各种数据模型的共同基础，它比数据模型更独立于机器、更抽象，从而更加稳定。描述概念模型的有力工具是E-R模型。</p><h2 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681205211759-1118953d-1e34-4092-b02b-5f1ba3de30f0.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681205232696-066b57a5-044d-4999-8fb2-280ec6d6bf61.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681205382877-aa1446bf-24be-460e-8045-58967e121c80.png" alt="image.png"></p><h2 id="ISA联系"><a href="#ISA联系" class="headerlink" title="ISA联系"></a>ISA联系</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681201419874-cd39dd3c-b199-4643-8fe9-ec99ae7f2a44.png" alt="image.png"></p><h3 id="分类属性"><a href="#分类属性" class="headerlink" title="分类属性"></a>分类属性</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681201471401-8cd3c21f-0235-41bb-81c4-cbd8820dc611.png" alt="image.png"></p><ol><li>研究生和本科生放在同一张表中–数据的排他性，会导致空间的浪费</li><li>研究生和本科生放在两张表中–进行共有的操作时，需要同时对两张表进行操作</li><li>共有信息放在学生表中，特有信息放在研究生、本科生的两张表中–进行共有操作时，可以直接对学生表进行操作。进行特有操作时，只需要操作研究生或者本科生的一张表即可。但是如果需要一个完整的研究生记录，需要通过关键字进行连接（连接操作消耗时间大）</li></ol><h3 id="不相交约束与可重叠约束"><a href="#不相交约束与可重叠约束" class="headerlink" title="不相交约束与可重叠约束"></a>不相交约束与可重叠约束</h3><p>不相交：需要使用完整性约束条件，来实现排他性<br />学生：研究生、本科生<br />是否重叠：</p><ul><li>应用上进行检测</li><li>数据上自身的要求：可以使用触发器进行检测</li></ul><p>可重叠的：<br />鸟：大鸟、小鸟、益鸟、害鸟（有可能对于南方来说是益鸟，对于北方来说是害鸟）、候鸟、留鸟<br />麻雀：可以同时存放在多张子类表中，如果放在一张表上，利用率较高<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681201686335-33cc0e89-4ef2-4b96-a37a-f1ef4bd3d8b4.png" alt="image.png"><br><strong>关键是时间复杂度和空间复杂度的平衡</strong></p><h3 id="完备性约束"><a href="#完备性约束" class="headerlink" title="完备性约束"></a>完备性约束</h3><p>如果是部分特化，则不能使用Union来操作研究生和本科生，因为研究生+本科生不等于学生<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681201991062-9ac13b0f-78c6-402a-ac12-aab3544412c1.png" alt="image.png"></p><h2 id="基数约束"><a href="#基数约束" class="headerlink" title="基数约束"></a>基数约束</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681202197193-033c09d6-a8a7-4640-b108-df65eafd7d6b.png" alt="image.png"><br><code>30..40</code>：</p><ul><li>最少30个学生，最多40个学生，隶属于一个班级</li><li>即：一个班级最少30个学生，最多40个学生</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681202424458-acf5605d-324c-4f5a-85bd-646b77327f81.png" alt="image.png"></p><h2 id="Part-of-联系"><a href="#Part-of-联系" class="headerlink" title="Part-of 联系"></a>Part-of 联系</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681202591101-e2c7e1e7-39af-47f9-b5f7-a197777415ec.png" alt="image.png"><br>可以用随机数、foreign key（指代所依赖的实体的关键字）来区分不同的弱实体<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681202920956-c891595d-9db1-494a-a1d5-2d453348eeb4.png" alt="image.png"></p><h1 id="ch40-概念结构设计"><a href="#ch40-概念结构设计" class="headerlink" title="ch40 概念结构设计"></a>ch40 概念结构设计</h1><h2 id="概念结构设计的方法"><a href="#概念结构设计的方法" class="headerlink" title="概念结构设计的方法"></a>概念结构设计的方法</h2><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>用ER图描述数据字典<br />通过内模式、外模式、应用的概念来解耦，通过子概念来实现开发<br />缺点：不具有实际意义，难以估测系统的复杂程度<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681203694275-513c8333-c98d-4dbd-921e-cac4c455ca3d.png" alt="image.png"></p><h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681204312007-c2415420-2e56-4c2e-891c-7cf7ec9b61cc.png" alt="image.png"></p><h3 id="逐步扩张"><a href="#逐步扩张" class="headerlink" title="逐步扩张"></a>逐步扩张</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681204896550-e6aa7f45-102d-4945-ae0a-ca6787dff68d.png" alt="image.png"></p><h3 id="混合策略"><a href="#混合策略" class="headerlink" title="混合策略"></a>混合策略</h3><p>将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构。<br />常用策略</p><ul><li><strong>自顶向下地进行需求分析</strong></li><li><strong>自底向上地设计概念结构</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681205068930-8a252a58-db0c-4b84-b5d5-d285fe4b44ca.png" alt="image.png"></p><h2 id="概念结构设计的步骤"><a href="#概念结构设计的步骤" class="headerlink" title="概念结构设计的步骤"></a>概念结构设计的步骤</h2><p>自底向上设计概念结构的步骤</p><ul><li>第1步：抽象数据并设计局部视图</li><li>第2步：集成局部视图，得到全局概念结构</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686733098717-fd17e4ce-9617-4b44-adbc-9be45b402880.png" alt="image.png"></p><h2 id="实体与属性"><a href="#实体与属性" class="headerlink" title="实体与属性"></a>实体与属性</h2><p>实体与属性的划分原则</p><ul><li>为了简化E-R图的处置，现实世界的事物能作为属性对待的，尽量作为属性对待</li><li>两条准则：<ul><li><strong>作为属性，不能再具有需要描述的性质</strong>。属性必须是<strong>不可分的数据项</strong>，不能包含其他属性。</li><li><strong>属性不能与其他实体具有联系</strong>，即E-R图中所表示的联系是实体之间的联系。</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681206076340-aeb80f64-303a-44f1-a134-1af0d622fe1f.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681206541316-1d5dd792-f3cb-4c22-ac78-cd605c7f8f4b.png" alt="image.png"></p><h2 id="E-R图的集成"><a href="#E-R图的集成" class="headerlink" title="E-R图的集成"></a>E-R图的集成</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681207138626-3ea1ac33-d972-44d9-942c-3587157ced06.png" alt="image.png"><br>合并E-R图，生成初步E-R图<br />各个局部应用所面向的问题不同，各个子系统的E-R图之间必定会存在许多不一致的地方，称之为冲突。<br />子系统E-R图之间的冲突主要有三类：</p><ul><li>属性冲突</li><li>命名冲突</li><li>结构冲突</li></ul><h3 id="属性冲突"><a href="#属性冲突" class="headerlink" title="属性冲突"></a>属性冲突</h3><p>属性冲突</p><ul><li><strong>属性域冲突</strong>，即属性值的类型、取值范围或取值集合不同<ul><li>例如零件号，有的部门把它定义为整数，有的部门把它定义为字符型。</li><li>年龄，某些部门以出生日期形式表示职工的年龄，而另一些部门用整数表示职工的年龄。</li></ul></li><li><strong>属性取值单位冲突</strong><ul><li>例如，零件的重量有的以公斤为单位，有的以斤为单位，有的以克为单位。</li></ul></li></ul><h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h3><p>命名冲突</p><ul><li>同名异义，即不同意义的对象在不同的局部应用中具有相同的名字</li><li>异名同义（一义多名），即同一意义的对象在不同的局部应用中具有不同的名字。<ul><li>如对科研项目，财务科称为项目，科研处称为课题，生产管理处称为工程</li></ul></li><li>命名冲突<ul><li>可能发生在实体、联系一级上</li><li>也可能发生在属性一级上</li><li>通过讨论、协商等行政手段加以解决</li></ul></li></ul><h3 id="结构冲突"><a href="#结构冲突" class="headerlink" title="结构冲突"></a>结构冲突</h3><p>结构冲突</p><ul><li><strong>同一对象在不同应用中具有不同的抽象</strong><ul><li>例如，职工在某一局部应用中被当作实体，而在另一局部应用中则被当作属性。</li><li>解决方法：把属性变换为实体或把实体变换为属性，使同一对象具有相同的抽象。</li></ul></li><li><strong>同一实体在不同子系统的E-R图中所包含的属性个数和属性排列次序不完全相同</strong><ul><li>解决方法：使该实体的属性取各子系统的E-R图中属性的并集，再适当调整属性的次序。</li></ul></li><li><strong>实体间的联系在不同的E-R图中为不同的类型</strong><ul><li>实体E1与E2在一个E-R图中是多对多联系，在另一个E-R图中是一对多联系</li><li>解决方法：根据应用的语义对实体联系的类型进行综合或调整。</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686733237638-db05c289-01ad-4953-ac6d-af11aaf5468d.png" alt="image.png"></p><h2 id="E-R图的修改和重构"><a href="#E-R图的修改和重构" class="headerlink" title="E-R图的修改和重构"></a>E-R图的修改和重构</h2><p>消除不必要的冗余，设计基本E-R图<br />所谓冗余的数据是指可由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系。<br />消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686733482485-dbe6b9b3-423b-4581-91d9-19688f816646.png" alt="image.png"></p><h1 id="ch42-逻辑结构设计"><a href="#ch42-逻辑结构设计" class="headerlink" title="ch42 逻辑结构设计"></a>ch42 逻辑结构设计</h1><p>把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构<br />转换内容</p><ul><li>E-R图由实体型、实体的属性和实体型之间的联系三个要素组成</li><li>关系模型的逻辑结构是一组关系模式的集合</li><li>将E-R图转换为关系模型：将实体型、实体的属性和实体型之间的联系转化为关系模式</li></ul><p>一个实体型转换为一个关系模式。<br />关系的属性：实体的属性<br />关系的码：实体的码</p><h2 id="关系数据模型的优化"><a href="#关系数据模型的优化" class="headerlink" title="关系数据模型的优化"></a>关系数据模型的优化</h2><p>确定数据依赖</p><ul><li>按需求分析阶段所得到的语义，分别写出每个关系模式内部各属性之间的数据依赖以及不同关系模式属性之间数据依赖。</li></ul><p>对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。<br />按照数据依赖的理论对关系模式进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。<br />按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。<br /><strong>并不是规范化程度越高的关系就越优</strong></p><ul><li>当查询经常涉及两个或多个关系模式的属性时，系统必须经常地进行连接运算</li><li><strong>连接运算的代价是相当高的</strong></li><li>因此在这种情况下，第二范式甚至第一范式也许是适合的。</li><li>非BCNF的关系模式虽然会存在不同程度的更新异常，但如果在实际应用中对此关系模式只是查询，并不执行更新操作，就不会产生实际影响。</li><li>对于一个具体应用来说，到底规范化进行到什么程度，<strong>需要权衡响应时间和潜在问题</strong>两者的利弊才能决定</li></ul><h2 id="关系模式的分解"><a href="#关系模式的分解" class="headerlink" title="关系模式的分解"></a>关系模式的分解</h2><p>对关系模式进行必要分解，提高数据操作效率和存储空间的利用率。<br />常用分解方法</p><ul><li>水平分解</li><li>垂直分解</li></ul><h3 id="水平分解"><a href="#水平分解" class="headerlink" title="水平分解"></a>水平分解</h3><p>把(基本)关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统的效率。<br />如何分解</p><ul><li>对符合“80&#x2F;20原则”的，把经常被使用的数据（约20%）水平分解出来，形成一个子关系。</li><li>水平分解为若干子关系，使每个事务存取的数据对应一个子关系。</li></ul><h3 id="垂直分解"><a href="#垂直分解" class="headerlink" title="垂直分解"></a>垂直分解</h3><p>把关系模式R的属性分解为若干子集合，形成若干子关系模式。<br />垂直分解的原则：经常在一起使用的属性从R中分解出来形成一个子关系模式<br />垂直分解的优点</p><ul><li><strong>可以提高某些事务的效率</strong></li></ul><p>垂直分解的缺点</p><ul><li><strong>可能使另一些事务不得不执行连接操作，降低了效率</strong></li></ul><p>垂直分解的适用范围</p><ul><li>取决于分解后R上的所有事务的总效率是否得到了提高</li></ul><p>进行垂直分解的方法</p><ul><li>简单情况：直观分解</li><li>复杂情况：用模式分解算法垂直分解必须不损失关系模式的语义（保持无损连接性和保持函数依赖）</li></ul><h2 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h2><p>定义数据库模式主要是从系统的时间效率、空间效率、易维护等角度出发。<br />定义用户外模式时应该更注重考虑用户的习惯与方便。包括三个方面：</p><ul><li><strong>使用更符合用户习惯的别名</strong></li></ul><p>合并各分E-R图曾做了消除命名冲突的工作，以使数据库系统中同一关系和属性具有唯一的名字。这在设计数据库整体结构时是非常必要的。<br />用视图机制可以在设计用户视图时可以重新定义某些属性名，使其与用户习惯一致，以方便使用。</p><ul><li><strong>针对不同级别的用户定义不同的视图，以保证系统的安全性</strong></li></ul><p>假设有关系模式产品（产品号，产品名，规格，单价，生产车间，生产负责人，产品成本，产品合格率，质量等级），可以在产品关系上建立两个视图：<br />为一般顾客建立视图：产品1（产品号，产品名，规格，单价）<br />为产品销售部门建立视图：产品2（产品号，产品名，规格，单价，车间，生产负责人）</p><ul><li><strong>简化用户对系统的使用</strong></li></ul><p>如果某些局部应用中经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图</p><h1 id="ch43-物理结构设计"><a href="#ch43-物理结构设计" class="headerlink" title="ch43 物理结构设计"></a>ch43 物理结构设计</h1><h2 id="数据库的物理设计"><a href="#数据库的物理设计" class="headerlink" title="数据库的物理设计"></a>数据库的物理设计</h2><p>数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。<br />为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。<br />数据库物理设计的步骤</p><ol><li>确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构; </li><li>对物理结构进行评价，评价的重点是时间和空间效率 </li><li>若评价结果满足原设计要求，则可进入到物理实施阶段。</li><li>否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型。</li></ol><h2 id="关系模式存取方法选择"><a href="#关系模式存取方法选择" class="headerlink" title="关系模式存取方法选择"></a>关系模式存取方法选择</h2><p>数据库系统是多用户共享的系统，对同一个关系要建立多条存取路径才能满足多用户的多种应用要求。<br />物理结构设计的任务之一是根据关系数据库管理系统支持的存取方法确定选择哪些存取方法。<br />数据库管理系统常用存取方法</p><ul><li>B+树索引存取方法</li><li>Hash索引存取方法</li><li>聚簇存取方法<blockquote><p><strong>数据库索引是存储引擎用于快速找到记录的一种数据结构</strong>。 《高性能MySQL》</p></blockquote></li></ul><p>索引可以根据一定的规则和算法，把数据的关键字或者范围映射到一个特定的数据结构中，比如B+树或者哈希表。这样，<strong>当我们需要查找数据时，就不需要遍历整个数据库表，而是可以根据索引的规则和算法，快速地定位到数据所在的位置。</strong></p><h3 id="B-树索引存取方法"><a href="#B-树索引存取方法" class="headerlink" title="B+树索引存取方法"></a>B+树索引存取方法</h3><p>选择索引存取方法的主要内容：根据应用要求确定</p><ul><li>对哪些属性列建立索引</li><li>对哪些属性列建立组合索引</li><li>对哪些索引要设计为唯一索引</li></ul><p>选择索引存取方法的一般规则</p><ul><li>如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）</li><li>如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引</li><li>如果一个（或一组）属性经常在连接操作的连接条件中出现，则考虑在这个（或这组）属性上建立索引</li></ul><p>关系上定义的索引数过多会带来较多的额外开销（维护、查找索引的开销)<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686741310969-482d83c8-a1ae-4004-9612-236824ea2102.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686741292283-7e939afe-d715-4b0c-964e-903194da790f.webp"><br><strong>为什么官方建议使用自增长主键作为索引。</strong><br /><strong>结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。</strong><br />插入连续的数据：<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686741336911-b1fa99eb-dbca-450a-b4c0-69525ff4077f.gif"><br>插入非连续的数据<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686741326227-3b4b18b3-b831-4ad5-b0a6-7d787379aec7.gif"></p><h3 id="HASH存取方法的选择"><a href="#HASH存取方法的选择" class="headerlink" title="HASH存取方法的选择"></a>HASH存取方法的选择</h3><p>选择Hash存取方法的规则<br />如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一</p><ul><li>该关系的大小可预知，而且不变； </li><li>该关系的大小动态改变，但所选用的数据库管理系统提供了动态Hash存取方法。</li></ul><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686741161207-9519f37c-e93f-4984-b2b2-fb18d13ddc3a.png"><br>哈希索引优点</p><ol><li><strong>快速查询：参与索引的字段只要进行Hash运算之后就可以快速定位到该记录，时间复杂度约为1</strong></li></ol><p>哈希索引缺点</p><ol><li>哈希索引只包含哈希值和行指针，所以不能用索引中的值来避免读取行</li><li>哈希索引数据<strong>并不是按照索引值顺序存储的，所以也就无法用于排序和范围查询</strong></li><li>哈希索引<strong>也不支持部分索引列查询，因为哈希索引始终是使用索引列的全部数据进行哈希计算的</strong>。</li><li>哈希索引只支持等值比较查询，如&#x3D;，IN()，&lt;&#x3D;&gt;操作</li><li><strong>如果哈希冲突较多，一些索引的维护操作的代价也会更高</strong></li></ol><h3 id="聚簇"><a href="#聚簇" class="headerlink" title="聚簇"></a>聚簇</h3><p><a href="https://blog.csdn.net/zhizhengguan/article/details/120834883">mysql 聚簇索引</a><br><strong>为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中称为聚簇。</strong><br />该属性（或属性组）称为聚簇码（cluster key）<br /><strong>聚簇的用途：大大提高按聚簇属性进行查询的效率</strong><br />[例] 假设学生关系按所在系建有索引，现在要查询信息系的所有学生名单。</p><ul><li>计算机系的500名学生分布在500个不同的物理块上时，至少要执行500次I&#x2F;O操作。</li><li>如果将同一系的学生元组集中存放，则每读一个物理块可得到多个满足查询条件的元组，从而显著地减少了访问磁盘的次数。</li></ul><h3 id="聚簇存取方法的选择"><a href="#聚簇存取方法的选择" class="headerlink" title="聚簇存取方法的选择"></a>聚簇存取方法的选择</h3><p>聚簇<br /><strong>聚簇索引的叶子节点就是数据节点，也就是说索引和数据行在一起；反之，如果叶子节点没有存储数据行，那么就是非聚簇索引。</strong><br />既适用于单个关系独立聚簇<br />也适用于经常进行连接操作的多个关系</p><ul><li><strong>把多个连接的元组按连接属性值聚集存放</strong></li><li><strong>从而实现多个关系的“预连接”，提高连接操作的效率。</strong></li></ul><p>选择聚簇存储方法，即确定需要建立多少个聚簇，每个聚簇中包含哪些关系</p><ul><li><strong>一个数据库可以建立多个聚簇，一个关系只能加入一个聚簇</strong>。<blockquote><p>我们知道聚簇索引中包含了数据行，那么如果有多个聚簇索引，就说明存储了多份相同的数据行，岂不浪费空间？</p></blockquote></li></ul><p>设计候选聚簇</p><ul><li>常在一起进行连接操作的关系可以建立组合聚簇</li><li>如果一个关系的一组属性经常出现在相等比较条件中，则该单个关系可建立聚簇；</li><li>如果一个关系的一个（或一组）属性上的值重复率很高，则此单个关系可建立聚簇。</li></ul><p>检查候选聚簇中的关系，取消其中不必要的关系</p><ul><li>从聚簇中删除经常进行全表扫描的关系</li><li>从聚簇中删除更新操作远多于连接操作的关系</li><li>从聚簇中删除重复出现的关系</li><li>当一个关系同时加入多个聚簇时，必须从这多个聚簇方案（包括不建立聚簇）中选择一个较优的，即在这个聚簇上运行各种事务的总代价最小。</li></ul><p>聚簇的局限性 </p><ul><li>聚簇只能提高某些特定应用的性能</li><li>建立与维护聚簇的开销相当大<ul><li><p><strong>对已有关系建立聚簇，将导致关系中元组的物理存储位置移动，并使此关系上原有的所有索引无效，必须重建。</strong></p><blockquote><p>如果我们在Cars表上创建一个聚簇索引在Id列上，那么<strong>Cars表的数据行将根据Id列的值重新排序和存储</strong>。这样就改变了数据行的物理存储位置。同时，由于数据行的位置发生了变化，<strong>Cars表上原来的非聚簇索引也将失效，因为它指向的数据行的位置不对了</strong>。因此，需要重新创建这个非聚簇索引，以便它能正确地指向数据行的新位置。</p></blockquote></li><li><p><strong>当一个元组的聚簇码改变时，该元组的存储位置也要做相应改变</strong>。</p></li></ul></li></ul><blockquote><p>假设我们有一个Cars表，它有一个聚簇索引在Id列上。Cars表的数据行是以B-tree的方式存储的，它们按照Id列的值排序。现在，如果我们修改一个数据行的Id列的值，例如把第一行的Id从1改为9，那么这个数据行将根据新的Id值重新排序和存储。这样就改变了数据行的物理存储位置。<strong>这是因为聚簇索引要求表中的数据行按照聚簇索引键值的顺序存储，如果键值发生了变化，就必须调整数据行的位置，以保持顺序。</strong></p></blockquote><ul><li>当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其他访问很少或者是次要的时，可以使用聚簇<ul><li>尤其当SQL语句中包含有与聚簇码有关的ORDER BY, GROUP BY, UNION, DISTINCT等子句或短语时，使用聚簇特别有利，可以省去或减化对结果集的排序操作</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686742070326-12040a1e-ca37-4866-bf94-ff01c562ac1c.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>B+树索引是一种将数据的键值按照一定的顺序存储在一个多层的树形结构中的存储方式，<strong>它的特点是支持范围查询和排序，也适合频繁更新的数据，但是查询速度不如哈希索引快。</strong>B+树索引可以是基于主键或非主键的，也可以是单列或多列的组合。</p></li><li><p>Hash索引是一种将数据的键值通过哈希函数映射到一个哈希表中的存储方式，<strong>它的特点是查询速度非常快，但是不支持范围查询和排序，也不适合频繁更新的数据。</strong>Hash索引通常是基于某个单列或多列的组合的，因为哈希函数需要输入一个确定的值。</p><blockquote><p>Hash索引找到了索引并不一定就找到了数据，因为<strong>Hash索引的哈希表中存储的是数据的键值和指向数据的指针，而不是数据本身。</strong><br>如果查询的列就是Hash索引的列，那么可以直接返回键值，不需要再访问数据。<br>但是如果查询的列不是Hash索引的列，那么还需要根据指针去访问数据，这就需要回表查询。<br>例如，一个用户表，如果以用户名作为Hash索引，那么当查询用户名时，可以直接返回键值，不需要回表查询。但是如果查询用户的其他信息，比如年龄、性别等，那么还需要根据指针去访问数据，这就需要回表查询。</p></blockquote></li><li><p>聚簇索引是一种将数据和索引放在一起的存储方式，它的特点是<strong>数据的物理存放顺序和索引的顺序是一致的，找到索引就找到了数据</strong>。聚簇索引通常是基于主键的，因为主键是唯一且不变的，适合作为聚簇索引</p></li><li><p>聚簇索引是可以使用B+树索引的，但不能使用Hash索引的。因为Hash索引的特点是将数据的键值通过哈希函数映射到一个哈希表中，而哈希表中的数据是无序的，不能保证数据的物理存放顺序和索引顺序一致。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter06 - 关系数据理论</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter06%20-%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter06%20-%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="ch32-关系模式及范式"><a href="#ch32-关系模式及范式" class="headerlink" title="ch32 关系模式及范式"></a>ch32 关系模式及范式</h1><p>U和D：不同属性可以拥有相同的域<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681367886563-8d651c22-5f6b-43aa-88e6-7f6a98ddb84d.png" alt="image.png"></p><h2 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h2><p>数据依赖</p><ul><li>是一个关系内部属性与属性之间的一种约束关系<ul><li>通过属性间值的相等与否体现出来的数据间相关联系是现实世界属性间相互联系的抽象</li><li>是数据内在的性质</li><li>是语义的体现</li></ul></li><li>数据依赖的主要类型<ul><li>函数依赖（Functional Dependency，简记为FD)</li><li>多值依赖（Multi-Valued Dependency，简记为MVD)</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1682507677102-7f4ba1b8-3991-45da-ab8d-4f718932cea3.png" alt="image.png"></p><h2 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h2><p>但凡是关系，就是1NF<br /><code>F=&#123;Sno-→Sdept, Sdept→Mname, (Sno, Cno)→Grade&#125;</code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681368679429-8ea610e1-188d-437f-869b-0a039ed294fb.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1682507773791-e76cb493-6023-4c4e-918a-a0c227f7775c.png" alt="image.png"><br>关系模式Student&lt;U, F&gt;中存在的问题:</p><ul><li><strong>数据冗余：不仅浪费空间，也需要统一的完成修改</strong><ul><li>浪费大量的存储空间：每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同。</li></ul></li><li><strong>更新异常(Update Anomalies)</strong><ul><li>数据冗余，更新数据时，维护数据<strong>完整性</strong>代价大，否则会面临<strong>数据不一致</strong>的情况。</li><li>某系更换系主任后，必须修改与该系学生有关的每一个元组。如果有元组没有修改，则会出错-完整性约束条件出错</li></ul></li><li><strong>插入异常（Insertion Anomalies)</strong><ul><li>如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。</li></ul></li><li><strong>删除异常（Deletion Anomalies)</strong><ul><li>如果某个系的学生全部毕业了，则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。</li></ul></li><li>结论：Student关系模式不是一个好的模式。</li><li>一个“好”的模式应当<strong>不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。</strong></li><li>原因：由存在于模式中的某些数据依赖引起的。</li><li>解决方法：用规范化理论改造关系模式来消除其中不合适的数据依赖</li><li>把这个单一的模式分成三个关系模式;</li></ul><p>s(Sno,Sdept,Sno → Sdept);<br />sc(Sno,Cno,Grade,(Sno,Cno)→Grade);<br />DEPT(Sdept,Mname,SdeptMname);<br />这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制。</p><ul><li>规范化以后的结果：<ul><li>应该是节约空间的，去除数据的冗余</li><li>浪费了查询的时间，拥有了更多的表，如果涉及到多张表，需要进行连接操作来进行查询</li></ul></li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681369969827-3ea578ed-ecb9-4ba4-9911-339893fe167d.png" alt="image.png"><br>越往右：越严格，表的划分越细致<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681369983564-940dfc7f-b3bb-4710-9323-9832f90a4533.png" alt="image.png"></p><h1 id="ch33-函数依赖与码"><a href="#ch33-函数依赖与码" class="headerlink" title="ch33 函数依赖与码"></a>ch33 函数依赖与码</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>定义6.1：设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y，X称为这个函数依赖的决定因素（Determinant）。</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1682508193585-a6236d5f-1736-4afc-b855-5ab8cb36537d.png" alt="image.png"></p><ul><li>函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是<strong>指R的所有关系实例均要满足的约束条件。</strong></li><li>函数依赖<strong>是语义范畴的概念</strong>。只能根据数据的语义来确定函数依赖。<ul><li>例如“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立</li></ul></li><li>数据库设计者<strong>可以对现实世界作强制的规定</strong>。<ul><li>例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在，则拒绝插入该元组。</li></ul></li></ul><h3 id="平凡函数依赖与非平凡函数依赖"><a href="#平凡函数依赖与非平凡函数依赖" class="headerlink" title="平凡函数依赖与非平凡函数依赖"></a>平凡函数依赖与非平凡函数依赖</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1682508369861-50a4e71b-5aee-4f08-a4b3-ccaa4d63e130.png" alt="image.png"></p><blockquote><p>举例来说，如果有一个关系模式R(学号，姓名，性别)，那么学号对姓名和性别有非平凡函数依赖，因为学号可以唯一确定姓名和性别，而姓名和性别不是学号的子集。但是学号对学号有平凡函数依赖，因为学号可以由自身确定。同样，姓名对姓名和性别有平凡函数依赖，因为姓名是姓名和性别的子集。</p></blockquote><h3 id="完全函数依赖与部分函数依赖"><a href="#完全函数依赖与部分函数依赖" class="headerlink" title="完全函数依赖与部分函数依赖"></a>完全函数依赖与部分函数依赖</h3><p>完全函数：X不可以拿出部分属性，可以增加部分属性变为部分函数依赖。也就是说，<strong>X的所有属性一起才能决定Y，去掉任何一个属性都不行</strong><br />部分函数：X可以拿出部分属性。也就是说，<strong>X中的部分属性就可以决定Y，用不着全部</strong><br />F：完全依赖，P：部分依赖<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681370921815-f346c388-fd57-45d2-a3cc-8f42c8678199.png" alt="image.png"></p><blockquote><p>举例来说，如果有一个关系模式R(学号，姓名，课程号，成绩)，那么：</p><ul><li>学号和课程号对姓名和成绩有非平凡函数依赖，因为学号和课程号可以唯一确定姓名和成绩，而姓名和成绩不是学号和课程号的子集。</li><li>学号和课程号对姓名有部分函数依赖，因为学号可以单独决定姓名，而不需要课程号。</li><li>学号和课程号对成绩有完全函数依赖，因为学号或课程号单独都不能决定成绩，而只有两者一起才能决定成绩</li></ul></blockquote><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><p>一一对应：信息量上可以看做是冗余的<br />传递性：从业务逻辑上判断，是由需求决定的依赖关系（直接依赖），还是由推导得出来的依赖关系（传递依赖）。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681371040425-a7b37edc-9508-4afa-b29d-fba2f9dd2382.png" alt="image.png"></p><blockquote><p>如果我知道了一个学生的学号Sno，那我就能知道他所在的系Sdept。(因为理论上一个学生只属于一个系)<br>如果我知道了某一个系Sdept，那么我就能知道这个系的系主任的姓名Mname。(一个系只有一个正的系主任。)<br>也就是说，我知道了一个学生的学号Sno，其实我就知道了他所在系的系主任的姓名Mname。但这个过程中，他们是<strong>不存在直接函数依赖</strong>的，我需要<strong>通过系名称Sdept作为一个桥梁去把二者联系起来的。</strong></p></blockquote><h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><p>在这里，是通过函数依赖的概率来定义码</p><ul><li>如果U<strong>完全依赖</strong>于K，则称K为R的候选码</li><li>如果U<strong>部分依赖</strong>于K，则称K为R的超码</li><li>候选码是最小的超码</li><li>如果候选码多于一个，则选定其中的一个为<strong>主码</strong></li><li>候选码的超集是超码，候选码的真子集一定不是超码</li><li>包含在候选码中的<strong>属性</strong>称为<strong>主属性</strong>(prime attribute)：<strong>主属性是候选码的并集</strong></li><li>不包含在任何候选码中的属性称为<strong>非主属性</strong>(nonprime attribute）或<strong>非码属性</strong>(non-key attribute)（非主属性-&gt;非码属性：不在任何一个候选码中出现过的属性）</li><li>最简单的情况,单个属性是码；最极端的情况，整个属性组是码，称为全码（all-key)。<blockquote><p>在后面的章节中<strong>主码或候选码都简称为码</strong>。读者可以根据上下文加以识别。</p></blockquote></li></ul><p>记录数据时，可以记录完备的数据，也可以记录部分数据</p><ul><li>应用需不需要使用这些数据（要什么记录什么）</li></ul><p>主属性与非主属性：</p><blockquote><p>你之所以为你，是有你的个性和你的共性（挑选个性来区分独特的你 – 候选码挑选为主码的过程）<br>骨架和皮肉（非主属性越多–越具备详细分析的潜在价值，画像越具体）的关系<br>只有骨架：全码</p></blockquote><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1682509588786-681c4eb5-290a-4361-a895-a6fde7a92cac.png" alt="image.png"></p><h3 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h3><p>定义6.5 关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码,则称X是R的外部码（foreign key)，也称外码。<br />如在SC (Sno,Cno, Grade）中，Sno不是码，但Sno是关系模式S (Sno, Sdept, Sage)的码,则 Sno是关系模式SC的外码。<br /><strong>主码与外码提供了一个表示关系间联系的手段</strong>，如例6.2中关系模式S与SC的联系就是通过Sno来体现的。</p><h1 id="ch34-1NF-2NF-3NF"><a href="#ch34-1NF-2NF-3NF" class="headerlink" title="ch34* 1NF 2NF 3NF"></a>ch34* 1NF 2NF 3NF</h1><h2 id="范式-1"><a href="#范式-1" class="headerlink" title="范式"></a>范式</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1682509738017-3118b023-95e3-47c1-8b3e-296fbb6e6e42.png" alt="image.png"></p><h2 id="1NF-1"><a href="#1NF-1" class="headerlink" title="1NF"></a>1NF</h2><p>定义：<strong>关系中每一分量不可再分。即不能以集合、序列等作为属性。</strong>（也就是不能表中套表，要保证数据的原子性。）</p><ul><li>如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。</li><li>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。</li><li>但是满足第一范式的关系模式并不一定是一个好的关系模式。</li></ul><p>举例<br />学生编号课程编号</p><table><thead><tr><th><strong>学生编号</strong></th><th><strong>课程编号</strong></th></tr></thead><tbody><tr><td>S01</td><td>{C1，C2，C3}</td></tr><tr><td>S02</td><td>{C1，C4}</td></tr></tbody></table><p>它就不满足1NF，因为{C1，C2，C3}和{C1，C4}是集合。<br />修改为符合1NF：<br />学生编号课程编号</p><table><thead><tr><th><strong>学生编号</strong></th><th><strong>课程编号</strong></th></tr></thead><tbody><tr><td>S01</td><td>C1</td></tr><tr><td>S01</td><td>C2</td></tr><tr><td>S01</td><td>C3</td></tr><tr><td>S02</td><td>C1</td></tr><tr><td>S02</td><td>C4</td></tr></tbody></table><h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681372099475-e0443512-2e48-4ce9-8867-0abe821c909d.png" alt="image.png"><br>虚线：部分函数依赖<br />一个关系模式R不属于2NF，就会产生以下几个问题:</p><ol><li><strong>插入异常</strong>。假若要插入一个学生Sno&#x3D;S7，Sdept&#x3D;PHY，Sloc&#x3D;BLD2，但该生还未选课，即这个学生无Cno，这样的元组就插不进S-L-C中。因为<strong>插入元组时必须给定码值,而这时码值的一部分为空，因而学生的固有信息无法插入。</strong></li><li><strong>删除异常</strong>。假定某个学生只选一门课，如S4就选了一门课C3，现在C3这门课他也不选了，那么C3这个数据项就要删除。而C3是主属性，删除了C3，整个元组就必须一起删除，使得S4 的其他信息也被删除了，从而造成删除异常，即<strong>不应删除的信息也删除了。</strong></li><li><strong>修改复杂</strong>。某个学生从数学系（MA）转到计算机科学系（CS)，这本来只需修改此学生元组中的Sdept分量即可，但因为关系模式S-L-C中还含有系的住处Sloc属性，学生转系将同时改变住处，因而还必须修改元组中的Sloc分量。另外，如果这个学生选修了k门课，Sdept、Sloc<strong>重复存储了k次，不仅存储冗余度大，而且必须无遗漏地修改k个元组中全部Sdept、Sloc信息，造成修改的复杂化。</strong></li></ol><h3 id="旧问题解决"><a href="#旧问题解决" class="headerlink" title="旧问题解决"></a>旧问题解决</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681372205228-cb5f3265-7b4d-4f4a-85b5-190c2c92975e.png" alt="image.png"></p><ol><li>插入异常：学生选课和学生基本信息分别在两个表中，所以即使没有选课的学生也可以加入SL。</li><li>删除异常：删除一个学生的选课记录只影响SC,对SL没有影响，大四老哥（没有选课记录了）不用退学了，好耶！</li><li>数据冗余度大：选课跟基本信息不在一张表里，重复的都是必要数据，大大降低了数据冗余。修改复杂：数据都不怎么冗余了，修改操作自然也随之减少</li></ol><h3 id="新问题出现"><a href="#新问题出现" class="headerlink" title="新问题出现"></a>新问题出现</h3><p>SL中仍存在着对于我们简化关系结构有障碍的关系，即Sloc对于Sdept的函数依赖，这个关系我们是不想要的，他看上去很多余，明明已经可以通过Sno确定Sloc，可是Sloc偏偏还和Sdept有不得不说的关系，这个关系也导致SL存在一些问题。</p><ol><li>插入异常：一个系刚刚成立，还没有学生，那么码Sno就没有数据，这个系就没了，系长哭泣。</li><li>删除异常：某系决定暂停招生一段时间，把最后一批学生送走时候，删除学生数据，Sno又空了，这个系又没了，系长又哭了。</li><li>数据冗余大：一个系的所有学生都住在一起，可是Sloc这个属性却每个学生重复一次。</li><li>修改复杂：同上，Sloc重复的多，如果该系调整住址位置，修改的也多</li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>定义：在1NF基础上，消除非主属性对键的部分依赖，则称它符合2NF。<br />根据上面对部分依赖的分析，对于Student表：</p><table><thead><tr><th><strong>学生编号</strong></th><th><strong>学生姓名</strong></th><th><strong>班级编号</strong></th><th><strong>院系</strong></th><th><strong>课程编号</strong></th><th><strong>成绩</strong></th></tr></thead><tbody><tr><td>S01</td><td>杨明</td><td>D01</td><td>思齐</td><td>C01</td><td>90</td></tr><tr><td>S02</td><td>李婉</td><td>D01</td><td>思齐</td><td>C01</td><td>87</td></tr><tr><td>S01</td><td>杨明</td><td>D01</td><td>思齐</td><td>C02</td><td>92</td></tr><tr><td>S03</td><td>刘海</td><td>D02</td><td>述圣</td><td>C01</td><td>95</td></tr><tr><td>S04</td><td>安然</td><td>D02</td><td>述圣</td><td>C02</td><td>78</td></tr><tr><td>S05</td><td>乐天</td><td>D03</td><td>省身</td><td>C01</td><td>82</td></tr></tbody></table><p>对于学生姓名、学生所属的班级编号、院系，这三个属性可以直接通过学生编号来确定，在这里课程编号#显得很多余。也就是，学生姓名、班级编号、院系对（学生编号#、课程编号#）<strong>部分函数依赖</strong>。把Student表进行拆分，可以消除部分依赖。<br />其中，学生表Student如下：</p><table><thead><tr><th><strong>学生编号</strong></th><th><strong>学生姓名</strong></th><th><strong>班级编号</strong></th><th><strong>院系</strong></th></tr></thead><tbody><tr><td>S01</td><td>杨明</td><td>D01</td><td>思齐</td></tr><tr><td>S02</td><td>李婉</td><td>D01</td><td>思齐</td></tr><tr><td>S01</td><td>杨明</td><td>D01</td><td>思齐</td></tr><tr><td>S03</td><td>刘海</td><td>D02</td><td>述圣</td></tr><tr><td>S04</td><td>安然</td><td>D02</td><td>述圣</td></tr><tr><td>S05</td><td>乐天</td><td>D03</td><td>省身</td></tr></tbody></table><p>学生-课程表如下：</p><table><thead><tr><th><strong>学生编号</strong></th><th><strong>课程编号</strong></th><th><strong>成绩</strong></th></tr></thead><tbody><tr><td>S01</td><td>C01</td><td>90</td></tr><tr><td>S02</td><td>C01</td><td>87</td></tr><tr><td>S01</td><td>C02</td><td>92</td></tr><tr><td>S03</td><td>C01</td><td>95</td></tr><tr><td>S04</td><td>C02</td><td>78</td></tr><tr><td>S05</td><td>C01</td><td>82</td></tr></tbody></table><h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>定义：在2NF基础上，消除非主属性对键的传递依赖，则称它符合3NF。</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1682510881657-eee206c4-40ed-457c-9e82-06c01eaf42c1.png" alt="image.png"><br>第二个不分解为<code>Sno,Sloc</code>的原因</p><ol><li>保持函数依赖性</li><li>减少数据冗余：这样会出现不同的学号对应相同的sloc</li></ol><h3 id="旧问题解决-1"><a href="#旧问题解决-1" class="headerlink" title="旧问题解决"></a>旧问题解决</h3><p>把Sno和Sloc的直接关系断掉，Sno依然可以通过先找到对应的Sdept，然后再通过Sdept找到Sloc，效果没变，但是减少了无用的关系。<br />将新的表命名为SD和DL。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1682511377653-b7108c52-5dbc-4dc4-9773-af5d5a1de6db.png" alt="image.png"><br>这样我们就把SL这个2NF分解成了两个3NF，一定程度上解决了之前提到的问题：</p><ol><li>插入异常：新建立的系可以直接放入DL中，与学生无关。</li><li>删除异常：学生数据在SD中，删除不会影响到DL中的内容。</li><li>数据冗余大：DL中的Sdept和SLoc的内容只会存储一次。</li><li>修改复杂：同上，Sloc无重复，如果该系调整住址位置，修改只需要修改一条内容即可。</li></ol><h3 id="新问题产生"><a href="#新问题产生" class="headerlink" title="新问题产生"></a>新问题产生</h3><p>过度拆分为3NF，可能会有以下缺点：</p><ul><li>查询效率降低：由于数据表被拆分为多个，查询时可能需要进行多表连接，这会增加查询的时间和复杂度。</li><li>数据完整性难以保证：由于数据表被拆分为多个，更新时可能需要修改多个表，这会增加更新的时间和复杂度，也可能导致数据不一致的风险。</li><li>数据冗余仍然存在：即使满足了3NF，数据表中仍然可能存在主属性对候选键的部分或传递函数依赖，这会造成数据冗余和异常。</li></ul><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>根据上面对传递依赖的分析，对于Student表，学生编号可以唯一确定他所在的院系，但是注意到这中间存在传递过程，即学生编号唯一确定该学生所对应的班级编号，班级编号对应唯一的院系。我们称，院系对学生编号传递函数依赖。<br />把Student表继续进行拆分，可以消除传递依赖。<br />其中，学生表Student如下：</p><table><thead><tr><th><strong>学生编号</strong></th><th><strong>学生姓名</strong></th><th><strong>班级编号</strong></th></tr></thead><tbody><tr><td>S01</td><td>杨明</td><td>D01</td></tr><tr><td>S02</td><td>李婉</td><td>D01</td></tr><tr><td>S01</td><td>杨明</td><td>D01</td></tr><tr><td>S03</td><td>刘海</td><td>D02</td></tr><tr><td>S04</td><td>安然</td><td>D02</td></tr><tr><td>S05</td><td>乐天</td><td>D03</td></tr></tbody></table><p>班级-院系表如下：</p><table><thead><tr><th><strong>班级编号</strong></th><th><strong>院系</strong></th></tr></thead><tbody><tr><td>D01</td><td>思齐</td></tr><tr><td>D02</td><td>述圣</td></tr><tr><td>D03</td><td>省身</td></tr></tbody></table><p>符合3NF。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1NF，2NF和3NF都是关系数据库设计中的范式，用来规范数据表的结构，避免数据冗余和异常。简单来说，它们的区别如下：</p><ul><li>1NF要求数据表中的每一列都是不可拆分的最小单元，也就是确保每一列的原子性。</li><li>2NF要求在1NF的基础上，<strong>消除非主属性对候选键的部分函数依赖</strong>，也就是确保每一列都完全依赖于候选键。</li><li>3NF要求在2NF的基础上，<strong>消除非主属性对候选键的传递函数依赖</strong>，也就是确保每一列只直接依赖于候选键。</li></ul><h1 id="ch35-BCNF"><a href="#ch35-BCNF" class="headerlink" title="ch35 BCNF"></a>ch35 BCNF</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686661263649-085f9cb8-b3f4-4352-a3ea-e2b8bbe42681.png" alt="image.png"></p><h1 id="ch36-多值依赖与4NF"><a href="#ch36-多值依赖与4NF" class="headerlink" title="ch36 多值依赖与4NF"></a>ch36 多值依赖与4NF</h1><h2 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h2><p><strong>判定方法：对于任意关系中，如果存在两个元组（就是行），记为A,B，如果他们的某一属性X的值相等，那么我们交换它们另外的属性Y的值后，得到的新的两个元组，在表中是可以在原来的表中找到与它们相匹配的元组的。</strong><br />一对多：和函数（多对一）不同</p><ul><li>用表和表之间的连接，建立多对一的关系</li><li>通过组合的方式，枚举一对一的关系</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681808185312-c63cbc12-3063-4a94-bf0b-0e84a4dfd322.png" alt="image.png"><br>对于C的每一个值，T有一组值与之对应，而不论B取何值。因此T多值依赖于C，即C→→T。</p><ul><li>数据冗余度大：有多少名任课教师，参考书就要存储多少次。</li><li>增加操作复杂：当某一课程增加一名任课教师时，该课程有多少本参照书，就必须插入多少个元组。</li><li>删除操作复杂：某一门课要去掉一本参考书，该课程有多少名教师，就必须删除多少个元组。修改操作复杂：某一门课要修改一本参考书，该课程有多少名教师，就必须修改多少个元组。</li><li>产生原因:存在多值依赖</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681810189736-546ad876-7d4d-48c1-b642-834286e48b3d.png" alt="image.png"></p><h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681810882550-01d1c07c-1fbd-4ad7-9927-4809813ca023.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1681810902423-de122dca-2e08-4356-8ee3-c187de667bcf.png" alt="image.png"></p><h2 id="多值依赖与函数依赖的区别"><a href="#多值依赖与函数依赖的区别" class="headerlink" title="多值依赖与函数依赖的区别"></a>多值依赖与函数依赖的区别</h2><blockquote><p>函数依赖：一夫一妻制下，我只能有一个老婆，所以我决定了我的老婆，反之亦然，这就是函数依赖。<br>多值依赖：我有3个女朋友，5栋房子。女朋友多值依赖于我，房子也多值依赖于我，因为他们各自的选择与另一者无关（选定房子只与我有关，与女朋友无关，另一组同样）。<br>平凡的多值依赖：未成年人不允许有女朋友，但是可以有5栋房子，即女朋友为空集，这种情况就是平凡的多值依赖。</p></blockquote><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>![E%))~VH&#96;NL$0OO2$L2DN_OX.png](<a href="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1682516595032-bfa70c66-e953-43e1-a8b5-92731853110c.png">https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1682516595032-bfa70c66-e953-43e1-a8b5-92731853110c.png</a>)</p><ol start="2"><li>这个关系不符合2NF。原因如下：</li></ol><ul><li>2NF的定义是：在一个关系模式中，如果每个非主属性都完全函数依赖于候选码，那么这个关系模式就符合2NF。</li><li>在这个例子中，假设关系模式为R(员工，部门，经理，日期，零件数)，那么候选码是(员工，日期)，因为它可以决定其他所有属性，而且它的任何真子集都不能决定其他所有属性。</li><li>在这个例子中，部门和经理这两个非主属性都不完全函数依赖于候选码(员工，日期)，而是部分函数依赖于候选码的一部分(员工)。这就违反了2NF的要求。</li><li>为了使这个关系模式符合2NF，可以将其分解为两个关系模式：这样就可以消除部门和经理的部分函数依赖。<ul><li>R1(员工，部门，经理)，其中员工是候选码</li><li>R2(员工，日期，零件数)，其中(员工，日期)是候选码</li></ul></li></ul><ol start="3"><li><br /></li></ol><ul><li>对于R1(员工，部门，经理)，它的最小函数依赖集为{员工→部门，部门→经理}，根据算法，可以构造两个关系模式：<ul><li>R11(员工，部门)，其中员工是候选码</li><li>R12(部门，经理)，其中部门是候选码</li></ul></li><li>对于R2(员工，日期，零件数)，它的最小函数依赖集为{(员工，日期)→零件数}，根据算法，可以构造一个关系模式：<ul><li>R21(员工，日期，零件数)，其中(员工，日期)是候选码</li></ul></li></ul><p>为什么R12不是（员工，经理）<br />部门→经理是一个函数依赖，所以R12是(部门，经理)。<br />如果R12是(员工，经理)，那么就没有体现出部门→经理这个函数依赖，也就<strong>没有保持函数依赖性</strong>。<br />如果R12是(员工，经理)，那么就会出现<strong>数据冗余</strong>，因为<strong>同一个部门的多个员工都会有相同的经理</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter10 - 数据库恢复技术</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter10%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter10%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="ch48-事务"><a href="#ch48-事务" class="headerlink" title="ch48 事务"></a>ch48 事务</h1><p>事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。<br />事务和程序是两个概念</p><ul><li>在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序</li><li>一个程序通常包含多个事务</li></ul><p>事务是恢复和并发控制的基本单位</p><h2 id="定义事务"><a href="#定义事务" class="headerlink" title="定义事务"></a>定义事务</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686108977614-465f25e2-1a8e-47e5-87a4-d4d0dfd55d84.png" alt="image.png"><br>COMMIT:</p><ul><li>事务正常结束</li><li><strong>提交事务的所有操作（读+更新）</strong></li><li>事务中所有对数据库的更新写回到磁盘上的物理数据库中</li></ul><p>ROLLBACK:</p><ul><li>事务异常</li><li><strong>终止事务运行的过程中发生了故障，不能继续执行</strong></li><li>系统将事务中对数据库的所有已完成的操作<strong>全部撤销</strong></li><li>事务滚回到开始时的状态</li></ul><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p><strong>事务的ACID特性</strong>：</p><ol><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持续性&#x2F;持久性（Durability）</li></ol><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>事务是数据库的逻辑工作单位事务中包括的诸操作<strong>要么都做，要么都不做all or nothing</strong></p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</p><ul><li>一致性状态：数据库中只包含成功事务提交的结果</li><li>不一致状态：<ul><li>数据库系统运行中发生故障，有些事务尚未完成就被迫中断</li><li>这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686109343186-956b8fb9-6a55-4f93-9da4-e2545aafc3c2.png" alt="image.png"></p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>隔离性</p><ul><li>一个事务的执行不能被其他事务干扰</li><li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li><li>并发执行的各个事务之间不能互相干扰</li></ul><h3 id="持续性"><a href="#持续性" class="headerlink" title="持续性"></a>持续性</h3><p>持续性也称永久性（Permanence）</p><ul><li>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li><li>接下来的其他操作或故障不应该对其执行结果有任何影响。</li></ul><h3 id="事务的特性-1"><a href="#事务的特性-1" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>保证事务ACID特性是事务处理的任务<br />破坏事务ACID特性的因素</p><ul><li>多个事务并行运行时，不同事务的操作交叉执行<ul><li>数据库管理系统必须<strong>保证多个事务的交叉运行不影响这些事务的隔离性</strong></li></ul></li><li>事务在运行过程中被强行停止<ul><li>数据库管理系统必须**保证被强行终止的事务对数据库和其他事务没有任何影响 **</li></ul></li></ul><h1 id="ch49-故障和数据库恢复"><a href="#ch49-故障和数据库恢复" class="headerlink" title="ch49 故障和数据库恢复"></a>ch49 故障和数据库恢复</h1><p>故障是不可避免的</p><ul><li>计算机硬件故障</li><li>软件的错误</li><li>操作员的失误</li><li>恶意的破坏</li></ul><p>故障的影响</p><ul><li>运行事务非正常中断，影响数据库中数据的正确性</li><li>破坏数据库，全部或部分丢失数据</li></ul><p>数据库的恢复数据库：管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能，这就是数据库的恢复管理系统对故障的对策<br />恢复子系统是数据库管理系统的一个重要组成部分<br />恢复技术是衡量系统优劣的重要指标</p><h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2><p>故障的种类：</p><ul><li>事务内部的故障</li><li>系统故障</li><li>介质故障</li><li>计算机病毒</li></ul><p>各类故障，对数据库的影响有两种可能性</p><ul><li>一是数据库本身被破坏</li><li>二是数据库没有被破坏，但数据可能不正确，这是由于<strong>事务的运行被非正常终止造成的。</strong></li></ul><h2 id="事物内部的故障"><a href="#事物内部的故障" class="headerlink" title="事物内部的故障"></a>事物内部的故障</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686109998816-3f4d32c4-4346-45a6-88d1-132aae3c2b26.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686110014397-0d230e17-7207-41a6-8a44-3f44cec88db9.png" alt="image.png"></p><h3 id="事务故障的恢复"><a href="#事务故障的恢复" class="headerlink" title="事务故障的恢复"></a>事务故障的恢复</h3><p>事务故障意味着</p><ul><li>事务没有达到预期的终点(COMMIT或者显式的ROLLBACK)</li><li>数据库可能处于不正确状态。</li></ul><p>事务故障的恢复：事务撤消（UNDO）<br />强行回滚（ROLLBACK）该事务：撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样</p><h2 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h2><p>系统故障，称为软故障，是指造成系统停止运转的任何事件（特定类型的硬件错误（如CPU故障）、操作系统故障、数据库管理系统代码错误、系统断电），使得系统要重新启动。 </p><ul><li>整个系统的正常运行突然被破坏</li><li>所有正在运行的事务都非正常终止</li><li>不破坏数据库</li><li>内存中数据库缓冲区的信息全部丢失</li></ul><h3 id="系统故障的恢复"><a href="#系统故障的恢复" class="headerlink" title="系统故障的恢复"></a>系统故障的恢复</h3><ul><li>发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。 <ul><li>恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，<strong>强行撤消（UNDO）所有未完成事务</strong></li></ul></li><li>发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失<ul><li>恢复策略：系统重新启动时，恢复程序需要<strong>重做（REDO）所有已提交的事务</strong></li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686309208696-df71fea0-a86d-436b-ad14-1d2043be6b2f.png" alt="image.png"></p><h2 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h2><p><strong>介质故障，称为硬故障，指外存故障</strong></p><ul><li>磁盘损坏</li><li>磁头碰撞</li><li>瞬时强磁场干扰</li><li>介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务</li><li>介质故障比前两类故障的<strong>可能性小得多，但破坏性大得多</strong></li></ul><h2 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h2><p>计算机病毒</p><ul><li>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序</li><li>可以繁殖和传播，造成对计算机系统包括数据库的危害</li></ul><p>计算机病毒已成为计算机系统的主要威胁，自然也是数据库系统的主要威胁<br />数据库一旦被破坏仍要用恢复技术把数据库加以恢复</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><ul><li>恢复操作的基本原理：<strong>冗余</strong><ul><li><strong>利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据</strong></li></ul></li><li>恢复的实现技术：复杂<ul><li>一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上</li></ul></li><li>恢复机制涉及的关键问题：<ul><li><strong>如何建立冗余数据</strong>（数据转储，登记日志文件）</li><li><strong>如何利用这些冗余数据实施数据库恢复</strong></li></ul></li></ul><h1 id="ch50-数据转储和日志文件"><a href="#ch50-数据转储和日志文件" class="headerlink" title="ch50 数据转储和日志文件"></a>ch50 数据转储和日志文件</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686309566911-a152eb81-1e1c-435f-a1cb-670bf57c10e5.png" alt="image.png"></p><h2 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h2><ul><li>转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程</li><li>备用的数据文本称为后备副本(backup)或后援副本</li><li>数据库遭到破坏后可以将后备副本重新装入</li><li>重装后备副本<strong>只能将数据库恢复到转储时的状态</strong></li><li><strong>要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务</strong></li></ul><p>一个事务中有一个控制流，从入口到出口的路径。<br />ta和tb的数据库状态是一样的：数据库此时是静态的，只能访问，不能增删改查<br />恢复：在运行事务后出错时，需要尽量的逼近。理论上是恢复到Tf之前的某一刻的一致性状态。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686309655248-983dddff-b871-4c77-a5a2-45acc3d4febf.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686309811986-6fae8c3a-755d-4f92-b084-fda9a04e0a30.png" alt="image.png"></p><h3 id="静态转储"><a href="#静态转储" class="headerlink" title="静态转储"></a>静态转储</h3><p>没有对数据库进行增删改的事务（all or nothing一个事务如果全是读操作，其实和不操作一样。如果讨论事务，基本有对数据库进行增删改），所以也可以理解为无运行事务<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683620615064-5b43d1f8-8fe7-4010-b22c-ca8e51d4c6f9.png" alt="image.png"><br>适用场景：应用可以有一段时间的暂停（只能查询）</p><h3 id="动态转储"><a href="#动态转储" class="headerlink" title="动态转储"></a>动态转储</h3><p>恢复过程中应用是不可用的状态。但是转储还是可以并发<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683620854256-2cf09977-4fed-4d4d-9d57-64f4cb8abbac.png" alt="image.png"></p><ul><li>不能保证备份的时间点，某个数据资源具有一致性。还没来得及执行完或者还没有来得及回滚。</li><li>当前记录是以事务为粒度，而某一个时刻可以是事务中的一个状态</li><li>没有办法等待到一个合适的时机去备份</li><li>所以，需要记录事务中的每一次增删改操作</li></ul><h3 id="海量转储与增量转储"><a href="#海量转储与增量转储" class="headerlink" title="海量转储与增量转储"></a>海量转储与增量转储</h3><p>恢复更方便：海量转储<br />备份更方便：增量转储<br />增量：需要把若干个备份累计在一块<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683621507040-97f1b855-438e-4196-b0f0-7523812db736.png" alt="image.png"></p><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>记录的是事务的更新操作（粒度更细）<br />记录查询操作：</p><ul><li>方便对权限进行管理</li><li>方便及时发现异常</li><li>更新日志会变得很大：增删改的次数（因为数据库的标准操作是按需操作）远远小于查询次数</li></ul><p>以记录为单位：对元组&#x2F;属性进行修改-逻辑层</p><ul><li><strong>日志文件(log file)是用来记录事务对数据库的更新操作的文件</strong></li><li>日志文件的格式<ul><li>以记录为单位的日志文件</li><li>以数据块为单位的日志文件</li></ul></li><li>用途<ul><li>进行<strong>事务故障恢复</strong></li><li>进行<strong>系统故障恢复</strong></li><li>协助后备副本进行<strong>介质故障恢复</strong></li></ul></li></ul><h3 id="以记录为单位的日志文件"><a href="#以记录为单位的日志文件" class="headerlink" title="以记录为单位的日志文件"></a>以记录为单位的日志文件</h3><p>以记录为单位的日志文件，<strong>日志文件</strong>中的**一个日志记录(log record)**包含</p><ul><li>各个事务的开始标记(BEGIN TRANSACTION)</li><li>各个事务的结束标记(COMMIT或ROLLBACK)</li><li>各个事务的所有更新操作</li></ul><p>以记录为单位的日志文件，<strong>每条日志记录的内容</strong></p><ul><li>事务标识（标明是哪个事务)</li><li>操作类型（插入、删除或修改)</li><li>操作对象（记录内部标识)</li><li>更新前数据的旧值（对插入操作而言，此项为空值)</li><li>更新后数据的新值（对删除操作而言,此项为空值)</li></ul><h3 id="以数据块为单位的日志文件"><a href="#以数据块为单位的日志文件" class="headerlink" title="以数据块为单位的日志文件"></a>以数据块为单位的日志文件</h3><p>以数据块为单位的日志文件，每条日志记录的内容</p><ul><li>事务标识</li><li>被更新的数据块</li></ul><h3 id="日志文件的作用"><a href="#日志文件的作用" class="headerlink" title="日志文件的作用"></a>日志文件的作用</h3><p>具体作用</p><ul><li><strong>事务故障恢复（会在中途故障）和系统故障恢复</strong>必须用日志文件。</li><li><strong>在动态转储方式中必须建立日志文件</strong>，后备副本和日志文件结合起来才能有效地恢复数据库。</li></ul><p>在静态转储方式（是一致性状态，所以可以不建立日志文件）中，也可以建立日志文件。</p><ul><li>当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态</li><li><strong>利用日志文件，把已完成的事务进行重做处理</strong></li><li><strong>对故障发生时尚未完成的事务进行撤销处理</strong></li><li>不必重新运行（可能需要大量的其他资源）那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态：根据各位的成绩算均分，进行更新。<ul><li>如果重做，需要重新+200多次。</li><li>日志文件：读200+的成绩，不会留有记录。算出均分，更新某一元组的某一属性：0-&gt;78。会有3条记录：开始，更新0变78，提交</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683622663449-2e1c87e0-f623-428f-af2f-ee5bdaa3e102.png" alt="image.png"></p><h3 id="登记日志文件"><a href="#登记日志文件" class="headerlink" title="登记日志文件"></a>登记日志文件</h3><p>为保证数据库是可恢复的，登记日志文件时必须遵循两条原则</p><ul><li><strong>登记的次序严格按并发事务执行的时间次序</strong></li><li><strong>必须先写日志文件，后写数据库</strong><ul><li>写日志文件操作：把表示这个修改的日志记录写到日志文件中</li><li>写数据库操作：把对数据的修改写到数据库中（可以根据日志文件实现该数据库操作，防止先操作数据库时，数据库崩溃，就不知到0变78是什么时候发生的）</li></ul></li></ul><p>为什么要先写日志文件</p><ul><li>写数据库和写日志文件是两个不同的操作</li><li>在这两个操作之间可能发生故障</li><li>如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了</li><li>如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性</li></ul><h1 id="ch51-恢复策略"><a href="#ch51-恢复策略" class="headerlink" title="ch51 恢复策略"></a>ch51 恢复策略</h1><p>事务故障：在业务上没有触发一个正常的终止链</p><h2 id="事务故障的恢复-1"><a href="#事务故障的恢复-1" class="headerlink" title="事务故障的恢复"></a>事务故障的恢复</h2><ul><li>事务故障：事务在运行至正常终止点前被终止</li><li>恢复方法：由恢复子系统**利用日志文件撤消(UNDO)**此事务已对数据库进行的修改</li><li>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</li></ul><h2 id="事务故障的恢复步骤"><a href="#事务故障的恢复步骤" class="headerlink" title="事务故障的恢复步骤"></a>事务故障的恢复步骤</h2><p>反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。对该事务的更新操作执行逆操作。即将日志记录中“更新前的值” 写入数据库。</p><ul><li>插入操作， “更新前的值”为空，则相当于做删除操作</li><li>删除操作，“更新后的值”为空，则相当于做插入操作</li><li>若是修改操作，则相当于用修改前值代替修改后值</li></ul><p>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。<br />如此处理下去，<strong>直至读到此事务的开始标记，事务故障恢复就完成了。</strong></p><h2 id="系统故障的恢复-1"><a href="#系统故障的恢复-1" class="headerlink" title="系统故障的恢复"></a>系统故障的恢复</h2><p>系统故障造成数据库不一致状态的原因</p><ul><li>未完成事务对数据库的更新可能已写入数据库</li><li>已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库</li></ul><p>恢复方法</p><ul><li><strong>Undo 故障发生时未完成的事务</strong></li><li><strong>Redo 已完成的事务</strong></li></ul><p>系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</p><h2 id="系统故障的恢复步骤"><a href="#系统故障的恢复步骤" class="headerlink" title="系统故障的恢复步骤"></a>系统故障的恢复步骤</h2><ol><li>正向扫描日志文件（即从头扫描日志文件）</li></ol><ul><li>重做(REDO) 队列: 在故障发生前已经提交的事务<ul><li>这些事务既有BEGIN TRANSACTION记录，也有COMMIT记录</li></ul></li><li>撤销 (UNDO)队列:故障发生时尚未完成的事务<ul><li>这些事务只有BEGIN TRANSACTION记录，无相应的COMMIT记录</li></ul></li></ul><ol start="2"><li>对撤销(UNDO)队列事务进行撤销(UNDO)处理<ol><li>反向扫描日志文件，<strong>对每个撤销事务的更新操作执行逆操作</strong></li><li>即将日志记录中“更新前的值”写入数据库</li></ol></li><li>对重做(REDO)队列事务进行重做(REDO)处理<ol><li>正向扫描日志文件，<strong>对每个重做事务重新执行登记的操作</strong></li><li>即将日志记录中“更新后的值”写入数据库</li></ol></li></ol><h2 id="介质故障的恢复"><a href="#介质故障的恢复" class="headerlink" title="介质故障的恢复"></a>介质故障的恢复</h2><ul><li>介质故障的恢复的工作<ul><li>重装数据库</li><li>重做已完成的事务</li></ul></li><li>介质故障的恢复需要数据库管理员介入</li><li>数据库管理员的工作<ul><li>重装最近转储的数据库副本和有关的各日志文件副本</li><li>执行系统提供的恢复命令</li></ul></li><li>具体的恢复操作仍由数据库管理系统完成</li></ul><h2 id="介质故障的恢复步骤"><a href="#介质故障的恢复步骤" class="headerlink" title="介质故障的恢复步骤"></a>介质故障的恢复步骤</h2><ul><li><strong>装入最新的后备数据库副本</strong>(离故障发生时刻最近的转储副本) ，<strong>使数据库恢复到最近一次转储时的一致性状态。</strong><ul><li>对于静态转储的数据库副本，装入后数据库即处于一致性状态</li><li>对于动态转储的数据库副本，还须<strong>同时装入转储时刻的日志文件副本</strong>，利用恢复系统故障的方法（即<strong>REDO+UNDO</strong>），才能将数据库恢复到一致性状态。</li></ul></li><li><strong>装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务。</strong><ul><li>首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。</li><li>然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。</li></ul></li></ul><h1 id="ch52-具有检查点的恢复技术"><a href="#ch52-具有检查点的恢复技术" class="headerlink" title="ch52 具有检查点的恢复技术"></a>ch52 具有检查点的恢复技术</h1><p>恢复的两个问题</p><ul><li><strong>搜索整个日志将耗费大量的时间</strong></li><li><strong>重做处理：重新执行，浪费了大量时间</strong></li></ul><p>具有检查点（checkpoint）的恢复技术</p><ul><li>在日志文件中增加检查点记录（checkpoint）</li><li>增加重新开始文件</li><li>恢复子系统在登录日志文件期间动态地维护日志</li></ul><h2 id="检查点技术"><a href="#检查点技术" class="headerlink" title="检查点技术"></a>检查点技术</h2><p>检查点记录的内容</p><ul><li>建立检查点时刻所有正在执行的事务清单</li><li>这些事务最近一个日志记录的地址</li></ul><p>重新开始文件的内容</p><ul><li>记录各个检查点记录在日志文件中的地址</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683625265440-b09e9893-de09-4e84-ab35-029d7abc7472.png" alt="image.png"></p><h2 id="维护日志文件的方法"><a href="#维护日志文件的方法" class="headerlink" title="维护日志文件的方法"></a>维护日志文件的方法</h2><p>动态维护日志文件的方法</p><ul><li>周期性地执行如下操作：建立检查点，保存数据库状态。</li><li>具体步骤是：<ul><li>将当前<strong>日志缓冲区</strong>中的所有日志记录写入磁盘的日志文件上</li><li>在日志文件中写入一个检查点记录</li><li><strong>将当前数据缓冲区的所有数据记录写入磁盘的数据库中</strong>（强制要求把所有数据都记录在磁盘中了。因此，只需要从该checkpoint后开始）</li><li>把检查点记录在日志文件中的地址写入一个重新开始文件</li></ul></li></ul><h2 id="建立检查点"><a href="#建立检查点" class="headerlink" title="建立检查点"></a>建立检查点</h2><p>恢复子系统可以定期或不定期地建立检查点,保存数据库状态 </p><ul><li>定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点</li><li>不定期：按照某种规则，如日志文件已写满一半建立一个检查点</li></ul><h2 id="利用检查点的恢复策略"><a href="#利用检查点的恢复策略" class="headerlink" title="利用检查点的恢复策略"></a>利用检查点的恢复策略</h2><p>使用检查点方法可以改善恢复效率</p><ul><li>当事务T在一个检查点之前提交，T对数据库所做的修改已写入数据库</li><li>写入时间是在这个检查点建立之前或在这个检查点建立之时，在进行恢复处理时，没有必要对事务T执行重做操作</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683625515068-274a9e2b-0c2b-4736-90d1-db5ba665768a.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683625847672-9b75ca09-b1fd-4fd0-bc2d-37c1fd360f52.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683625828736-bb9843d5-f99b-452c-9136-adfd3807895b.png" alt="image.png"></p><h1 id="ch53-数据库镜像"><a href="#ch53-数据库镜像" class="headerlink" title="ch53 数据库镜像"></a>ch53 数据库镜像</h1><p>介质故障是对系统影响最为严重的一种故障，严重影响数据库的可用性</p><ul><li>介质故障恢复比较费时</li><li>为预防介质故障，数据库管理员必须周期性地转储数据库</li></ul><p>提高数据库可用性的解决方案：数据库镜像（Mirror）<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683625922902-0bc2eea5-1f17-4a0b-9b2a-375b49febdfe.png" alt="image.png"></p><h2 id="出现介质故障"><a href="#出现介质故障" class="headerlink" title="出现介质故障"></a>出现介质故障</h2><ul><li>可由镜像磁盘继续提供使用</li><li>同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复</li><li>不需要关闭系统和重装数据库副本</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683626031333-260347b3-a745-41f2-833e-a0218927c3f6.png" alt="image.png"></p><h2 id="没有出现故障"><a href="#没有出现故障" class="headerlink" title="没有出现故障"></a>没有出现故障</h2><ul><li>可用于并发操作</li><li>一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683626045794-22f87b29-9bc9-401b-915d-091d181562e9.png" alt="image.png"><br>频繁地复制数据自然会降低系统运行效率</p><ul><li>在实际应用中用户往往<strong>只选择对关键数据和日志文件镜像</strong></li><li>不是对整个数据库进行镜像</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter11 - 并发控制</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter11%20-%20%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter11%20-%20%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="ch54-并发控制"><a href="#ch54-并发控制" class="headerlink" title="ch54 并发控制"></a>ch54 并发控制</h1><h2 id="事务并发"><a href="#事务并发" class="headerlink" title="事务并发"></a>事务并发</h2><p>多用户数据库系统，允许多个用户同时使用的数据库系统</p><ul><li>飞机定票数据库系统</li><li>银行数据库系统</li></ul><p>特点：在同一时刻并发运行的事务数可达数百上千个<br />事务并发执行带来的问题</p><ul><li>会产生多个事务同时存取同一数据的情况</li><li>可能会存取和存储不正确的数据，破坏<strong>事务隔离性</strong>和<strong>数据库的一致性</strong></li></ul><p>数据库管理系统必须提供并发控制机制，<strong>并发控制机制是衡量一个数据库管理系统性能的重要标志之一</strong></p><blockquote><p>隔离性：不受到其他事务的影响，独立完成自己的</p><p>一致性：数据库中只包含成功事务提交的结果</p></blockquote><h2 id="多事务执行方式"><a href="#多事务执行方式" class="headerlink" title="多事务执行方式"></a>多事务执行方式</h2><h3 id="事务串行执行"><a href="#事务串行执行" class="headerlink" title="事务串行执行"></a>事务串行执行</h3><p>事务是用来描述业务的，是业务要求all or nothing。<br />如果三个事务分别可以all or nothing，那么事件的顺序无关紧要。<br />但实际上，需要考虑三个事务的顺序不同会不会导致不同的结果。如果结果错误，实际上是对事务本身的定义错误。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683793399810-2976ce61-9f27-49d4-95ae-c4b13db73804.png" alt="image.png"><br>例子：T1阶段，对CPU和DB进行操作，分为AB甲乙阶段<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683793833670-af1ba77a-4bd3-4b07-9b31-3e9dc4d73394.png" alt="image.png"><br>A阶段没使用DB，甲乙阶段没使用CPU，B阶段没使用DB<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683794018284-3306e64f-6efc-4147-82ac-01b91d8f7a8d.png" alt="image.png"><br>不能实现错峰访问资源。<br /><strong>串行逻辑上提供了多事务执行的正确结果。为其他方式提供了正确答案</strong></p><h3 id="交叉并发方式"><a href="#交叉并发方式" class="headerlink" title="交叉并发方式"></a>交叉并发方式</h3><p>单一资源：同时只能分配给一个事务（数据资源一般认为是单一资源）<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683794176795-f8e3d8d6-5f16-4bc1-bf48-4eebe0181170.png" alt="image.png"><br>微观上没有并发，宏观上是并发的（在T1还没执行完时，T2,T3也执行了）。</p><h3 id="同时并发方式"><a href="#同时并发方式" class="headerlink" title="同时并发方式"></a>同时并发方式</h3><p>在关系型数据库中，默认对于一个数据资源的增删改只有一个入口，大多情况是交叉并发方式<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683794398398-dd8fbe1a-aa1b-494e-9747-3dbbb4063f95.png" alt="image.png"></p><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>事务是并发控制的基本单位<br />并发控制机制的任务</p><ul><li>对并发操作进行正确调度</li><li>保证事务的隔离性</li><li>保证数据库的一致性</li></ul><h3 id="不一致性例子"><a href="#不一致性例子" class="headerlink" title="不一致性例子"></a>不一致性例子</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683794736397-96f3ed2b-5219-4b50-aee3-aa9608f12003.png" alt="image.png"><br>这种情况称为数据库的不一致性，是由并发操作引起的。<br /><strong>在并发操作情况下，对T1、T2两个事务的操作序列的调度是随机的。</strong><br />若按上面的调度序列执行， T1事务的修改就被丢失。<br />原因：第4步中T2事务修改A并写回后覆盖了T1事务的修改</p><h2 id="并发操作带来的数据不一致性"><a href="#并发操作带来的数据不一致性" class="headerlink" title="并发操作带来的数据不一致性"></a>并发操作带来的数据不一致性</h2><ul><li>丢失修改（Lost Update）</li><li>不可重复读（Non-repeatable Read）</li><li>读“脏”数据（Dirty Read）</li></ul><p>记号</p><ul><li>R(x):读数据x</li><li>W(x):写数据x</li></ul><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683794921269-d8a947ed-371f-4944-aeda-64b525d03c82.png" alt="image.png"><br>丢失修改带来的副作用最大</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>事务执行期间（事务还没有结束），多次读取数据不一致。</strong>显然，如果在B事务中的两次访问数据D期间，事务A对数据D进行了修改，对于事务B而言就形成了不可重复读。<br /><strong>不可重复读是指事务T1读取数据后，事务T2执行更新操作</strong>（写入新数据，或者在某个时刻rollback，<strong>rollback是一种潜在的更新操作</strong>），<strong>使T1无法再现前一次读取结果</strong>。<br />不可重复读包括三种情况，后两种不可重复读有时也称为<strong>幻影现象（数据的突然出现或突然消失）</strong>（Phantom Row) :</p><ul><li>事务T1读取某一数据后，<strong>事务T2对其做了修改</strong>，当事务T1再次读该数据时，得到与前一次不同的值</li><li>事务T1按一定条件从数据库中读取了某些数据记录后，<strong>事务T2删除了其中部分记录</strong>，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。</li><li>事务T1按一定条件从数据库中读取某些数据记录后，<strong>事务T2插入了一些记录</strong>，当T1再次按相同条件读取数据时，发现多了一些记录。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683795482893-81795b9e-55b3-41f4-989c-f9e04c44c5ff.png" alt="image.png"></p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>B事务读取到了A事务修改过尚未提交的数据</strong><br />读“脏”数据是指：</p><ul><li>事务T1修改某一数据，并将其写回磁盘</li><li>事务T2读取同一数据后， T1由于某种原因被撤销</li><li>这时T1已修改过的数据恢复原值， T2读到的数据就与数据库中的数据不一致</li><li>T2读到的数据就为“脏”数据，即不正确的数据</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683795518500-c6411954-513c-4f91-9ec0-bbfb3b9798f8.png" alt="image.png"></p><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><ol><li>丢失修改：事务T1的提交的更新会事务T2覆盖</li><li>不可重复读：事务T1在不同时刻对同一数据进行读的结果不同（强调的<strong>是同一个事务</strong>在整个事务过程中<strong>对同一笔数据进行读取，每次读取结果都不同</strong>。）-被T2修改了&#x2F;删除了&#x2F;增加了</li><li>脏读：两个不同的事务T1，T2，T1修改了数据，T2读取了T1修改后的数据，与数据库中的数据（<strong>由于T1回滚了</strong>）不一致<blockquote><p><strong>不可重复读</strong><br>（针对其他提交前后，读取数据本身的对比）<strong>不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。</strong>如果事务1在事务2的更新操作之前读取一次数据，在事务2的更新操作之后再读取同一笔数据一次，两次结果是不同的，所以，Read Uncommitted也无法避免不可重复读取的问题。<br><strong>幻读</strong><br>（针对其他提交前后，读取数据<strong>条数</strong>的对比） <strong>幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。</strong>在Read Uncommitted隔离级别下， 不管事务2的插入操作是否提交，事务1在插入操作之前和之后执行相同的查询，取得的结果集是不同的，所以，Read Uncommitted同样无法避免幻读的问题。</p></blockquote></li></ol><h2 id="数据不一致性及并发控制"><a href="#数据不一致性及并发控制" class="headerlink" title="数据不一致性及并发控制"></a>数据不一致性及并发控制</h2><ul><li>数据不一致性：由于并发操作破坏了事务的隔离性</li><li>并发控制就是要用正确的方式调度并发操作，**使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性 **</li><li><strong>对数据库的应用有时允许某些不一致性</strong>，例如有些统计工作涉及数据量很大，读到一些“脏”数据对统计精度没什么影响，可以降低对一致性的要求以减少系统开销</li></ul><h2 id="并发控制的主要技术"><a href="#并发控制的主要技术" class="headerlink" title="并发控制的主要技术"></a>并发控制的主要技术</h2><p>并发控制的主要技术</p><ul><li>封锁(Locking)</li><li>时间戳(Timestamp)</li><li>乐观控制法</li><li>多版本并发控制(MVCC)</li></ul><h1 id="ch55-封锁"><a href="#ch55-封锁" class="headerlink" title="ch55 封锁"></a>ch55 封锁</h1><ul><li>封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁</li><li><strong>加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。</strong></li><li><strong>封锁是实现并发控制的一个非常重要的技术</strong></li><li><strong>一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。</strong></li><li>基本封锁类型<ul><li>排它锁（Exclusive Locks，简记为X锁）</li><li>共享锁（Share Locks，简记为S锁）</li></ul></li></ul><h2 id="排他锁与共享锁"><a href="#排他锁与共享锁" class="headerlink" title="排他锁与共享锁"></a>排他锁与共享锁</h2><p><strong>排他锁又称为写锁</strong>。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都<strong>不能再对A加任何类型的锁</strong>，直到T释放A上的锁为止。这就保证了其他事务<strong>在T释放A上的锁之前不能再读取和修改A</strong>。<br /><strong>共享锁又称为读锁</strong>。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务<strong>只能再对A加S锁，而不能加X锁</strong>，直到T释放A上的S锁为止。这就保证了<strong>其他事务可以读A</strong>，但<strong>在T释放A上的S锁之前不能对A做任何修改</strong>。</p><blockquote><p>【注意】</p><p>之所以看起来它们能够控制对数据的读取和修改，这需要依赖每个事务在读取和修改数据之前必须要遵守某种约定，这就是：如果要求在某些条件下，<strong>某事务需要加某种锁才能对数据进行操作</strong>，那么，所有其它事务在遇到同样情况下，也强制必须先加锁才能对数据进行操作，如果加锁加失败，则该事务需要等待。而<strong>锁之间是有排斥法则的，所以可以通过这个法则来间接实现对数据读取和修改上的限制。</strong></p><p>排他锁对应的要求条件往往是在对数据的修改之前，共享锁对应的则是读取。也就是说，如果对事务启用排他锁，往往意味着，<strong>任何事务在修改数据之前都要先加排他锁（但是并不一定代表读取数据时也要先加锁）</strong>。如果对事务启用共享锁，往往意味着<strong>任何事务在读取数据之前都要先加共享锁</strong>。不过，可以自行规定加锁时机。</p></blockquote><h3 id="相容矩阵"><a href="#相容矩阵" class="headerlink" title="相容矩阵"></a>相容矩阵</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683805800306-768ca03a-7420-45ee-b633-32099b979e8d.png" alt="image.png"></p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p>在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。 </p><ul><li>何时申请X锁或S锁</li><li>持锁时间</li><li>何时释放</li></ul><p>对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。</p><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p>一级封锁协议<br />事务T<strong>在修改数据R之前</strong>必须先对其加X锁，直到事务结束才释放。</p><ul><li>正常结束（COMMIT）</li><li>非正常结束（ROLLBACK）</li></ul><p>一级封锁协议可防止丢失修改，并保证事务T是可恢复的。<br />在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它<strong>不能保证可重复读和不读“脏”数据。</strong></p><ul><li>可以防止丢失修改：因为X锁保证了其他事务不能同时对该数据进行修改</li><li>不能保证不可重复读：<strong>因为一级封锁协议只是规定了写数据之前要加X锁，并不代表读数据之前也要加锁。</strong>所以，当T1读取数据的时候，T2事务是可以对同一数据进行修改，也就造成了不可重复读的现象。</li><li>不能保证不可读“脏”数据：同理，T1读取事务的时候，并不能阻止T2的修改和回滚操作，也就造成了T1读取的数据和数据库不一致的情况</li></ul><p>并没有对读操作进行限制，不在乎读到的数据是否正确<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683806226495-f6f91bb8-8695-48ca-a325-2818ebde57c8.png" alt="image.png"></p><h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><p>二级封锁协议是指,<strong>在一级封锁协议基础</strong>上增加事务T<strong>在读取数据R之前必须先对其加S锁</strong>，读完后即可释放S锁。<br />二级封锁协议可以防止丢失修改和读“脏”数据。</p><ul><li>可以防止丢失修改：因为是建立在一级封锁协议的基础上（写之前要加X锁）</li><li>可以防止读脏数据：因为在读取的时候加入了S锁，也就保证了其他事务不对该数据进行修改，也就不会产生由于修改回滚导致取出的数据和数据库不一致（或者说读取到未提交的修改的数据的）的现象</li><li>不能保证可重复读：因为读完数据后即可释放S锁<strong>（无需等待事务结束）</strong>，所以释放完S锁后，其他事务可以对该数据进行修改，也就会造成不可重复读的现象。<strong>因为事务并没有结束，所以会出现同一事务的不同时刻，会读取到不同的结果</strong></li></ul><p>在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。<br />x锁是既可以读，也可以写的<br />添加S锁，<strong>实际上是判断读取的时候是否有数据在修改</strong>。</p><ul><li>有X锁的时候，不能加入S锁-修改的时候不能读取</li><li>有S锁的时候，不能再加入X锁-读取的时候不能再修改。</li><li>有S锁的时候，可以再加入S锁-可以多个事务同时读取数据</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683806318042-9f64dbb1-96bd-4bc7-9e17-2aa62bd6d7cc.png" alt="image.png"></p><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p>三级封锁协议是指,在一级封锁协议的基础上增加事务T在读取数据R之前必须先对其加S锁,<strong>直到事务结束才释放。与二级最大的区别是释放时间</strong><br />三级封锁协议可防止丢失修改、读脏数据和不可重复读</p><ul><li>可以解决不可重复读问题：因为事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放，<strong>所以在事务执行期间，所读取到的数据不可能被修改了</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683807588604-95028ddf-5431-4df9-84a9-4df9a69ea033.png" alt="image.png"><br>如果是二级</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683807701803-39998811-6f65-4e03-a1d4-3f2a426103e3.png" alt="image.png"></p><p>T2的XlockB则可以获得，可以对B进行修改<br />加锁最大的开销：加锁后其他操作难以有有效的方式进行并发，不能够见缝插针地利用数据库资源</p><h3 id="封锁协议小结"><a href="#封锁协议小结" class="headerlink" title="封锁协议小结"></a>封锁协议小结</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683807822520-1fe9037f-6ba7-4b69-a58e-407b49b33305.png" alt="image.png"></p><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>随机发生<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683798400226-e4ffc313-d4f0-44b4-acf9-37ca100c1693.png" alt="image.png"><br>如果不采用FCFS的策略时<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683798507884-49adb3a8-ff09-4fc4-b30b-7aad2821d631.png" alt="image.png"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683798702245-66df827e-ea74-4285-b437-35094772062f.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683798832937-c14873da-b7ba-437e-9abf-8aefe00ab6c0.png" alt="image.png"></p><h2 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h2><p><strong>产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。</strong><br />预防死锁的发生就是要破坏产生死锁的条件</p><h3 id="一次封锁法"><a href="#一次封锁法" class="headerlink" title="一次封锁法"></a>一次封锁法</h3><p>一次封锁法，要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行<br />存在的问题</p><ul><li>降低系统并发度</li><li>难于事先精确确定封锁对象<ul><li>数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象，所以很难事先精确地确定每个事务所要封锁的数据对象。</li><li>解决方法：将事务在执行过程中可能要封锁的数据对象全部加锁，这就进一步降低了并发度。</li></ul></li></ul><h3 id="顺序封锁法"><a href="#顺序封锁法" class="headerlink" title="顺序封锁法"></a>顺序封锁法</h3><p>顺序封锁法，预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。<br />存在的问题</p><ul><li>维护成本<ul><li>数据库系统中封锁的数据对象极多，并且随数据的插入、删除等操作而不断地变化，要维护这样的资源的封锁顺序非常困难，成本很高。</li></ul></li><li>难以实现<ul><li>事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁</li></ul></li></ul><h2 id="死锁的诊断"><a href="#死锁的诊断" class="headerlink" title="死锁的诊断"></a>死锁的诊断</h2><p>数据库管理系统在解决死锁的问题上更普遍采用的是<strong>诊断并解除死锁</strong>的方法<br />在操作系统中广为采用的<strong>预防死锁的策略并不太适合数据库的特点</strong></p><h3 id="超时法"><a href="#超时法" class="headerlink" title="超时法"></a>超时法</h3><p>超时法，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁<br />优点：实现简单<br />缺点：有可能误判死锁时限若设置得太长，死锁发生后不能及时发现</p><h3 id="等待图法"><a href="#等待图法" class="headerlink" title="等待图法"></a>等待图法</h3><p>等待图法，并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。<strong>如果发现图中存在回路，则表示系统中出现了死锁。</strong></p><ul><li>事务等待图是一个有向图G&#x3D;(T，U)</li><li>T为结点的集合，每个结点表示正运行的事务</li><li>U为边的集合，每条边表示事务等待的情况</li><li>若T1等待T2 ，则T1 ， T2之间划一条有向边，从T1指向T2</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1683803130407-cb9de41e-5e86-4fb2-a10e-413dc4766442.png" alt="image.png"></p><h2 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h2><p>解除死锁</p><ul><li>选择一个处理死锁代价最小的事务，将其撤消</li><li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li></ul><h1 id="ch56-事务调度"><a href="#ch56-事务调度" class="headerlink" title="ch56 事务调度"></a>ch56 事务调度</h1><h2 id="并发调度的可串行性"><a href="#并发调度的可串行性" class="headerlink" title="并发调度的可串行性"></a>并发调度的可串行性</h2><ul><li>数据库管理系统对并发事务不同的调度可能会产生不同的结果</li><li><strong>串行调度是正确的</strong></li><li>**执行结果等价于串行调度的调度也是正确的，称为可串行化调度 **</li></ul><h2 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h2><ul><li>可串行化(Serializable)调度<ul><li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li></ul></li><li>可串行性(Serializability)<ul><li>是并发事务正确调度的准则</li><li>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li></ul></li></ul><h2 id="可串行化调度的例子"><a href="#可串行化调度的例子" class="headerlink" title="可串行化调度的例子"></a>可串行化调度的例子</h2><p> <img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686365573306-165980ab-d7e2-4f3a-a015-1d56b7d3faf2.png" alt="image.png"></p><h3 id="串行调度-正确的调度"><a href="#串行调度-正确的调度" class="headerlink" title="串行调度-正确的调度"></a>串行调度-正确的调度</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686365646363-47b2b144-7ff2-49ae-8c6a-5fc9079bf62b.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686365661877-fd9a315a-e7e6-4f15-b4b1-311617a81dd0.png" alt="image.png"></p><h3 id="不可串行化调度-错误的调度"><a href="#不可串行化调度-错误的调度" class="headerlink" title="不可串行化调度-错误的调度"></a>不可串行化调度-错误的调度</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686365684199-43ccc331-4c0d-4ffe-8753-4fcebd862404.png" alt="image.png"></p><h3 id="可串行化调度-正确的调度"><a href="#可串行化调度-正确的调度" class="headerlink" title="可串行化调度-正确的调度"></a>可串行化调度-正确的调度</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686365740395-45dafa96-d3fe-40ae-b074-d1f57296456d.png" alt="image.png"></p><h2 id="冲突可串行化"><a href="#冲突可串行化" class="headerlink" title="冲突可串行化"></a>冲突可串行化</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>冲突可串行化</p><ul><li>一个比可串行化更严格的条件</li><li>商用系统中的调度器采用</li></ul><p>冲突操作：是指不同的事务对同一数据的读写操作和写写操作：</p><ul><li>Ri(x)与Wj(x)&#x2F;<em>事务Ti读x，Tj写x，其中i≠j</em>&#x2F; </li><li>Wi(x)与Wj(x)&#x2F;<em>事务Ti写x，Tj写x，其中i≠j</em>&#x2F;</li></ul><p>其他操作是不冲突操作<br />不能交换（Swap）的动作:</p><ul><li>同一事务的两个操作</li><li>不同事务的冲突操作</li><li>一个调度Sc在保证冲突操作的次序不变的情况下，<strong>通过交换两个事务不冲突操作的次序</strong>得到另一个调度Sc’，<strong>如果Sc’是串行的</strong>，称调度Sc是冲突可串行化的调度</li><li>若一个调度是冲突可串行化，则一定是可串行化的调度</li><li>可用这种方法判断一个调度是否是冲突可串行化的</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686365961699-3fb41217-e49a-43ff-8515-e3ad88a57bb7.png" alt="image.png"></p><h3 id="冲突可串行化调度"><a href="#冲突可串行化调度" class="headerlink" title="冲突可串行化调度"></a>冲突可串行化调度</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686366022027-8b73c391-88f5-47f7-8d29-aed548c9b401.png" alt="image.png"></p><h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><p>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性 <br />两段锁协议，指所有<strong>事务</strong>必须分两个阶段对数据项加锁和解锁</p><ul><li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li><li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li></ul><p>“两段”锁的含义，**事务分为两个阶段 **</p><ul><li>第一阶段是获得封锁，也称为扩展阶段<ul><li>事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁</li></ul></li><li>第二阶段是释放封锁，也称为收缩阶段<ul><li>事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684392192083-10336acb-43d6-4196-a8f7-5dbde4adee0e.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684392412989-a8675099-5090-4bbf-b2b0-1d798bfd48ae.png" alt="image.png"></p><ul><li><strong>事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。</strong></li><li>若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的</li><li>若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议</li></ul><h2 id="两段锁协议与一次封锁法"><a href="#两段锁协议与一次封锁法" class="headerlink" title="两段锁协议与一次封锁法"></a>两段锁协议与一次封锁法</h2><p>两段锁协议与防止死锁的一次封锁法</p><ul><li>一次封锁法要求每个事务<strong>必须一次将所有要使用的数据全部加锁，否则就不能继续执行</strong>，因此一次封锁法遵守两段锁协议</li><li>但是两段锁协议<strong>并不要求事务必须一次将所有要使用的数据全部加锁</strong>，因此遵守两段锁协议的事务<strong>可能发生死锁</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684392633488-33692066-ab97-4b1d-ae0d-19ac66ed4bd6.png" alt="image.png"></p><h1 id="ch57-封锁粒度"><a href="#ch57-封锁粒度" class="headerlink" title="ch57 封锁粒度"></a>ch57 封锁粒度</h1><p>**封锁对象的大小称为封锁粒度(Granularity) **<br />封锁的对象：逻辑单元，物理单元 <br />例：在关系数据库中，封锁对象：</p><ul><li>逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等</li><li>物理单元：页（数据页或索引页）、物理记录等</li></ul><h2 id="选择封锁粒度原则"><a href="#选择封锁粒度原则" class="headerlink" title="选择封锁粒度原则"></a>选择封锁粒度原则</h2><p>封锁粒度与系统的并发度和并发控制的开销密切相关。</p><ul><li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，<strong>并发度就越小，系统开销也越小</strong></li><li>封锁的粒度越小，<strong>并发度较高，但系统开销也就越大</strong></li></ul><p>例</p><ul><li>若封锁粒度是数据页，事务T1需要修改元组L1，则T1必须对包含L1的整个数据页A加锁。如果T1对A加锁后事务T2要修改A中元组L2，则T2被迫等待，直到T1释放A。</li><li>如果封锁粒度是元组，则T1和T2可以同时对L1和L2加锁，<strong>不需要互相等待，提高了系统的并行度。</strong></li><li>又如，事务T需要读取整个表，若封锁粒度是元组，T<strong>必须对表中的每一个元组加锁，开销极大</strong></li></ul><h2 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h2><p>多粒度封锁(Multiple Granularity Locking)<br>在一个系统中同时支持多种封锁粒度供不同的事务<br />选择选择封锁粒度，<strong>同时考虑封锁开销和并发度两个因素</strong>, 适当选择封锁粒度</p><ul><li>需要处理多个关系的大量元组的用户事务：以数据库为封锁单位</li><li>需要处理大量元组的用户事务：以关系为封锁单元</li><li>只处理少量元组的用户事务：以元组为封锁单位</li></ul><h2 id="多粒度树"><a href="#多粒度树" class="headerlink" title="多粒度树"></a>多粒度树</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686366628937-e7a195e5-e629-45f1-ad51-713a18299e3b.png" alt="image.png"></p><h2 id="多粒度封锁协议"><a href="#多粒度封锁协议" class="headerlink" title="多粒度封锁协议"></a>多粒度封锁协议</h2><ul><li>允许多粒度树中的每个结点被独立地加锁</li><li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁</li><li>在多粒度封锁中一个数据对象可能以两种方式封锁：<ul><li>显式封锁: 直接加到数据对象上的封锁</li><li>隐式封锁:是该数据对象没有独立加锁，是<strong>由于其上级结点加锁而使该数据对象加上了锁</strong></li></ul></li><li>显式封锁和隐式封锁的效果是一样的</li></ul><h2 id="显式封锁和隐式封锁"><a href="#显式封锁和隐式封锁" class="headerlink" title="显式封锁和隐式封锁"></a>显式封锁和隐式封锁</h2><p>系统检查封锁冲突时</p><ul><li>要检查显式封锁</li><li>还要检查隐式封锁</li></ul><p>例如，事务T要<strong>对关系R1加X锁</strong></p><ul><li>系统必须<strong>搜索其上级结点</strong>数据库、关系R1</li><li>还要<strong>搜索R1的下级结点</strong>，即R1中的每一个元组</li><li><strong>如果其中某一个数据对象已经加了不相容锁，则T必须等待</strong></li></ul><p>对某个数据对象加锁，系统要检查 </p><ul><li>该数据对象有无显式封锁与之冲突</li><li>所有上级结点<ul><li>检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点已加的封锁造成的）</li></ul></li><li>所有下级结点<ul><li>看本次事务添加的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突</li></ul></li></ul><p>即：</p><ul><li>与自己已经有的显式封锁是否冲突</li><li>与自己已经有的隐式封锁是否冲突</li><li>下级结点的封锁与自己要给下级结点带来的隐式封锁是否冲突</li></ul><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>引进意向锁（intention lock）目的：<strong>提高对某个数据对象加锁时系统的检查效率</strong><br /><strong>有了意向锁，系统就无需逐个检查下一结点的显式封锁</strong><br />如果对一个结点加<strong>意向锁</strong>，则说明该结点的下层结点正在被加锁<br />对任一结点加<strong>基本锁</strong>，必须先对它的上层结点加意向锁<br />例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁</p><h3 id="意向共享锁-IS锁"><a href="#意向共享锁-IS锁" class="headerlink" title="意向共享锁-IS锁"></a>意向共享锁-IS锁</h3><p><strong>意向共享锁(Intent Share Lock，简称IS锁)</strong></p><ul><li>如果对一个数据对象加IS锁，表示它的<strong>后裔结点拟（意向）加S锁</strong>。</li><li>例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁</li></ul><h3 id="意向排他锁-IX锁"><a href="#意向排他锁-IX锁" class="headerlink" title="意向排他锁-IX锁"></a>意向排他锁-IX锁</h3><p><strong>意向排它锁(Intent Exclusive Lock，简称IX锁)</strong></p><ul><li>如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。</li><li>例如：事务T1要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁</li></ul><h3 id="共享意向排他锁-SIX锁"><a href="#共享意向排他锁-SIX锁" class="headerlink" title="共享意向排他锁-SIX锁"></a>共享意向排他锁-SIX锁</h3><p><strong>共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)</strong></p><ul><li>如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX &#x3D; S + IX。</li><li>例：对某个表加SIX锁，则表示该事务要<strong>读整个表</strong>（所以要对该表加S锁），同时会<strong>更新个别元组</strong>（所以要对该表加IX锁）。</li></ul><h3 id="意向锁的相容矩阵"><a href="#意向锁的相容矩阵" class="headerlink" title="意向锁的相容矩阵"></a>意向锁的相容矩阵</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686367481628-b698d31f-ef38-4217-bc66-26820ef27508.png" alt="image.png"></p><blockquote><p>T1加S锁,T2只能加S和IS锁。<br />X锁排他，pass。<br />**因为加S所后，对应数据的子节点都隐式的加了S锁，所以加IX锁表示其子节点拟加X锁(确实逻辑上可能不会对子节点加锁，但是只要有这个可能性就要保证正确性)**，X排他，pass。SIX锁同理。<br>T1加X锁，T2只能干等着。因为X锁排他，优先级最高</p><p>T1加IS锁，T2不能加X锁。<strong>因为T1有对其子节点加S锁的可能而T2扼杀了这个可能性</strong>。<br />至于<strong>T2为什么能加IX锁是因为I锁只是意向锁，所以是可行的，若事务有非意向锁，根据相容矩阵再次判定</strong>。SIX锁综上同理。</p><p>T1加IX锁，T2不能加S，X，SIX锁的原因不再赘述。(不能加SIX锁的原因，可参考不能加S锁)<br>T1加SIX锁，T2只能加IS锁。</p><p>不能加S，X，IX，SIX锁的原因分别是：<br>T2加S，T1无法完成SIX锁的IX部分<br>T2加X，T1首先就无法完成S锁，更别说SIX锁</p><p><strong>T2加IX，表示T2意向修改对象子节点，而T1要读对象，若T2修改其子节点便产生并发错误</strong>。故pass</p><p>T2加SIX，综合上面S和IX的情况。pass</p></blockquote><p>（S锁就是已经加上去了，IS锁就是有可能不加S锁）</p><h3 id="锁的强度"><a href="#锁的强度" class="headerlink" title="锁的强度"></a>锁的强度</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686367498809-0b0a72f9-2253-421f-b3ec-7f686476e191.png" alt="image.png"></p><h2 id="具有意向锁的多粒度封锁方法"><a href="#具有意向锁的多粒度封锁方法" class="headerlink" title="具有意向锁的多粒度封锁方法"></a>具有意向锁的多粒度封锁方法</h2><p>申请封锁时应该按自上而下的次序进行<br />释放封锁时则应该按自下而上的次序进行<br />具有意向锁的多粒度封锁方法</p><ul><li>提高了系统的并发度</li><li>减少了加锁和解锁的开销</li><li>在实际的数据库管理系统产品中得到广泛应用</li></ul><p>例如：事务T1要对关系R1加S锁</p><ul><li>要首先对数据库加IS锁</li><li>检查数据库和R1是否已加了不相容的锁(X或IX)</li><li>不再需要搜索和检查R1中的元组是否加了不相容的锁(X锁)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter09 - 关系查询处理和查询优化</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter09%20-%20%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/Chapter09%20-%20%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="ch58-查询处理"><a href="#ch58-查询处理" class="headerlink" title="ch58 查询处理"></a>ch58 查询处理</h1><h2 id="查询处理步骤"><a href="#查询处理步骤" class="headerlink" title="查询处理步骤"></a>查询处理步骤</h2><p>大部分情况下，应用的业务逻辑确定，那么相关的flower语句是确定的<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684830038573-b4cf93b6-7741-41b4-8b20-0217a6915b31.png" alt="image.png"><br>执行重复的flower语句，可以直接使用查询执行计划。再次执行，就不需要优化了，直接使用<br />执行的次数越多，那么所带来的收益也就越大。<br />如果执行某些不常用的语句，</p><h3 id="查询分析"><a href="#查询分析" class="headerlink" title="查询分析"></a>查询分析</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684830793558-72cd3fcd-a8fa-4fc9-8c9f-9acc86800cdb.png" alt="image.png"></p><h3 id="查询检查"><a href="#查询检查" class="headerlink" title="查询检查"></a>查询检查</h3><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684830749851-fb517619-dc83-4d7d-95f5-65a18ce03c56.png" alt="image.png"><br>基于规则的优化器更像是一个经验丰富熟知各条路段的老司机，大部分情况可以根据自己的经验来判断走哪条路可以更快的到达目的地，而基于代价的优化更像手机里面的地图，它可以选择出许多不同的路径根据实时的路况信息综合考虑路程长度，交通状况来挑出最优的路径。</p><h3 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684830773728-bbbd3209-5d34-4a58-b8ce-fc3dfc0ca7c7.png" alt="image.png"></p><h2 id="选择操作的实现"><a href="#选择操作的实现" class="headerlink" title="选择操作的实现"></a>选择操作的实现</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684831619388-a8df2063-f885-499a-8f97-5d6e092fb5ab.png" alt="image.png"></p><h3 id="全表扫描算法"><a href="#全表扫描算法" class="headerlink" title="全表扫描算法"></a>全表扫描算法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684831668555-658d7fd0-0c6a-45b3-af96-abec0e4fdec4.png" alt="image.png"></p><h3 id="索引扫描算法"><a href="#索引扫描算法" class="headerlink" title="索引扫描算法"></a>索引扫描算法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684831692142-08f5fbfd-c9e3-4171-97e9-41f51388e14d.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684831712474-d371c91a-6d72-471a-b77b-faebde8234bd.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684831729886-95284cb5-b0d5-4584-b68c-df32742e57a8.png" alt="image.png"></p><h2 id="连接操作的实现"><a href="#连接操作的实现" class="headerlink" title="连接操作的实现"></a>连接操作的实现</h2><p>连接操作是查询处理中最耗时的操作之一 </p><h3 id="嵌套循环算法"><a href="#嵌套循环算法" class="headerlink" title="嵌套循环算法"></a>嵌套循环算法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684831764567-26ab6107-03f3-4d91-9964-1719bfaf30b4.png" alt="image.png"></p><h3 id="排序-合并算法"><a href="#排序-合并算法" class="headerlink" title="排序-合并算法"></a>排序-合并算法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684831853961-6d459b4a-c913-4bc2-973f-8d28e63e4712.png" alt="image.png"></p><ol><li>排序阶段本身需要开销</li><li>排序的结果需要重新写回，无法存储在内存中</li><li>规模越大，收益越大</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684831953046-0ae2c9b6-aa3b-4f28-87da-e3a632beab12.png" alt="image.png"></p><h3 id="索引连接算法"><a href="#索引连接算法" class="headerlink" title="索引连接算法"></a>索引连接算法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684832046687-c61b7c99-6df5-43ab-9438-e8c78dd5fd88.png" alt="image.png"></p><h3 id="Hash-Join算法"><a href="#Hash-Join算法" class="headerlink" title="Hash Join算法"></a>Hash Join算法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684832128431-f9fc73f1-a4fe-44de-8bed-e84130dd0d01.png" alt="image.png"></p><h1 id="ch59-查询优化"><a href="#ch59-查询优化" class="headerlink" title="ch59 查询优化"></a>ch59 查询优化</h1><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684832434242-c578b064-3b15-4524-aad4-dfe5ec763942.png" alt="image.png"><br>物理统计信息是归属在内模式中的</p><h2 id="查询优化的实例"><a href="#查询优化的实例" class="headerlink" title="查询优化的实例"></a>查询优化的实例</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684833682281-8d57e5e4-722d-49a9-96cb-dde4d0aa8f1f.png" alt="image.png"></p><h3 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684833513236-584083af-e9df-406a-80d9-48618ba16f2c.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684833529625-316c76b5-d076-4a3e-8d2a-e8c45e576e1f.png" alt="image.png"></p><h3 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h3><p>笛卡尔积上做特定选择就可以看做是连接<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684833561345-03b02b6f-93d4-4f47-bf81-100a40b7378f.png" alt="image.png"></p><h3 id="方案C"><a href="#方案C" class="headerlink" title="方案C"></a>方案C</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684833653918-6f283bbb-9b80-450d-8182-dababd9303c5.png" alt="image.png"></p><h3 id="拥有索引的实例"><a href="#拥有索引的实例" class="headerlink" title="拥有索引的实例"></a>拥有索引的实例</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684833769232-1d51fed1-8c3c-4cf2-bc39-e986bc9f3ace.png" alt="image.png"></p><h3 id="优化实例"><a href="#优化实例" class="headerlink" title="优化实例"></a>优化实例</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684833732093-36f6eab0-db9b-4ff3-a8ac-29a0fc7a88ed.png" alt="image.png"></p><h1 id="ch60-代数优化"><a href="#ch60-代数优化" class="headerlink" title="ch60 代数优化"></a>ch60 代数优化</h1><p>先投影，后选择<br />同时进行选择（判断是否需要留下）和投影<br />类比：先发可乐，后发汉堡和同时发可乐、汉堡</p><h2 id="典型的启发式规则"><a href="#典型的启发式规则" class="headerlink" title="典型的启发式规则"></a>典型的启发式规则</h2><p>不需要找到每一个等价表达式，而是需要尽可能找到最优解</p><ol><li>选择运算<ol><li>应尽可能先做在优化策略中这是最重要、最基本的一条。</li></ol></li><li>把投影运算和选择运算同时进行<ol><li>如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。</li></ol></li><li>把投影同其前或其后的双目运算结合起来<ol><li>没有必要为了去掉某些字段而扫描一遍关系。</li></ol></li><li>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算<ol><li>连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间。</li></ol></li><li>找出公共子表达式<ol><li>如果这种重复出现的子表达式的结果不是很大的关系，并且从外存中读入这个关系比计算该子表达式的时间少得多，则先计算一次公共子表达式并把结果写入中间文件是合算的。</li><li>当查询的是视图时，定义视图的表达式就是公共子表达式的情况。<strong>视图产生的结果集是固定的？</strong></li></ol></li></ol><p>大量的关系型数据库不支持笛卡尔积，效率低</p><h3 id="启发式优化1"><a href="#启发式优化1" class="headerlink" title="启发式优化1"></a>启发式优化1</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684834300839-550e29fe-bb61-4c41-ac38-1c91a7b1fb96.png" alt="image.png"><br>选择往叶节点跑</p><h3 id="启发式优化2"><a href="#启发式优化2" class="headerlink" title="启发式优化2"></a>启发式优化2</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684834341845-d448e850-17d9-4b4a-bd84-9adc044c72a1.png" alt="image.png"></p><h3 id="启发式优化3"><a href="#启发式优化3" class="headerlink" title="启发式优化3"></a>启发式优化3</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684834385621-c2d16199-cb77-4af2-b832-aee5628c3150.png" alt="image.png"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684834420276-a02d588e-a767-4403-b448-7716269b4d4d.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684834436101-9ad56105-438b-4bd0-86bd-46c73f7b5da4.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684834445694-2f2adcfa-3301-4316-81b5-db574630bb68.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684834455991-a1428d75-aeb3-4aa5-867b-8e9180185888.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684834474299-f020b9d7-412a-4d71-9789-8f62c2ee74d0.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684834543104-3637a810-860e-469f-a7e1-155e6e169c29.png" alt="image.png"></p><h1 id="ch61-物理优化"><a href="#ch61-物理优化" class="headerlink" title="ch61 物理优化"></a>ch61 物理优化</h1><ul><li>代数优化改变查询语句中操作的次序和组合，不涉及底层的存取路径</li><li>对于一个查询语句有许多存取方案，它们的执行效率不同， 仅仅进行代数优化是不够的</li><li>物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划</li></ul><p>物理优化方法</p><ul><li>基于规则的启发式优化<ul><li>启发式规则是指那些在大多数情况下都适用，但不是在每种情况下都是最好的规则。</li></ul></li><li>基于代价估算的优化<ul><li>优化器估算不同执行策略的代价，并选出具有最小代价的执行计划。</li></ul></li><li>两者结合的优化方法：<ul><li>常常先使用启发式规则，选取若干较优的候选方案，减少代价估算的工作量</li><li>然后分别计算这些候选方案的执行代价，较快地选出最终的优化方案</li></ul></li></ul><h2 id="启发式规则"><a href="#启发式规则" class="headerlink" title="启发式规则"></a>启发式规则</h2><h3 id="选择操作的启发式规则"><a href="#选择操作的启发式规则" class="headerlink" title="选择操作的启发式规则"></a>选择操作的启发式规则</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684835030147-fcb43525-ad41-43c5-bcb8-d8899d76248d.png" alt="image.png"><br>求并使用索引比较麻烦，得到的是超集</p><h3 id="连接操作的启发式规则"><a href="#连接操作的启发式规则" class="headerlink" title="连接操作的启发式规则"></a>连接操作的启发式规则</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684835131006-91faae0e-2b22-421a-bffe-490cb5ecd7b2.png" alt="image.png"></p><h2 id="基于代价的优化"><a href="#基于代价的优化" class="headerlink" title="基于代价的优化"></a>基于代价的优化</h2><h3 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684835164105-ff7b2580-b0ba-4226-b184-de96b1a1d850.png" alt="image.png"></p><h3 id="代价估算"><a href="#代价估算" class="headerlink" title="代价估算"></a>代价估算</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684835498111-9dfbf58a-c2e4-42bf-8461-bc7b2b426963.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1684835508046-861008da-4201-40f3-92bf-08a106f9afbc.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/NoSQL/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/NoSQL/</url>
      
        <content type="html"><![CDATA[<h1 id="ch62-关系型数据库的价值"><a href="#ch62-关系型数据库的价值" class="headerlink" title="ch62 关系型数据库的价值"></a>ch62 关系型数据库的价值</h1><h2 id="获取持久化数据"><a href="#获取持久化数据" class="headerlink" title="获取持久化数据"></a>获取持久化数据</h2><p>持久存储大量数据<br />在大多数的计算架构中，有两个存储区域: </p><ul><li>速度快但是数据易丢失的“主存储器”(main memory)<ul><li>空间有限</li><li>易挥发</li></ul></li><li>存储量大但速度较慢的“后备存储器”(backing store)<ul><li>文件系统，如许多生产力应用程序(productivity application，比如文字处理软件)</li><li>数据库，大多数企业级应用程序<blockquote><p><strong>挥发性和非挥发性存储器跟掉电丢失与否有关。前者为掉电数据丢失。</strong><br />RAM为随机存取存储器，理论上断电后数据全丢失，但是非挥发性RAM内置了一个电源，有个检测系统是否掉电的电路，当监测到掉电时，即接通内部电源以确保时间保持和内存数据不受破坏。这相当于没有掉电，即RAM的数据也没丢失。</p></blockquote></li></ul></li></ul><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>多个用户会一起访问同一份数据体，并且可能要修改这份数据。（大多数情况下，他们都在不同数据区域内各自操作，但是，偶尔也会同时操作一小块数据）<br />关系型数据库提供了“事务”机制来控制对其数据的访问，以便处理此问题。<br />事务在处理错误时也有用。通过事务更改数据时，如果在处理变更的过程中出错了，那么就可以回滚（roll back）这一事务，以保证数据不受破坏。</p><h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><ul><li>企业级应用程序居于一个丰富的生态系统中，它需要与其他应用程序协同工作。<strong>不同的应用程序经常要使用同一份数据，而且某个应用程序更新完数据之后，必须让其他应用程序知道这份数据已经改变了。</strong></li><li>常用的办法是使用共享数据库集成(shared database integration) ，<strong>多个应用程序都将数据保存在同一个数据库中</strong>。这样一来，所有应用程序很容易就能使用彼此的数据了。</li><li>与多用户访问单一应用程序时一样，数据库的并发控制机制也可以应对多个应用程序。</li></ul><h2 id="近乎标准的模型"><a href="#近乎标准的模型" class="headerlink" title="近乎标准的模型"></a>近乎标准的模型</h2><p>关系型数据库以近乎标准的方式提供了数据模型。<br />尽管各种关系型数据库之间仍有差异，但其核心机制相同</p><ul><li>不同厂商的SQL方言相似</li><li>“事务” 的操作方式也几乎一样</li></ul><h1 id="ch63-NoSQL的由来"><a href="#ch63-NoSQL的由来" class="headerlink" title="ch63 NoSQL的由来"></a>ch63 NoSQL的由来</h1><h2 id="阻抗失谐"><a href="#阻抗失谐" class="headerlink" title="阻抗失谐"></a>阻抗失谐</h2><p>基于关系代数(relational algebra)，关系模型把数据组织成 “关系”(relation)和“元组”(tuple)。</p><ul><li>元组是由“键值对”(name-value pair)构成的集合</li><li>而关系则是元组的集合。</li><li>SQL操作所使用及返回的数据都是“关系”</li><li><strong>元组不能包含“嵌套记录”(nested record)或“列表”(list) 等任何结构</strong></li></ul><p>而内存中的数据结构则无此限制，它可以使用的数据组织形式比“关系”更丰富。<br /><strong>关系模型和内存中的数据结构之间存在差异。这种现象通常称为“阻抗失谐”。</strong><br />如果在内存中使用了较为丰富的数据结构，那么要把它保存到磁盘之前，必须先将其转换成“关系形式”。于是就发生了“阻抗失谐”：<strong>需要在两种不同的表示形式之间转译</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686383247158-0f3acaf9-d628-459e-96dc-8cf26bc3416c.png" alt="image.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>面向对象数据库</li><li>“对象-关系映射框架”( object-relational mapping framework) 通过映射模式( mapping pattern)表达转换</li><li>问题：<ul><li>查询性能问题</li><li>集成问题</li></ul></li></ul><h2 id="集成数据库"><a href="#集成数据库" class="headerlink" title="集成数据库"></a>集成数据库</h2><p>SQL充当了应用程序之间的一种集成机制。数据库在这种情况下成了“集成数据库”(integration database)</p><ul><li>通常由<strong>不同团队所开发的多个应用程序，将其数据存储在一个公用的数据库中</strong>。</li><li>所有应用程序都在<strong>操作内容一致的持久数据</strong>，提高了数据通信的效率</li><li>为了能将很多应用程序集成起来，<strong>数据库的结构比单个应用程序所要用到的结构复杂得多</strong></li><li>如果某个应用程序想要修改存储的数据，那么它就得<strong>和所有使用此数据库的其他应用程序相协调</strong>。</li><li><strong>各种应用程序的结构和性能要求不尽相同</strong>，数据库通常不能任由应用程序更新其数据。为了保持数据库的完整性，我们需要将这一责任交由数据库自身负责。</li></ul><h2 id="应用程序数据库"><a href="#应用程序数据库" class="headerlink" title="应用程序数据库"></a>应用程序数据库</h2><p>将数据库视为“应用程序数据库”(application database)，** 其内容只能由一个应用程序的代码库直接访问**<br />由于只有开发应用程序的团队才需要知道其结构，模式的维护与更新就更容易了。<br />由于应用程序开发团队<strong>同时管理数据库和应用程序代码</strong>，因此可以把维护数据库完整性的工作放在应用程序代码中。<br /><strong>交互工作转交由应用程序接口来完成</strong></p><ul><li>“面向服务架构” 、Web服务。使得应用程序间<strong>通过平台中立的方式完成集成</strong>。</li><li>在Web服务作为集成机制后，所交换的数据可以拥有更为灵活的结构<ul><li>如XML、 JSON格式，它们均能够使用嵌套记录及列表等更丰富的数据结构使用</li><li>“面向文档”的交互方式，减少通讯次数和开销</li><li>既可以传输文本，也可以传输二进制</li></ul></li></ul><p>在使用应用程序数据库后，由于内部数据库与外部通信服务之间已经解耦，所以外界并不关心数据如何存储，这样就可以选用非关系型数据库了<br />关系型数据库的许多特性，诸如安全性等，可以**交给使用该数据库的外围应用程序(enclosing application)**来做</p><h2 id="集群问题"><a href="#集群问题" class="headerlink" title="集群问题"></a>集群问题</h2><p>纵向扩展(scale up)及横向扩展(scale out)</p><ul><li>采用集群应对横向扩展<blockquote><p>必须有更多的计算资源，才能应对数据和流量的增加。处理此类增长有两种方案:纵向扩展(scale up）及横向扩展(scale out)。<strong>如果要纵向扩展，那么就需要功能更强大的计算机</strong>，要购买更多的处理器、磁盘存储空间和内存。但是机器的功能越强，其成本也越高，更何况其扩展尺度也有限。另一种方案是:<strong>采用由多个小型计算机组成的集群。集群中的小型机可以使用性价比较高的硬件，这样就能降低扩展所需的成本。</strong>而且，这么做也更有弹性:我们可以构建一个高度稳定的集群，就算其中的某些电脑经常发生故障，也不会影响整个集群的运行。</p></blockquote></li></ul><p>关系型数据库的“分片”和“复制”</p><ul><li><p>在负载分散的同时，应用程序必须控制所有分片，需要知道数据库中的每份小数据的存储情况</p></li><li><p>如何确保跨分片的查询、参照完整性(referential integrity)、 事务、一致性控制(consistency control)等操作</p></li><li><p>纵向扩展(scale up)是指通过<strong>在节点上增加更多的CPU、内存和硬盘来扩大系统的能力</strong>。 这种方式适合于系统设计初期或者对数据实时性要求很高的场景，但是<strong>成本较高，且有单点故障的风险。</strong></p></li><li><p>横向扩展(scale out)是指通过<strong>增加节点的数量来提高系统的处理能力</strong>。这种方式适合于系统并发超过单机极限或者需要分布式计算的场景，但是也会引入一些复杂问题，如<strong>负载均衡、数据一致性、容错</strong>等。</p></li><li><p>关系型数据库的“分片”(sharding)是指<strong>将一个大的数据库分割成多个小的数据库，每个小数据库只存储一部分数据</strong>，从而提高查询效率和可扩展性。</p></li><li><p>关系型数据库的“复制”(replication)是指<strong>将一个数据库的数据完全或部分地复制到另一个数据库中</strong>，从而提高数据可用性和容错性</p></li><li><p>跨分片的查询是指<strong>需要从多个分片中获取数据的查询，这种查询通常比单分片的查询更复杂和低效</strong>，因为需要合并不同分片的结果。</p></li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>NoSQL没有规范的定义“开源分布式的非关系型数据库”<br />各种NoSQL数据库的共同特性是</p><ul><li>不使用关系模型：NoSQL数据库不将数据存储在固定的表格中，而是采用各种数据模型，如文档、键值、图形等，来适应不同的数据类型和结构</li><li>在集群中运行良好<ul><li>关系型数据库使用ACID事务来保持整个数据库的一致性，而这种方式本身与集群环境相冲突</li><li>NoSQL数据库为处理并发及分布问题提供了众多选项。</li></ul></li><li>开源</li><li>适用于21世纪的互联网公司</li><li>无模式<ul><li>不用事先修改结构定义，即可自由添加字段了</li><li>这在处理不规则数据和自定义字段时非常有用<blockquote><p>举例来说，如果我们使用一个文档型数据库，如MongoDB，来存储用户信息，我们不需要预先定义用户表的字段和类型，<strong>我们可以根据需要随时添加或修改用户文档的属性。</strong>例如，我们可以给某些用户添加一个“爱好”字段，而不影响其他用户文档。这样做的<strong>好处是可以灵活地适应用户信息的变化，而不需要频繁地修改数据库架构</strong>。但是这样做的<strong>坏处是可能导致用户信息的不一致性和冗余性</strong>，比如有些用户可能有多个“爱好”字段，或者有些用户可能没有“姓名”字段等。这就给数据管理和维护带来了挑战，比如如何保证数据的完整性和有效性，如何进行数据清洗和分析等。</p></blockquote></li></ul></li></ul><h2 id="为什么使用NoSQL"><a href="#为什么使用NoSQL" class="headerlink" title="为什么使用NoSQL"></a>为什么使用NoSQL</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686454883123-860552a9-bcf6-4ee7-b96e-b59c46671f1b.png" alt="image.png"></p><h1 id="ch64-聚合"><a href="#ch64-聚合" class="headerlink" title="ch64 聚合"></a>ch64 聚合</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>把一组相互关联的对象视为一个整体单元来操作，而这个单元就叫聚合（aggregate）。</p><ul><li>通过原子操作(atomic operation)更新聚合的值（含一致性管理）</li><li>以聚合为单位，进行数据存储通信</li><li>在集群中操作数据库时，用聚合为单位来复制和分片</li><li>聚合描述数据访问方式</li></ul><p>面向聚合操作数据时所用的单元，其结构比元组集合复杂得多</p><ul><li>“键值数据库”、“文档数据库”、“列族数据库”</li></ul><h2 id="关系模型和聚合模型"><a href="#关系模型和聚合模型" class="headerlink" title="关系模型和聚合模型"></a>关系模型和聚合模型</h2><h3 id="关系实例"><a href="#关系实例" class="headerlink" title="关系实例"></a>关系实例</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686384847513-9cff477f-fffa-4c84-9409-6afd2755089e.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686384854125-8340bd48-6a58-4a93-9c50-b29c079fff67.png" alt="image.png"></p><h3 id="聚合实例1"><a href="#聚合实例1" class="headerlink" title="聚合实例1"></a>聚合实例1</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686384880918-62b5813e-a28b-481c-a859-3ab963a523b1.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686384890454-849f1aee-c477-4fca-8efa-77e6bd816ca2.png" alt="image.png"></p><h3 id="聚合实例2"><a href="#聚合实例2" class="headerlink" title="聚合实例2"></a>聚合实例2</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686384910518-f2303e3d-4872-4f4f-9ccc-0fa6132aa1d7.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686384918398-bf0b8e43-10e4-4bf5-ac02-2e2e9d8552ba.png" alt="image.png"></p><h2 id="聚合无知"><a href="#聚合无知" class="headerlink" title="聚合无知"></a>聚合无知</h2><p>关系型数据库的数据模型中，没有“聚合”这一概念，因此我们称之为“聚合无知”(aggregate-ignorant)。 <br />“图数据库”也是聚合无知的。<br />聚合反应数据操作的边界，<strong>很难在共享数据的多个场景中“正确” 划分，对某些数据交互有用的聚合结构，可能会阻碍另一些数据交互</strong></p><ul><li>在客户下单并核查订单，以及零售商处理订单时，将订单视为一个聚合结构就比较合适。</li><li>如零售商要分析过去几个月的产品销售情况，如果将订单做成一个聚合，就必须深挖数据库中的每一个聚合。</li></ul><p>聚合无知模型是指不使用聚合的数据模型，而是将数据对象作为独立的实体来存储和操作。这样做的好处是可以<strong>根据不同的需求和场景来组织和查询数据对象，而不受固定的聚合结构的限制。</strong><br />若是采用“聚合无知模型”，如果没有一种占主导地位的结构，那么很容易就能以不同方式（查询方式）来查看数据</p><h2 id="聚合之间的关系"><a href="#聚合之间的关系" class="headerlink" title="聚合之间的关系"></a>聚合之间的关系</h2><p>例如：把订单和客户放在两个聚合中，但是想在它们之间设定某种关系，以便能根据订单查出客户数据</p><ul><li>要提供这种关联，最简单的办法就是把客户ID嵌入订单的聚合数据中。</li><li>在应用层级提供关联，在数据库层级提供聚合之间关系的表达机制</li></ul><p>操作多个有关联的聚合，由应用保证其正确性<br />面向聚合数据库获取数据时以聚合为单元，只能保证单一聚合内部内容的原子性</p><p>举例来说，如果我们有一个订单聚合和一个库存聚合，我们想要实现一个下单的操作，那么我们需要在应用程序中做以下几步：</p><ul><li>查询订单聚合，检查订单的状态和金额等信息。</li><li>查询库存聚合，检查库存是否足够。</li><li>如果库存足够，更新订单聚合，将订单状态改为已支付。</li><li>如果库存足够，更新库存聚合，将库存数量减少相应的数量。</li></ul><p>在这个过程中，我们<strong>需要在应用程序中保证订单和库存之间的关联关系的正确性</strong><br />比如<strong>如果订单更新失败了，我们需要回滚库存的更新</strong>。同时，我们<strong>只能保证对单个聚合的操作是原子性的</strong>，比如<strong>如果订单更新成功了，但是库存更新失败了，数据库无法自动撤销订单的更新（因为操作是原子性的，需要手动处理这些异常情况）</strong>。这就可能导致数据的不一致性和异常情况。因此，在操作多个有关联的聚合时，我们需要在应用程序中使用一些机制来保证事务性和一致性</p><h2 id="聚合、集群和事务处理"><a href="#聚合、集群和事务处理" class="headerlink" title="聚合、集群和事务处理"></a>聚合、集群和事务处理</h2><ul><li>在集群上运行时，需要<strong>把采集数据时所需的节点数降至最小</strong></li></ul><p>如果在数据库中明确包含聚合结构，那么它就可以根据这一重要信息，<strong>知道哪些数据需要一起操作了，而且这些数据应该放在同一个节点中</strong></p><ul><li>通常情况下，面向聚合的数据库不支持跨越多个聚合的ACID事务。它每次只能在一个聚合结构上执行原子操作。<ul><li>如果想以原子方式操作多个聚合，那么就必须自己组织应用程序的代码</li><li>在实际应用中，<strong>大多数原子操作都可以局限于某个聚合结构内部，而且，在将数据划分为聚合时，这也是要考虑的因素之一</strong></li></ul></li></ul><h1 id="ch65-主要的NoSQL数据模型？"><a href="#ch65-主要的NoSQL数据模型？" class="headerlink" title="ch65 主要的NoSQL数据模型？"></a>ch65 主要的NoSQL数据模型？</h1><h2 id="键值数据模型与文档数据模型"><a href="#键值数据模型与文档数据模型" class="headerlink" title="键值数据模型与文档数据模型"></a>键值数据模型与文档数据模型</h2><p>这两类数据库都包含大量聚合，每个聚合中都有一个获取数据所用的键或ID。<br />两种模型的区别是:</p><ul><li><strong>键值数据库的聚合不透明，只包含语义中立的大块信息</strong><ul><li>数据库可能会限制聚合的总大小，但除此之外，聚合中可以存储任意数据。</li><li>在键值数据库中，要访问聚合内容，只能通过键来查找</li></ul></li><li><strong>在文档数据库的聚合中，可以看到其结构</strong>。<ul><li>限制其中存放的内容，它定义了其允许的结构与数据类型能够更加灵活地访问数据。</li><li>通过用聚合中的字段查询，可以只获取一部分聚合，而不用获取全部内容</li><li>可以按照聚合内容创建索引</li></ul></li></ul><h2 id="列族存储数据模型"><a href="#列族存储数据模型" class="headerlink" title="列族存储数据模型"></a>列族存储数据模型</h2><ul><li>大部分数据库都以行为单元存储数据。然而，有些情况下写入操作执行得很少，但是经常需要一次读取若干行中的很多列。此时，列存储数据库将所有行的某一组列作为基本数据存储单元</li><li>列族数据库将列组织为列族。每一列都必须是某个列族的一部分，而且访问数据的单元也得是列某个列族中的数据经常需要一起访问</li></ul><p>列族模型将其视为两级聚合结构(two-level aggregate structure)。<br />第一个键通常代表行标识符，与“键值存储”相同，可以用它来获取想要的聚合<br />列族结构与“键值存储”的区别在于，其“行聚合”(row aggregate)本身又是一个映射，其中包含一些更为详细的值。这些“二级值” (second-level value)就叫做“列”。与整体访问某行数据一样，我们也可以操作特定的列</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686388529322-6fb4e4b2-1e83-4134-b35e-e1362d76192d.png" alt="image.png"></p><p>两种数据组织方式</p><ul><li>面向行(row-oriented)：每一行都是一个聚合(例如ID为1234的顾客就是一个聚合)，该聚合内部存有一些包含有用数据块(客户信息、订单记录)的列族</li><li>面向列(column-oriented): 每个列族都定义了一种记录类型(例如客户信息)，其中每行都表示一条记录。数据库中的大“行”理解为列族中每一个短行记录的串接</li></ul><h2 id="面向聚合的数据模型"><a href="#面向聚合的数据模型" class="headerlink" title="面向聚合的数据模型"></a>面向聚合的数据模型</h2><p>共同点</p><ul><li>都使用聚合这一概念，而且聚合中都有一个可以查找其内容的索引键</li><li>在集群上运行时，聚合是中心环节，因为数据库必须保证将聚合内的数据存放在同一个节点上</li><li>聚合是“更新”操作的最小数据单位(atomic unit)，对事务控制来说，以聚合为操作单元</li></ul><p>差别</p><ul><li><strong>键值数据模型</strong>将聚合看作不透明的整体，只能根据键来查出整个聚合，而不能仅仅查询或获取其中的一部</li><li><strong>文档模型</strong>的聚合对数据库透明，于是就可以只查询并获取其中一部分数据了，不过，由于文档没有模式，因此在想优化存储并获取聚合中的部分内容时，数据库不太好调整文档结构</li><li><strong>列族模型</strong>把聚合分为列族，让数据库将其视为行聚合内的一个数据单元。此类聚合的结构有某种限制，但是数据库可利用此种结构的优点来提高其易访问性。</li></ul><h2 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686388815189-36070dfb-3e0d-4be5-8dff-a001cc0e0b23.png" alt="image.png"><br>图数据库的基本数据模型：由边(或称“弧”，arc)连接而成的若干节点。<br />可以用专门为“图”而设计的查询操作来搜寻图数据库的网络了：指定节点，通过边进行查询<br /><strong>关系型数据可以通过“外键”实现，查询中的多次连接，效率较差</strong></p><h2 id="无模式"><a href="#无模式" class="headerlink" title="无模式"></a>无模式</h2><p>关系型数据库中，首先必须定义“模式”，然后才能存放数据。<br />NoSQL数据库，无模式：</p><ul><li>“键值数据库”可以把任何数据存放在一个“键”的名下。</li><li>“文档数据库” 对所存储的文档结构没有限制</li><li>列族数据库中，任意列里面都可以随意存放数据</li><li>图数据库中可以新增边，也可以随意向节点和边中添加属性。</li></ul><h3 id="格式不一致的数据"><a href="#格式不一致的数据" class="headerlink" title="格式不一致的数据"></a>格式不一致的数据</h3><p>每条记录都拥有不同字段集(set of field) <br />关系型数据库中，<strong>“模式”会将表内每一行的数据类型强行统一，若不同行所存放的数据类型不同，那这么做就很别扭</strong>。</p><ul><li>要么得分别用很多列来存放这些数据，而且把用不到的字段值填成null(这就成了“稀疏表”，sparse table)</li><li>要么就要使用类似custom column 4这样没有意义的列类型。</li></ul><p><strong>无模式表则没有这么麻烦，每条记录只要包含其需要的数据即可，不用再担心上面的问题了</strong>。</p><h3 id="无模式的问题"><a href="#无模式的问题" class="headerlink" title="无模式的问题?"></a>无模式的问题?</h3><p>存在“隐含模式”。在编写数据操作代码时，对数据结构所做的一系列假设</p><ul><li>应用与数据的耦合问题</li><li>无法在数据库层级优化和验证数据</li></ul><p>在集成数据库中，很难解决</p><ul><li>使用应用程序数据库，并使用Web Services、SOA等完成集成</li><li>在聚合中为不同应用程序明确划分出不同区域<ul><li>在文档数据库中，可以把文档分成不同的区段(section)</li><li>在列族数据库，可以把不同的列族分给不同的应用程序<blockquote><p>根据应用程序的需求，只访问所需的区域，减少数据传输和处理的开销。</p><p>根据区域的重要性和敏感性，设置不同的访问权限和安全策略，保护数据的完整性和隐私性。</p><p>根据区域的变化频率和更新方式，设置不同的备份和恢复策略，提高数据的可用性和可靠性。</p></blockquote></li></ul></li></ul><h1 id="ch66-分布式模型"><a href="#ch66-分布式模型" class="headerlink" title="ch66 分布式模型"></a>ch66 分布式模型</h1><h2 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h2><p>数据分布有两条路径:分片(sharding)与复制(replication) 。 </p><ul><li><strong>“分片”则是将不同数据存放在不同节点中</strong></li><li><strong>“复制”就是将同一份数据拷贝至多个节点</strong></li></ul><p><strong>“主从式”(master-slave)和“对等式”(peer-to-peer)</strong><br />既可以在两者中选一个来用，也可以同时使用它们。</p><h2 id="单一服务器"><a href="#单一服务器" class="headerlink" title="单一服务器"></a>单一服务器</h2><p>最简单的分布形式：根本不分布。</p><ul><li><strong>将数据库放在一个节点中，让它处理对数据存储的读取与写入操作</strong>。</li><li>不用考虑使用其他方案时所需应对的复杂事务，这对数据操作管理者与应用程序开发者来说，都比较简单。</li></ul><p>尽管许多NoSQL数据库都是为集群运行环境而设计的，但是只要符合应用程序需求，那就完全可以按照单一服务器的分布模型来使用</p><ul><li>图数据库配置在一台服务器上</li><li>如果只是为了处理聚合，那么可以考虑在单一服务器上部署“文档数据库”或“键值数据库”</li></ul><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686397043608-def3a1ba-835c-4009-a60a-ce18edbd6ccb.png" alt="image.png"></p><h3 id="节点分布"><a href="#节点分布" class="headerlink" title="节点分布"></a>节点分布</h3><p>在理想情况下，<strong>不同的服务器节点会服务于不同的用户</strong>。<strong>每位用户只需与一台服务器通信</strong>，并且很快就能获得服务器的响应。<strong>网络负载相当均衡地分布于各台服务器上</strong>。<br />为达成目标，<strong>必须保证需要同时访问的那些数据都存放在同一节点上</strong>，而且<strong>节点必须排布好这些数据块，使访问速度最优</strong>。<br />若使用面向聚合的数据库，可以把聚合作为分布数据的单元。<br />在节点的数据排布问题上，有若干个与性能改善相关的因素。</p><ul><li>地理因素</li><li>负载均衡</li><li>聚合有序放置</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li>采用<strong>应用程序的逻辑实现分片</strong></li></ol><ul><li>编程模型复杂化，因为应用程序的代码必须<strong>负责把查询操作分布到多个分片上</strong></li><li>若想重新调整分片，那么<strong>既要修改程序代码，又要迁移数据</strong></li></ul><ol start="2"><li>采用<strong>NoSQL数据库提供的“自动分片”</strong>(auto-sharding)功能</li></ol><ul><li>让数据库自己负责把数据分布到各分片</li><li>并且将数据访问请求<strong>引导至适当的分片</strong>上</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>分片可以同时<strong>提升读取与写入效率</strong><ul><li>使用“复制”技术，尤其是<strong>带缓存的复制，可以极大地改善读取性能</strong>，但对于写操作帮助不大</li></ul></li><li>分片<strong>对改善数据库的“故障恢复能力”帮助并不大</strong>。尽管数据分布在不同的节点上，但是和“单一服务器”方案一样，只要某节点出错，那么该分片上的数据就无法访问了<ul><li>在发生故障时，<strong>只有访问此数据的那些用户才会受影响</strong>，而其余用户则能正常访问</li><li>由于多节点问题，从实际效果出发，<strong>分片技术可能会降低数据库的错误恢复能力</strong></li></ul></li></ul><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>在“主从式分布”(master-slave distribution)中</p><ul><li>其中有一个节点叫做“主(master) 节点”，或“主要(primary) 节点”。主节点存放权威数据，而且通常负责处理数据更新操作。</li><li>其余节点都叫“从(slave) 节点”，或“次要(secondary) 节点”，和主节点保持同步，负责读取操作 。</li></ul><p><strong>在需要频繁读取数据集的情况下，“主从复制”(master-slave replication) 有助于提升数据访问性能</strong></p><ul><li>以<strong>新增更多从节点</strong>的方式来进行<strong>水平扩展</strong>，就<strong>可以同时处理更多数据读取请求</strong>，并且<strong>能保证将所有请求都引导至从节点</strong></li><li>在写入操作特别频繁的场合，**数据库仍受制于主节点处理更新，以及向从节点发布更新的能力 **</li></ul><p><strong>“主从复制” 可以增强“读取操作的故障恢复能力”(read resilience)</strong></p><ul><li>万一<strong>主节点出错</strong>了，那么<strong>从节点依然可以处理读取请求</strong>。</li><li>主节点出错之后，除非将其<strong>恢复</strong>，或另行<strong>指派新的主节点</strong>，否则数据库就无法处理写入操作。</li><li>在主节点出错之后，<strong>由于拥有内容与主节点相同的从节点，很快就能指派一个从节点作为新的主节点，从而具备故障恢复能力</strong>。</li><li>主节点可以手工指派，也可自动选择。</li></ul><p><strong>“数据的不一致性”</strong>：</p><ul><li><strong>网络延迟或者主从负载不一致，导致从库落后于主库，无法及时反映主库的最新状态</strong>。</li><li>主从<strong>参数设置不一致</strong>，导致从库无法正确地解析或者执行主库的日志</li><li>主从复制过程中出现错误或者异常，导致从库无法继续同步主库的日志</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686397308960-82dc6f27-9d3f-495b-a1f7-1aa3f2722281.png" alt="image.png"></p><h3 id="对等复制"><a href="#对等复制" class="headerlink" title="对等复制"></a>对等复制</h3><p>“对等复制” 它没有“主节点”这一概念。<strong>所有“副本”(replica) 地位相同，都可以接受写入请求，而且丢失其中一个副本，并不影响整个数据库的访问</strong>。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686397526432-3b201d59-98bb-4402-961b-90d4c05288da.png" alt="image.png"></p><h2 id="结合主从复制与分片"><a href="#结合主从复制与分片" class="headerlink" title="结合主从复制与分片"></a>结合主从复制与分片</h2><p>如果同时使用“主从复制”与“分片”，那么就意味着<strong>整个系统有多个主节点</strong>，然而对每项数据来说，<strong>负责它的主节点只有一个</strong><br />根据配置需要，<strong>同一个节点既可以做某些数据的主节点，也可以充当其他数据的从节点</strong>，此外，也可以指派全职的主节点或从节点<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686397555205-af102a50-34c0-4d1f-92e6-bcf4958b4c1c.png" alt="image.png"></p><h2 id="结合对等复制与分片"><a href="#结合对等复制与分片" class="headerlink" title="结合对等复制与分片"></a>结合对等复制与分片</h2><p>使用列族数据库时，经常会将“对等复制”与“分片”结合起来。<br />数据可能分布于集群中的数十个或数百个节点上。在采用“对等复制”方案时，一开始可以用“3”作为复制因子(replication factor), 也就是把<strong>每个分片数据放在3个节点中。一旦某个节点出错，那么它上面保存的那些分片数据会由其他节点重建</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686397571621-49c7dcd8-a65e-450d-8c65-1e768649985b.png" alt="image.png"></p><h1 id="ch67-分布式模型中的一致性"><a href="#ch67-分布式模型中的一致性" class="headerlink" title="ch67 分布式模型中的一致性"></a>ch67 分布式模型中的一致性</h1><h2 id="更新一致性（写入冲突和读写冲突）"><a href="#更新一致性（写入冲突和读写冲突）" class="headerlink" title="更新一致性（写入冲突和读写冲突）"></a>更新一致性（写入冲突和读写冲突）</h2><p>当两个客户端试图同时修改一份数据时，会发生“写入冲突”。而当某客户端在另一个客户端执行写入操作的过程中读取数据时，则会发生“读写冲突”。</p><ul><li>悲观方式以锁定数据记录来避免冲突<ul><li>“写入锁” (write lock)</li></ul></li><li>乐观方式则在事后检测冲突并将其修复：假设冲突的可能性很低，所以<strong>不会在更新前加锁或者检查数据的版本</strong>，而是在更新后检查是否有冲突发生，如果有则进行修复。<ul><li>“条件更新”( conditional update)，任意客户在执行更新操作之前，都要先测试数据的当前值和其上一次读入的值是否相同。如果数据的当前值和旧值不匹配，说明有其他客户端修改了数据，那么更新就会失败，否则更新就会成功</li><li>保存冲突数据 。用户自行“合并”(merge)或 “自动合并”（面向特定领域），用于分布式版本控制系统</li></ul></li></ul><p>并发编程涉及一个根本问题，那就是<strong>在安全性（避免“更新冲突”之类的错误）与响应能力(liveness，快速响应客户操作）之间权衡</strong>。“<strong>悲观方式”通常会大幅降低系统响应能力，以致无法满足需求</strong>。而且它还有出错的危险:采用“悲观方式”处理并发问题，<strong>通常会导致“死锁”</strong>( deadlock)，这一情况既难于防范，也不易调试。</p><blockquote><p>保存冲突数据是一种修复冲突的方法，它<strong>不会覆盖或者丢弃任何客户端的更新，而是将冲突的数据都保存下来，让用户自己决定如何合并</strong>。例如，如果两个客户端同时修改了一个文档的不同部分，那么保存冲突数据的方法就会将两个版本的文档都保留下来，让用户自己选择或者编辑合并后的文档。<br>“自动合并”是一种特殊的保存冲突数据的方法，它针对一些特定领域的数据，可以<strong>根据一些规则或者算法自动地合并冲突的数据</strong>。例如，如果两个客户端同时修改了一个购物车的内容，那么自动合并的方法就可以将两个版本的购物车合并成一个，包含了所有客户端添加或者删除的商品。</p></blockquote><h2 id="逻辑一致性"><a href="#逻辑一致性" class="headerlink" title="逻辑一致性"></a>逻辑一致性</h2><p>“图数据库”常常和关系型数据库一样，也支持ACID事务。<br />面向聚合的数据库通常支持“原子更新”( atomic update),但仅限于单一聚合内部 </p><ul><li><strong>“一致性” 可以在某个聚合内部保持，但在各聚合之间则不行</strong></li><li>在执行影响多个聚合的更新操作时，会留下一段时间空档，让客户端有可能在此刻读出逻辑不一致的数据</li><li><strong>存在不一致风险的时间长度就叫“不一致窗口”(inconsistency window)。</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686448888647-eb5f3018-7b01-45bf-8104-1eb8541669e9.png" alt="image.png"><br>上述例子中的一致性就叫<strong>“逻辑一致性”(logical consistency)<strong>，也就是要</strong>确保不同的数据项放在一起，其含义符合逻辑</strong>。<br />为了避免“读写冲突”造成的“逻辑不一致”，关系型数据库支持“<strong>事务</strong>”这一概念。<br />若是Martin<strong>将两个写入步骤封装到一个事务之中</strong>，则系统能够确保Pramod所读出的那两项数据，要么都是更新之前的值，要么都是更新之后的值。</p><h2 id="复制一致性"><a href="#复制一致性" class="headerlink" title="复制一致性"></a>复制一致性</h2><p>“复制一致性”(replication consistency)。要求从不同副本中读取同一个数据项时，所得到的值相同<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686400559738-e6b2ae92-28cd-48c9-9886-40ee5ddbb587.png" alt="image.png"></p><ul><li>在分布式系统中，<strong>如果某些节点收到了更新数据，而另外一些节点却尚未收到，那么这种情况就视为“读写冲突”</strong>。</li><li><strong>若写入操作已经传播至所有节点，则此刻的数据库就具备“最终一致性”( eventually consistent)</strong></li><li>复制不一致性带来的“不一致窗口”，在<strong>考虑网络环境</strong>后，会比单一节点导致的“不一致窗口”长的多</li><li>在任意时刻，<strong>节点中都可能存在“复制不一致”</strong>(replication inconsistency)问题，然而只要不再继续执行其他更新操作，那么<strong>上一次更新操作的结果最终将会反映到全部节点中去</strong>。过期的数据通常称为“陈旧”( stale）数据，这提醒我们：<strong>缓存也算一种“复制”形式</strong>，尤其在“主从式分布模型”中，更是如此。</li><li>不一致性窗口对应用的影响不同</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686449149871-4c6998a6-6f76-4034-991b-b4aad9da3cbd.png" alt="image.png"></p><h2 id="照原样读出所写内容的一致性"><a href="#照原样读出所写内容的一致性" class="headerlink" title="照原样读出所写内容的一致性"></a>照原样读出所写内容的一致性</h2><p>“照原样读出所写内容的一致性”(read-your-writes consistency) ，<strong>在执行完更新操作之后，要能够立刻看到新值。</strong><br />在具备“最终一致性” 的系统中，可以提供“会话一致性”( session consistency) :在用户会话内部保持“照原样读出所写内容的一致性”</p><ul><li>使用“黏性会话”(sticky session)，即绑定到某个节点的会话(这种性质也叫做“会话亲和力”，session affinity)。<ul><li>“黏性会话”可以保证，只要某节点具备“照原样读出所写内容的一致性”，那么与之绑定的会话就都具备这种特性了。</li><li>“黏性会话”的缺点是，它会降低“负载均衡器”( load balancer)的效能</li></ul></li><li>使用“版本戳”(version stamp)，并确保同数据库的每次交互操作中，都包含会话所见的最新版本戳。<strong>服务器节点在响应请求之前必须先保证，它所含有的更新数据包含此版本戳。</strong></li></ul><p>使用“黏性会话”和“主从复制”来保证“会话一致性”时，由于读取与写入操作分别发生在不同节点，那么想保证这一点会比较困难。</p><ul><li>方法一：将写入请求先发给从节点，由它负责将其转发至主节点，并同时保持客户端的“会话一致性”。</li><li>方法二：在执行写入操作时临时切换到主节点，并且在从节点尚未收到更新数据的这一段时间内，把读取操作都交由主节点来处理。</li></ul><h1 id="ch68-放宽“一致性”和“持久性”约束"><a href="#ch68-放宽“一致性”和“持久性”约束" class="headerlink" title="ch68 放宽“一致性”和“持久性”约束"></a>ch68 放宽“一致性”和“持久性”约束</h1><h2 id="放宽一致性约束"><a href="#放宽一致性约束" class="headerlink" title="放宽一致性约束"></a>放宽一致性约束</h2><h3 id="使用事务保障一致性"><a href="#使用事务保障一致性" class="headerlink" title="使用事务保障一致性"></a>使用事务保障一致性</h3><p>使用“事务”达成强一致性<br />引入放松“隔离级别” ( isolation level)的功能，以允许查询操作读取尚未提交的数据。</p><ul><li>读未提交，一个事务可以<strong>读取另一个未提交事务的数据</strong>。脏读</li><li>读已提交，一个事务要等另一个事务提交后才能读取数据。不可重复读</li><li>可重复读，在开始读取数据（事务开启）时，不再允许修改操作。幻读</li><li>可串行化，事务串行化顺序执行。严格一致性，效率是一个问题</li></ul><h3 id="事务的问题"><a href="#事务的问题" class="headerlink" title="事务的问题"></a>事务的问题</h3><p>在并发不大的前提下，是否需要事务<br /><strong>在数据较多的情况下，为了让应用性能符合用户要求，它们必须弃用“事务”</strong><br />尤其在需要引入分片机制时，更是如此<br />在分布式应用中，如事务的业务范围涉及多个以网络连接的参与者。<strong>其规模、复杂度和波动性均导致无法使用事务进行良好描述</strong></p><blockquote><p><strong>很多系统已经彻底弃用“事务”了，因为它们对性能的影响实在太大。</strong> 有两种不采用事务的使用方式。在数据规模较小的情况下，MySQL<br>比较流行，那时它还不支持事务处理。许多网站喜欢MySQL所带来的高速访问能力，并且不准备再使用事务了。在数据较多的情况下，像eBay Pritchett]这种非常大的网站，为了让网站性能符合用户要求，它们必须弃用“事务”，尤其在需要引入分片机制时，更是如此。就算没有这些限制，很多应用程序构建者也需要同远程系统交互，而那些系统无法合理地容纳于事务范围之内，所以说，在企业级应用程序中，经常需要更新事务范围之外的数据。</p></blockquote><h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>CAP定理:给定“一致性”(Consistency)、“可用性”(Availability)、“分区耐受性”( Partition tolerance) 这三个属性，我们只能同时满足其中两个属性。</p><ul><li>“一致性”</li><li>“可用性”，如果客户可以同集群中的某个节点通信，那么该节点就必然能够处理读取及写入操作。 </li><li>“分区耐受性” ，如果发生通信故障，导致整个集群被分割成多个无法互相通信的分区时(这种情况也叫“ 脑裂”，split brain)，集群仍然可用。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686453697771-d8cabf79-8452-4692-8527-950bbc931d18.png" alt="image.png"></p><h3 id="CA系统"><a href="#CA系统" class="headerlink" title="CA系统"></a>CA系统</h3><p>CA系统，也就是具备“一致性”(Consistency)与“可用性”(Availability)， 但却不具备“分区耐受性”的系统<br />大多数关系型数据库都是CA系统<br />CA集群</p><ul><li>无法保证“分区耐受性”，这使得一旦“分区”发生，所有节点必须停止运作</li><li>CAP中的，可用性定义为“系统中某个无故障节点所接收的每一条请求， 无论成功或失败，都必将得到响应。”</li><li>介于此时所有节点均为故障节点，不违反CAP中的“可用性”<blockquote><p>从理论上说，也存在“CA集群”。然而，这意味着，一旦集群中出现“分区”，所有节点都将无法运转，如此一来，客户端就无法与任意一个节点通信了。按照“可用性”一词的常规定义来看，该系统此时缺乏“可用性”，然而如果按照“CAP定理”中“可用性”一词的特殊含义来解释，则会令人困惑。“CAP定理”将“可用性”一词定义为“<strong>系统中某个无故障节点</strong>所接收的每一条请求，无论成功或失败，都必将得到响应。”[Lynch and Gilbert]。所以按照这个定义来看，<strong>发生故障且无法响应客户请求的节点，并不会导致系统失去“CAP定理”所定义的那种“可用性”。</strong></p></blockquote></li></ul><h3 id="CAP定理的现实含义"><a href="#CAP定理的现实含义" class="headerlink" title="CAP定理的现实含义"></a>CAP定理的现实含义</h3><p>尽管“CAP定理”经常表述为“三个属性中只能保有两个”，实际上当系统可能会遭遇“分区”状况时(比如分布式系统)，需要在“一致性”与“可用性”之间进行权衡。</p><ul><li>这并不是个二选一的决定，通常来说，我们都会略微舍弃“一致性”，以获取某种程度的“可用性”</li><li>这样的系统，既不具备完美的“一致性”，也不具备完美的“可用性”</li><li>但是能够满足需要</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="缺乏可用性"><a href="#缺乏可用性" class="headerlink" title="缺乏可用性"></a>缺乏可用性</h4><p>假设Martin与Pramod都想预订某旅馆的最后一间客房，预订系统使用“对等式分布模型”，它由两个节点组成Martin 使用位于伦敦的节点，而Pramod使用位于孟买的节点。若要确保一致性，那么当Martin要通过位于伦敦的节点预订房间时，<strong>该节点在确认预订操作之前，必须先告知位于孟买的节点。</strong><br /><strong>两个节点必须按照相互一致的顺序来处理它们所收到的操作请求</strong><br />此方案保证了“一致性”，但是假如网络连接发生故障，那么由故障导致的两个“分区”系统，就都无法预订旅馆房间了，于是系统失去了“可用性”。</p><h4 id="改善可用性"><a href="#改善可用性" class="headerlink" title="改善可用性"></a>改善可用性</h4><p>指派其中一个节点作为某家旅馆的“主节点”，确保所有预订操作都由“主节点”来处理。</p><ul><li>假设位于孟买的节点是“主节点”，那么在两个节点之间的网络连接发生故障之后，它仍然可以处理该旅馆的房间预订工作，这样Pramod将会订到最后一间客房</li><li>位于伦敦的用户看到的房间剩余情况会与孟买不一致，但是他们无法预订客房，于是就出现了“更新不一致”现象。</li><li>Martin<strong>可以和位于伦敦的节点通信，但是该节点却无法更新数据。</strong></li></ul><p>于是出现了“可用性”故障(availability failure)<br>这种在<strong>“一致性”与“可用性”之间所做的权衡</strong>，能正确处理上述特殊状况。</p><h4 id="进一步改善"><a href="#进一步改善" class="headerlink" title="进一步改善"></a>进一步改善</h4><p><strong>让两个“分区”系统都接受客房预订请求，即使在发生网络故障时也如此。</strong><br />这种方案的风险是，Martin和Pramod有可能都订到了最后一间客房。然而，根据这家旅馆的具体运营情况，这也许不会出问题：</p><ul><li>通常来说，旅行公司都允许一定数量的超额预订，这样的话，如果有某些客人预订了房间而最终没有人住，那么就可以把这部分空余房间分给那些超额预订的人了</li><li>与之相对，某些旅馆总是会在全部订满的名额之外多留出几间客房，这样万一哪间客房出了问题，或者在房间订满之后又来了一位贵宾，那么旅馆可以把客人安排到预留出来的空房中</li><li>还有些旅馆甚至选择在发现预订冲突之后向客户致歉并取消此预订。</li></ul><p><strong>该方案所付出的代价，要比因为网络故障而彻底无法预订的代价小。</strong></p><h4 id="写入不一致"><a href="#写入不一致" class="headerlink" title="写入不一致"></a>写入不一致</h4><p>购物车是允许“写入不一致”现象的一个经典示例</p><ul><li>即使网络有故障，也总是能够修改购物车中的商品。</li><li>这么做有可能导致多个购物车出现</li><li>而结账过程则会将两个购物车合并，具体做法是，将两个购物车中的每件商品都拿出来，放到另外一个购物车中，并按照新的购物车结账。</li><li>这个办法基本上不会出错，万一有问题，客户也有机会在下单之前先检视一下购物车中的东西。</li></ul><h3 id="一致性与延迟的取舍"><a href="#一致性与延迟的取舍" class="headerlink" title="一致性与延迟的取舍"></a>一致性与延迟的取舍</h3><p>在权衡分布式数据库的“一致性”时，与其考虑如何权衡“一致性”与“可用性”，不如思考怎样在“一致性”与“延迟”(latency)之间取舍。</p><ul><li>参与交互操作的节点越多，“一致性”就越好</li><li>然而，<strong>每新增一个节点，都会使交互操作的响应时间变长</strong></li><li><strong>“可用性”可以视为能够忍受的最大延迟时间，一旦延迟过高，我们就放弃操作，并认为数据不可用</strong></li><li>这样一来，就和“CAP定理”对“可用性”所下的定义相当吻合了</li></ul><h2 id="放宽持久性约束"><a href="#放宽持久性约束" class="headerlink" title="放宽持久性约束"></a>放宽持久性约束</h2><p>“一致性”的关键在于，将请求序列化，使之成为原子的（Atomic)、相互隔离的(Isolated)“工作单元”( work unit)。<br />“持久性”：如果某个数据库大部分时间都在内存中运行，更新操作也直接写入内存，并且定期将数据变更写回磁盘，那么，它就可以<strong>大大提高响应请求的速度</strong>了。这种做法的代价在于，一旦服务器发生故障，<strong>任何尚未写回磁盘的更新数据都将丢失</strong>。</p><h3 id="持久性权衡"><a href="#持久性权衡" class="headerlink" title="持久性权衡"></a>持久性权衡</h3><p>数据库大部分时间都在内存中运行，更新操作也直接写入内存，并且定期将数据变更写回磁盘</p><ul><li>可以大大提高响应请求的速度。</li><li>代价在于，一旦服务器发生故障，任何尚未写回磁盘的更新数据都将丢失。</li></ul><p>多用户的“会话状态”信息会话</p><ul><li>数据就算丢失，与应用系统效率相比，也不过是个小麻烦。这时可以考虑非持久性写入操作”(nondurable write)。</li><li><strong>可以在每次发出请求时，指定该请求所需的持久性</strong>。从而，把某些极为重要的更新操作立刻写回磁盘。</li></ul><p>捕获物理设备的遥测数据(telemetric data)。就算最近的更新数据可能会因为服务器发生故障而丢失，也还是选择把快速捕获数据放在首位。</p><h3 id="分布模型中“持久性”的权衡"><a href="#分布模型中“持久性”的权衡" class="headerlink" title="分布模型中“持久性”的权衡"></a>分布模型中“持久性”的权衡</h3><p><strong>如一个节点处理完更新操作之后，在更新数据尚未复制到其他节点之前就出错了，那么则会发生“复制持久性”(replication durability) 故障。</strong><br />假设有一个采用“主从式分布模型”的数据库，在其主节点出错时，它会自动指派一个从节点作为新的主节点。</p><ul><li>若主节点发生故障，则所有还未复制到其他副本的写入操作就都将丢失</li><li>一旦主节点从故障中恢复过来，那么，<strong>该节点上的更新数据就会和发生故障这段时间内新产生的那些更新数据相冲突</strong></li><li>我们把这视为一个“持久化”问题，因为主节点既然已经接纳了这个更新操作，那么用户自然就会认为该操作已经顺利执行完，但实际上，这份更新数据却因为主节点出错而丢失了</li></ul><p>解决方案：</p><ol><li>不重新指派新的主节点<ol><li>在主节点出错之后迅速将其恢复</li></ol></li><li>确保主节点在收到某些副本对更新数据的确认之后，再告知用户它已接纳此更新<ol><li>从节点发生故障时，集群不可用</li><li>拖慢更新速度</li></ol></li></ol><p>与处理“持久性”的基本手段类似，也可以针对单个请求来指定其所需的持久性。</p><h1 id="ch69-仲裁"><a href="#ch69-仲裁" class="headerlink" title="ch69 仲裁"></a>ch69 仲裁</h1><h2 id="写入仲裁"><a href="#写入仲裁" class="headerlink" title="写入仲裁"></a>写入仲裁</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1685600701236-c47daadf-1623-4b4f-a9e6-f74098fbb9fc.png" alt="image.png"></p><h2 id="读取仲裁"><a href="#读取仲裁" class="headerlink" title="读取仲裁"></a>读取仲裁</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1685600681818-dfc3bf76-dbb6-45fb-b340-0e12ca259120.png" alt="image.png"><br>想要知道更好的一致性，需要访问更多的节点<br />想要更好的可用性，需要越方便越好<br />R &gt; N - W &#x3D; 还没有来得及更新的节点数</p><h2 id="复制因子"><a href="#复制因子" class="headerlink" title="复制因子"></a>复制因子</h2><p>复制因子不大于节点数，是为了“集群”<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1685600847358-5105dfb0-01d6-45e2-b9f4-fa9911caf576.png" alt="image.png"><br>3个节点如果有一个出错，还有一个节点可以读，一个节点可以写<br />如果一次性出错2个，那么就无法读和写了。<br />如果设置复制因子为7，可允许出错的节点增加，但是执行速度变低</p><h2 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1685601227647-4245f64f-b8a4-4948-8690-280515f402ea.png" alt="image.png"><br>R和W总是相互平衡的</p><h1 id="ch70-版本戳"><a href="#ch70-版本戳" class="headerlink" title="ch70 版本戳"></a>ch70 版本戳</h1><p>AT：原子性事务-绝大数是用来避免错误，进行回滚。如果某些事务占据资源多，占用时间长，会阻碍并发。<br />BA：商业活动<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1685601929965-7e11b7ae-931b-4226-85a3-0156b2010c8a.png" alt="image.png"><br>用业务流程上的补充完成“回滚”，而不是像事务一样all or nothing-在数据库的支持下完成回滚</p><h1 id="ch71-键值数据库"><a href="#ch71-键值数据库" class="headerlink" title="ch71 键值数据库"></a>ch71 键值数据库</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>键值数据库(key-value store)是一张简单的哈希表(hash table)，<strong>主要用在所有数据库访问均通过主键(primary key)来操作的情况下</strong>。</p><ul><li>可把此表想象成传统的“关系” 该关系有两列：ID与NAME</li><li>ID列代表关键字，NAME列存放值。NAME列仅能存放String型的数据。</li><li>应用程序可提供ID及VALUE值，并将这一键值对持久化</li><li>假如ID已存在，就用新值覆盖当前值，否则就新建一条数据。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686463644155-cde46025-5555-4c2f-a51c-57f131aafeb5.png" alt="image.png"></p><ul><li>键值数据库是最简单的NoSQL数据库。</li><li>客户端可以根据键查询值，设置键所对应的值，或从数据库中删除键。</li><li><strong>“值”只是数据库存储的一块数据而已，它并不关心也无需知道其中的内容</strong></li><li><strong>应用程序负责理解所存数据的含义</strong>。</li><li>由于<strong>键值数据库总是通过主键访问</strong>，所以它们一般性能较高，且易于扩展。</li></ul><p>流行的键值数据库有:Riak、Redis（数据结构服务器）、 Memcached DB及其变种、Berkeley DB、HamsterDB (尤其适合嵌入式开发) 、 Amazon DynamoDB (不开源)和Project Voldemort (Amazon DynamoDB的开源实现)。</p><h2 id="数据结构服务器"><a href="#数据结构服务器" class="headerlink" title="数据结构服务器"></a>数据结构服务器</h2><ul><li>在键值数据库中，<strong>所存储的聚合不一定是领域对象(domain object)，也可以拥有通用数据结构</strong></li><li>Redis能够<strong>存储list、set、hash 等数据结构</strong>，可以支持“获取某个范围内的数值”(range)、“求差集”(diff)、“求并集”( union)、 “求交集”( intersection) 等操作</li><li>这些功能使数据库的用途变得比标准键值数据库更多</li></ul><h2 id="单一存储区"><a href="#单一存储区" class="headerlink" title="单一存储区"></a>单一存储区</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686463794947-c295ced0-f6e5-4546-b477-5b192e5e56c1.png" alt="image.png"><br>将各类对象(也就是聚合)全部存放在一个“存储区”中，其缺点是：<strong>“存储区”中可能要存放类型不同的多个聚合，这增加了关键字冲突的几率</strong></p><blockquote><p>如果一个存储区中既有用户聚合，又有订单聚合，那么<strong>可能出现用户ID和订单ID相同的情况，这就导致了关键字冲突。关键字冲突会影响数据的正确性和一致性</strong>，因为通过键查询时，可能返回错误的或多余的数据。为了避免关键字冲突，可以采用以下一些方法：</p><ul><li>为不同类型的聚合使用不同的命名空间或前缀，例如 user:123 和 order:123。</li><li>为键生成全局唯一的标识符（GUID），例如 8f14e45f-ea4d-439a-8da3-cb556e7c9b53。</li><li>为存储区设置唯一性约束或主键约束，防止插入重复的键。</li></ul></blockquote><p>还有一种办法是把对象名放在键名后面，例如：288790b8a421_ userProfile， 这样就可用它查出所需的单个对象了<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686463927030-4889a661-904b-4449-b1a9-0631b324fe83.png" alt="image.png"></p><h2 id="领域存储区"><a href="#领域存储区" class="headerlink" title="领域存储区"></a>领域存储区</h2><p>“领域存储区”(domain bucket)来存放特定数据<br />客户端驱动程序可以对其执行“序列化”(serialization) 与“反序列化”(deserialization) 操作将跨越多个“存储区”的数据分割成对象，将之存放在“领域存储区”或不同的“存储区”中，这样一来，无需改变关键字的命名方式，即可读出所需对象<br />存放表达相同含义的不同聚合方案，以应对多种不同应用的需求<br />效率及数据不一致性问题</p><blockquote><p>领域存储区中的数据可以是复杂的对象，而不仅仅是简单的键值对。<br>对象可以包含多个属性和关联，这些属性和关联可能分布在不同的存储区中。</p><p>为了在存储和读取对象时，保持对象的完整性和一致性，客户端驱动程序可以对对象进行序列化和反序列化的操作。</p><p><strong>序列化是指将对象转换为字节流或字符串的过程，反序列化是指将字节流或字符串还原为对象的过程。</strong></p><p>举例来说，如果一个电商公司的键值数据库中有一个领域存储区，用于存放用户对象。<br>用户对象包含用户ID、用户名、密码、邮箱、收货地址等属性，以及与订单、商品等其他对象的关联。<br>这些属性和关联可能分散在不同的存储区中，例如用户ID和用户名在一个存储区，密码和邮箱在另一个存储区，收货地址在第三个存储区，订单和商品在第四个存储区等。<br>当客户端驱动程序要将一个用户对象存入数据库时，它可以<strong>对用户对象进行序列化，将其转换为一个字节流或字符串，然后根据一定的规则，将其分割成多个键值对，分别存放在不同的存储区中。</strong><br>当客户端驱动程序要从数据库中读取一个用户对象时，它可以根据用户ID或其他标识符，<strong>从不同的存储区中查询出相应的键值对，然后对其进行反序列化，将其还原为一个完整的用户对象。</strong></p></blockquote><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>只有针对单个键的操作才具备“一致性”，因为这种操作只可能是“获取”、“设置”或“删除”。<br />由于数据库无法侦测数值改动， “乐观写入”(optimistic write)功能的实现成本太高。<br />分布式键值数据库，用“最终一致性模型” 实现“一致性”。<br />两种解决“更新冲突”的办法:</p><ol><li>采纳新写入的数据而拒绝旧数据</li><li>将两者(或存在冲突的所有数据)返回给客户端，令其解决冲突</li></ol><p>在创建“存储区”时设置与一致性有关的选项。</p><ul><li>若想<strong>提高数据一致性</strong>, 可以规定：执行完写入操作后，<strong>只有当存放此数据的全部节点一致将其更新，才认定该操作生效。</strong><ul><li>显然降低了集群的写入效率</li></ul></li><li>若想<strong>提高写入冲突或读取冲突的解决速度</strong>，可在创建“存储区”时设置为<strong>数据库接纳最新的写入操作，而不再创立“旁系记录”(sibling)</strong> 。</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>不同类型的键值数据库，其“事务”规范也不同，实现“事务”的方式各异。<br />一般说来，无法保证写入操作的“一致性”。<br />Riak在调用写入数据的API时，它使用W值与复制因子来实现“仲裁”。<br />假设某个集群的复制因子是5，而W值为3。<br /><strong>在写入数据时，必须有至少3个节点汇报其写入操作已顺利完成，数据库才会认为此操作执行完毕。</strong><br />由于N等于5而W是3，所以集群在两个节点(N-W&#x3D;2) 故障时仍可执行写入操作，不过，此时我们无法从那些发生故障的节点中读取某些数据。</p><h2 id="查询功能"><a href="#查询功能" class="headerlink" title="查询功能"></a>查询功能</h2><p>所有键值数据库都可以按关键字查询。它们的查询功能基本上仅限于此。<br />如果希望根据“值列”(value column)的某些属性来查询，那么无法用数据库完成此操作<br />应用程序需要自己读出值，并判断其属性是否符合查询条件。</p><blockquote><p>订单ID作为键，订单对象作为值，存放在一个键值对中。如果希望根据订单ID来查询订单对象，那么可以直接用键值数据库完成此操作，只需要输入订单ID，就可以快速地返回对应的订单对象。但是，<strong>如果希望根据订单对象的某些属性来查询</strong>，例如查询总价大于1000元的订单，或者查询下单时间在某个时间段内的订单，<strong>那么无法用键值数据库完成此操作。应用程序需要自己读出所有的订单对象，并判断其属性是否符合查询条件，这样做会消耗大量的时间和资源。</strong></p></blockquote><p>如果不知道关键字该怎么办?</p><ul><li>大部分数据库都不提供全部主键列表，即便提供了，获取关键字列表并查询其值的操作也很烦琐</li><li>某些键值数据库支持数值搜寻，以解决此问题</li><li>通过API、HTTP（浏览器、Curl等），操作键值数据库</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686466318320-111817b9-f2cb-46f0-926e-d8f70acd5a6d.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686466278546-a1da9e01-a1ba-4c50-a4b5-10fc551db031.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686466287101-23d9d0a9-1266-42cf-841c-cfb1522ade9c.png" alt="image.png"></p><h2 id="键名的设计"><a href="#键名的设计" class="headerlink" title="键名的设计"></a>键名的设计</h2><p>使用键值数据库时，通过某种算法生成键</p><ul><li>使用用户信息(例如ID、电子邮件地址等)、时间戳等值，生成键</li></ul><p>键值数据库非常适合保存会话(用会话ID作为键)、购物车数据、用户配置等信息</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>键值数据库并不关心键值对里的值。它可以是二进制块、文本、JSON、XML等。<br />可在HTTP请求中用Content-Type指定数据类型<br />实质上是由应用判定其内容</p><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>很多键值数据库都可用“分片”技术扩展。采用此技术后，键的名字就决定了负责存储该键的节点。</p><ul><li>假设按照键名的首字母“分片”。如果键名是f4b19d79587d，那么由于其首字母为f,所以存放它的节点就与存放ad9c7a396542这个键的节点不同。</li><li>当集群中的节点数变多时，这种“分片”设定可提高效率。</li></ul><p>“分片”也会引发某些问题。假如存放首字母为f的键所用的那个节点坏了，那么其上的数据将无法访问，而且也不能再写入其他键名首字母为f的新数据了。</p><p>可以控制“CAP定理” 中的参数: **N (存放键值对的副本节点数)、R (顺利完成读取操作所需的最小节点数)和W (顺利完成写入操作所需的最小节点数)**。</p><ul><li>假设集群有5个节点。将N设为3，意思就是<strong>所有数据都至少要复制到3个节点中</strong>，将R设为2，意思是<strong>GET请求要有两个节点应答</strong>，才能成功，将W设为2,意思是<strong>PUT请求必须写入两个节点</strong>，才算执行完毕。</li></ul><p>可以利用这些设置来微调读取及写入操作所能容忍的故障节点数。应该按照应用的需要来改变这些值，以**提升数据库的“可读能力”(read availability) 及“可写能力”(write availability)**。通常应该根据“一致性”需求来确定W值。<br />创建“存储区”时可设定上述各参数的默认值。</p><h2 id="适用案例"><a href="#适用案例" class="headerlink" title="适用案例"></a>适用案例</h2><h3 id="存放会话信息"><a href="#存放会话信息" class="headerlink" title="存放会话信息"></a>存放会话信息</h3><p>通常来说，每一次网络会话都是唯一的，所以分配给它们的sessionid值也各不相同。<br />如果应用程序原来要把sessionid存在磁盘上或关系型数据库中，那么将其迁移到键值数据库之后，会获益良多</p><ul><li>因为全部会话内容都可以用一条PUT请求来存放，而且只需一条GET请求就能取得。</li><li>由于会话中的<strong>所有信息都放在一个对象</strong>中，所以这种“<strong>单请求操作</strong>”(single-request operation) 很迅速。<blockquote><p><strong>网络会话是指用户与服务器之间的一次交互过程，从用户发起请求到服务器返回响应为止。网络会话可以用来保存用户的状态信息</strong>，例如登录状态、购物车内容、浏览历史等。为了实现网络会话，服务器会给每个用户分配一个唯一的标识符，称为sessionid，通常会通过cookie或URL参数的方式传递给用户。用户在每次请求时，都会带上sessionid，以便服务器识别用户的身份和状态</p></blockquote></li></ul><h3 id="用户配置信息"><a href="#用户配置信息" class="headerlink" title="用户配置信息"></a>用户配置信息</h3><p>用户配置信息，几乎每位用户都有userId、username或其他独特的属性，而且其配置信息也各自独立，诸如语言、颜色、时区、访问过的产品等。<br /><strong>这些内容可全部放在一个对象里，以便只用一次GET操作即获取某位用户的全部配置信息。</strong><br />同理，产品信息也可如此存放。</p><h3 id="购物车数据"><a href="#购物车数据" class="headerlink" title="购物车数据"></a>购物车数据</h3><p>购物车数据，电子商务网站的用户都与其购物车相绑定。<br />由于购物车的内容要在不同时间、不同浏览器、不同电脑、不同会话中保持一致，所以可把购物信息放在value属性中，并将其绑定到userid这个键名上。</p><h2 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h2><ul><li>数据间关系<ul><li>如果要<strong>在不同数据集之间建立关系，或是将不同的关键字集合联系起来</strong>，那么即便某些键值数据库提供了“链接遍历”等功能，它们也不是最佳选择。</li></ul></li><li>含有多项操作的事务<ul><li>如果在保存多个键值对时，<strong>其中有一个关键字出错，而又需要复原或回滚其余操作</strong>，那么键值数据库就不是最好的解决方案。</li></ul></li><li>查询数据<ul><li>如果要根据键值对的某部分值来搜寻关键字，那么键值数据库就不是很理想了。我们**无法直接检视键值数据库中的值，除非使用某些“检索引擎”(indexing engine)**。</li></ul></li><li>操作关键字集合<ul><li>由于键值数据库一次只能操作一个键，所以它<strong>无法同时操作多个关键字</strong>。假如需要操作多个关键字，那么最好在客户端处理此问题。</li></ul></li></ul><h1 id="ch72-文档数据库"><a href="#ch72-文档数据库" class="headerlink" title="ch72 文档数据库"></a>ch72 文档数据库</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>“文档”( document)是文档数据库中的主要概念。</p><ul><li>其格式可以是XML、JSON、BSON等。</li><li>文档具备自述性(self-describing)，呈现分层的树状数据结构(hierarchical tree data structure)，可以包含映射表、集合和标量值。</li></ul><p>文档彼此相似，但不必完全相同。<br /><strong>文档数据库所存放的文档，就相当于键值数据库所存放的“值”</strong>。<br /><strong>文档数据库可视为其值可查的键值数据库</strong>。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686466602911-cbbb67ee-afc3-42de-bb86-65039b49d502.png" alt="image.png"></p><ul><li><strong>文档数据库中，放在同一“集合”内的各文档的“数据模式”(the schema of the data)可以不同</strong></li><li>关系型数据库中，表格中每行数据的模式都要相同。</li></ul><p>文档中可以嵌套数组等基本数据类型，也可以将“子文档”(child document) 以“子对象”(subobject) 的形式嵌入主文档。</p><ul><li><strong>由于没有“数据模式”约定，文档数据库的文档中无需空属性，若其中不存在某属性，就假定该属性值未设定或与此文档无关。向文档中新增属性时，既无需预先定义，也不用修改已有文档内容。</strong></li><li>关系型数据库中，需要定义表中的每一列，而且若某条记录中的某列没有数据，则要将其留空(empty) 或设为null。</li></ul><p>流行的文档数据库有: MongoDB、 CouchDB、Terrastore、OrientDB、RavenDB和Lotus Notes。</p><h2 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h2><p>通过配置“副本集”(replica set) 实现“复制”，以提供较高的“可用性”<br /><strong>规定写入操作必须等待所写数据复制到全部或是给定数量的从节点之后，才能返回。从而指定数据库的“一致性”强度。</strong></p><ul><li>在只有一台服务器时如果指定w为“majority”，那么写入操作立刻就会返回，因为总共只有一个节点。</li><li>假设“副本集”中有三个节点，则写入操作必须在至少两个节点上执行完毕，才会视为成功</li><li><strong>提升w值可以增强“一致性”，但是会降低写入效率，因为写入操作必须在更多的节点上完成才行。</strong></li><li>也可以增加“副本集”的读取效率:设置slaveOk选项之后，就可以于从节点中读取数据了。</li><li>参数既可设置到整个”连接”、“数据库”、“集合”之上，也可针对每项操作独立设置。</li></ul><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><p>从传统的关系型数据库角度讲，“事务”一词意味着我们可以先用insert、update或delete等命令操作不同的表，然后<strong>用commit提交修改或以rollback命令回滚</strong>。<strong>NoSQL数据库通常没有这些机制:其写入操作要么成功，要么失败。</strong><br />“单文档级别”(single-documentlevel）的“事务”叫做“原子事务”( atomic transaction)。<br /><strong>可以用不同级别的WriteConcern参数来确保各种安全级别的写入操作</strong></p><ul><li>在默认情况下，所有写入操作都将顺利执行。</li><li>以WriteConcern.REPLICAS_SAFE为参数写入,即可确保该操作至少要写入两个节点才算成功。</li><li>在写日志条目(log entry)时，就可使用最低的安全级别，也就是WriteConcern.NONE。</li></ul><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p><strong>文档数据库可以用主从式数据复制技术来增强“可用性”</strong>。多个节点都保有同一份数据，即便主节点故障，客户端也依然能获取数据。应用程序代码一般不需检测主节点是否可用。<br />MongoDB通过“副本集”实现“复制”，以提供较高的“可用性”。副本集中至少有两个节点参与“异步主从式复制”(asynchronous master-slave replication)。</p><ul><li>“副本集”通常用于处理“数据冗余”( data redundancy)、“自动故障切换”( automated failover)、 “读取能力扩展”(read scaling)、“无需停机的服务器维护( server maintenance without downtime)和“灾难恢复”(disaster recovery)等事项。</li></ul><p><strong>应用程序的写入或读取操作都针对主节点。</strong>建立连接后，<strong>应用程序只需要同“副本集”中的一个节点相连即可(是不是主节点无所谓)，数据库会自动找到其余节点。</strong>若主节点故障，则数据库驱动会同“副本集”中新选出的主节点联系。应用程序不用处理通信错误，也无需干预主节点的选拔准则。<br /><strong>副本集在其内部选举“主”(master)节点，或 “主要”(primary)节点。</strong>假定所有节点投票权相同，其中某些节点可能会因为**距离其他服务器较近，或具有更多运行内存(RAM)**等因素而获得更多选票。用户也可以为节点指定一个值在0 ~ 1000之间的优先级( priority)来影响选举过程。<br /><strong>所有请求都由主节点处理，而其数据会复制到从节点。</strong>若主节点故障，则“副本集”中剩下的节点就会在其自身范围内选出新的主节点，所有后续请求就交由新的主节点处理，从节点也开始从新的主节点处获取数据。<br />当原来的主节点从故障中恢复时，它会作为从节点重新加入，并获取全部最新数据，以求与其他节点一致。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686468851573-162962f3-79cc-42a8-93ac-e6f4e9748334.png" alt="image.png"><br>（副本集内部也有自己的主节点）</p><h2 id="查询功能-1"><a href="#查询功能-1" class="headerlink" title="查询功能"></a>查询功能</h2><p>文档数据库可以查询文档中的数据，而不用像键值数据库那样，必须根据关键字获取整个文档，然后再检视其内容。<br />CouchDB:可用“物化视图”(materialized view)或“动态视图”(dynamic view)实现复杂的文档查询。<br />MongoDB支持一种JSON格式的查询语言由于文档是“聚合对象”(aggregated object)，所以用带子对象的字段查询待匹配的文档非常方便。</p><h2 id="可扩展性-1"><a href="#可扩展性-1" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>在不将数据库进行迁移的前提下，向其中新增节点或修改其内容。<br /><strong>增加更多的“读取从节点”(read slave)，将读取操作导引至从节点上，这样就可以扩展数据库应对频繁读取的能力了。</strong><br />假设某个应用程序的读取操作很频繁，可向“副本集”中加入更多从节点，并<strong>在执行读取操作时设定slaveOk标志，以提升集群的读取能力。完成读取操作的横向扩展。</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686469017744-8efd4856-8e45-47ec-b75c-7ff2e0cbb80f.png" alt="image.png"><br>如果想扩展写入能力，可以把数据“分片” 。<br />“分片”与关系型数据库的“分区”类似， </p><ul><li><strong>“分区”是根据某列的值，例如状态或年份，将数据分割开。</strong>关系型数据库的“分区”通常位于同一节点，所以客户端应用程序只查询“基表”(base table)就好，不需查询某个特定分区，关系型数据库会根据查询内容搜索适当的分区并返回数据。</li><li>“分片”操作也根据特定字段来划分数据，然而那些数据要移动到不同的Mongo节点中。为了让各“分片”的负载保持均衡，需要在节点之间动态转移数据。<strong>向集群中新增更多节点，并提高可写入的节点数，就能横向扩展其写入能力。</strong></li></ul><p>“分片”的关键字很重要。</p><ul><li><strong>按照客户名字(first name)来分隔，可确保将数据平衡地散布在各个“分片”上，以获得较好的写入效率。</strong></li><li>如果想把 “分片”放在距离用户近的地方，那么可以<strong>以用户位置来分片</strong>。按客户位置分片时，美国东海岸的全部用户数据都会放在居于东海岸的“分片”中，而所有西海岸的用户数据则将放在位于西海岸的“分片”中。</li></ul><p>可以把每个”分片”都做成“副本集”，以提高其读取效率。<br />如果向已有的“分片集群”(sharded cluster)中再加一个新分片”，就可以把原来分布在3个“分片”中的数据打散到4个“分片”中。<br />在转移数据与底层设施重构的全过程中，虽说集群为了重新平衡“分片”负载而传输大量数据时性能也许会下降，但是应用程序却无需停止工作。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1686469132410-b115967e-6ed4-4b39-b1b5-3f556165f38f.png" alt="image.png"><br>:::danger<br>分片和副本集有什么异同<br>:::</p><h2 id="适用案例-1"><a href="#适用案例-1" class="headerlink" title="适用案例"></a>适用案例</h2><h3 id="事件记录"><a href="#事件记录" class="headerlink" title="事件记录"></a>事件记录</h3><ul><li>在企业级解决方案中，许多不同的应用程序都需要记录事件。应用程序对事件记录各有需求。</li><li>文档数据库可以把所有这些不同类型的事件都存起来，并作为事件存储的“中心数据库”(central data store)使用。</li><li>如果事件捕获的数据类型一直在变，那么就更应该用文档数据库了。</li><li>可以按照触发事件的应用程序名分片，也可以按照order_processed或customer_logged等事件类型“分片”</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>内容管理系统及博客平台</li></ul><p>由于文档数据库没有“预设模式”(predefined schema)，而且通常支持JSON文档，所以它们很适合用在“内容管理系统”(content management system)及网站发布程序上，也可以用来管理用户评论、用户注册、用户配置和面向Web文档(web-facing document)。</p><ul><li>网站分析与实时分析</li></ul><p>文档数据库可存储实时分析数据。由于可以只更新部分文档内容，所以用它来存储“页面浏览量”(page view)或“独立访客数”( unique visitor)会非常方便，而且无需改变模式即可新增度量标准。</p><ul><li>电子商务应用程序</li></ul><p>电子商务类应用程序通常需要较为灵活的模式，以存储产品和订单。同时，它们也需要在不做高成本数据库重构及数据迁移的前提下进化其数据模型。</p><h2 id="不适用场合-1"><a href="#不适用场合-1" class="headerlink" title="不适用场合"></a>不适用场合</h2><ul><li><strong>包含多项操作的复杂事务</strong></li></ul><p>文档数据库也许不适合执行“跨文档的原子操作”(atomic cross-document operation)，虽然像RavenDB等文档数据库其实也支持此类操作。</p><ul><li><strong>查询持续变化的聚合结构</strong></li></ul><p>灵活的模式意味着数据库对模式不施加任何限制。数据以“应用程序实体”(application entity)的形式存储。<br /><strong>如果要即时查询这些持续改变的实体，那么所用的查询命令也得不停变化</strong>(用关系型数据库的术语讲，就是:用JOIN语句将数据表按查询标准连接起来时，待连接的表一直在变)。<br />由于数据保存在聚合中，所以假如聚合的设计持续变动，那么就需要以“最低级别的粒度”( lowest level of granularity)来保存聚合了，这实际上就等于要统一数据格式了。在这种情况下，文档数据库也许不合适。</p><h1 id="ch73-列族数据库"><a href="#ch73-列族数据库" class="headerlink" title="ch73 列族数据库"></a>ch73 列族数据库</h1><h1 id="ch74-图数据库"><a href="#ch74-图数据库" class="headerlink" title="ch74 图数据库"></a>ch74 图数据库</h1>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>题型</title>
      <link href="/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E9%A2%98%E5%9E%8B/"/>
      <url>/2023/06/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E9%A2%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>选择：基本概念<br />问答：</p><ol><li>两道nosql：<ol><li>nosql干嘛了，和sql之间的关系，如何想到nosql的</li><li>四个nosql的用法，上下文</li></ol></li><li>关系代数：关系代数和sql是耦合再一起的，会sql就得会关系代数</li></ol><p>综合题：<br />3*10</p><ol><li>ER题</li><li>sql：给定条件，写出sql语句</li><li>标准化，规范化，给你一堆依赖条件，问是x范式的，向更高范式转变</li></ol><p>写在考后：</p><ol><li>考试的选择题不是很难，但考察的多是容易误导的地方，或者摸棱两可的地方</li><li>可以多做一下习题书里面的补充习题，会有惊喜╰(<em>°▽°</em>)╯</li></ol><p>写给自己：<br>不要在意一时的得失，太阳会在第二天照常升起</p>]]></content>
      
      
      <categories>
          
          <category> 数据管理基础 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一章 - 计算机操作系统概述</title>
      <link href="/2023/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20-%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20-%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>CTSS：compatible Time-Sharing System</li><li>MULTICS：Multiplexed Infomation and Computing System 多任务系统</li></ul><h2 id="深入观察操作系统"><a href="#深入观察操作系统" class="headerlink" title="深入观察操作系统"></a>深入观察操作系统</h2><h3 id="资源管理的视角"><a href="#资源管理的视角" class="headerlink" title="资源管理的视角"></a>资源管理的视角</h3><h4 id="计算机系统的资源"><a href="#计算机系统的资源" class="headerlink" title="计算机系统的资源"></a>计算机系统的资源</h4><p>硬件资源<br />处理器、内存、外设<br />信息资源<br />数据、程序</p><h4 id="管理的视角"><a href="#管理的视角" class="headerlink" title="管理的视角"></a>管理的视角</h4><ul><li>处理器资源：那个程序占有处理器运行？</li><li>内存资源：程序&#x2F;数据在内存中如何分布？</li><li>设备管理：如何分配、去配和使用设备？ — IO设备等外设都是由操作系统统一管理，防止造成无序状态</li><li>信息资源管理：如何访问文件信息？</li><li>信号量资源：如何管理进程之间的通信</li></ul><h4 id="屏蔽资源使用的底层细节"><a href="#屏蔽资源使用的底层细节" class="headerlink" title="屏蔽资源使用的底层细节"></a>屏蔽资源使用的底层细节</h4><p>驱动程序：最底层的、直接控制和监视各类硬件(或文件)资源的部分<br />职责是隐藏底层硬件的具体细节，并向其他部分提供一个抽象的、通用的接口<br />比如说：打印一段文字或一个文件，既不需知道文件信息存储在硬盘上的细节，也不必知道具体打印机类型和控制细节</p><h4 id="资源的共享方式"><a href="#资源的共享方式" class="headerlink" title="资源的共享方式"></a>资源的共享方式</h4><p>独占使用方式（时分复用）<br />如：打印机在一个时间段内只能被一个进程独立使用<br />并发使用方式<br />如：一个文件可以同时被多个进程一起读</p><h4 id="资源分配策略"><a href="#资源分配策略" class="headerlink" title="资源分配策略"></a>资源分配策略</h4><ul><li>静态分配方式：进程运行前一次拿到全部独占资源<ul><li>资源使用效率低</li></ul></li><li>动态分配方式：使用资源前临时申请<ul><li>可能产生竞争资源的死锁</li><li>并发访问的难题-详见第六章</li></ul></li><li>资源抢占方式<ul><li>被抢夺资源的进程需要回滚执行</li></ul></li></ul><h3 id="控制程序执行的视角"><a href="#控制程序执行的视角" class="headerlink" title="控制程序执行的视角"></a>控制程序执行的视角</h3><h4 id="多道程序同时计算"><a href="#多道程序同时计算" class="headerlink" title="多道程序同时计算"></a>多道程序同时计算</h4><p>CPU速度与I&#x2F;O速度不匹配的矛盾，非常突出 – CPU以摩尔定律的速度发展，IO设备的速度受制于机械设备<br />只有让多道程序同时进入内存争抢CPU运行，才可以够使得CPU和外围设备充分并行，从而提高计算机系统的使用效率。关键是<strong>提高CPU的利用率</strong><br />并行：在同一个时间点有两个事件在同时发生。<br />并发：在某一个时间区间内，两件事情交替发生。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678072930218-d3ee2e36-9f55-482c-82ac-b5218ad941b2.png" alt="image.png"></p><h4 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h4><p>指让多个程序同时进入计算机的主存储器进行计算</p><h4 id="多道程序设计的特点"><a href="#多道程序设计的特点" class="headerlink" title="多道程序设计的特点"></a>多道程序设计的特点</h4><ul><li>CPU与外部设备充分并行</li><li>外部设备之间充分并行</li><li>发挥CPU的使用效率</li><li>提高单位时间的算题量 — 系统整体性能得到了优化</li><li>但是，单道程序的运算时间会增加</li></ul><h4 id="多道程序系统的实现"><a href="#多道程序系统的实现" class="headerlink" title="多道程序系统的实现"></a>多道程序系统的实现</h4><ul><li>为进入内存执行的程序建立管理实体：进程</li><li>OS应能管理与控制进程程序的执行</li><li>OS协调管理各类资源在进程间的使用<ul><li>处理器的管理和调度</li><li>主存储器的管理和调度</li><li>其他资源的管理和调度</li></ul></li></ul><h4 id="多道程序系统的实现要点"><a href="#多道程序系统的实现要点" class="headerlink" title="多道程序系统的实现要点"></a>多道程序系统的实现要点</h4><ul><li>如何使用资源：调用操作系统提供的服务例程(如何陷入操作系统)</li><li>如何复用CPU：调度程序(在CPU空闲时让其他程序运行)</li><li>如何使CPU与I&#x2F;O设备充分并行：设备控制器与通道(专用的I&#x2F;O处理器)</li><li>如何让正在运行的程序让出CPU：中断(中断正在执行的程序，引入OS处理)</li></ul><p><strong>内核是中断驱动的  Reactive</strong></p><h3 id="操作控制计算机的视角"><a href="#操作控制计算机的视角" class="headerlink" title="操作控制计算机的视角"></a>操作控制计算机的视角</h3><h4 id="计算机系统操作方式"><a href="#计算机系统操作方式" class="headerlink" title="计算机系统操作方式"></a>计算机系统操作方式</h4><ul><li>OS规定了合理操作计算机的工作流程</li><li>OS的操作接口——系统程序</li></ul><p>OS提供给用户的功能级接口，为用户提供的解决操作计算机和计算共性问题的所有服务的集合<br />OS的两类作业级接口</p><ul><li>脱机作业控制方式：作业控制语言</li><li>联机作业控制方式：操作控制命令</li></ul><h4 id="脱机作业控制方式"><a href="#脱机作业控制方式" class="headerlink" title="脱机作业控制方式"></a>脱机作业控制方式</h4><p>OS：提供作业说明语言<br />用户：编写作业说明书，确定作业加工控制步骤，并与程序数据一并提交<br />操作员：通过控制台输入作业<br />OS：通过作业控制程序自动控制作业的执行<br />例：批处理OS的作业控制方式，UNIX的shell程序，DOS的bat文件</p><p><strong>脱机输入&#x2F;输出技术是为了解决CPU和I&#x2F;O设备之间速度不匹配的矛盾而提出的，此技术减少了CPU的空闲等待时间，提高了I&#x2F;O速度。</strong>其输入&#x2F;输出方式如下图所示。<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678074655791-693dc5d8-94a7-48c8-8053-0c4e4b67bafd.jpeg" alt="94d41989dc954dfba4579a23c42a0f89.jpg"><br>为解决低速输入设备与CPU速度不匹配的问题，可以将用户程序和数据在一台外围机的控制下，预先从低速输入设备（纸带机）输入到输入带上，当CPU需要这些程序和数据时，再直接从输入带高速输入到内存，从而大大加快输入速度，减少CPU等待输入的时间，这就是脱机输入技术。<br />类似地，当程序运行完毕或告一段落，当CPU需要输出时，无须直接把计算结果送至低速输出设备（打印机），而是高速地把结果送到输出带上，然后在外围机的控制下，把磁带上的计算结果由相应的输出设备输出，这就是脱机输出技术。若输入&#x2F;输出操作在主机控制下进行，则称为联机输入&#x2F;输出。<br />采用脱机输入&#x2F;输出技术后，低速I&#x2F;O设备上数据的输入&#x2F;输出都在外围机的控制下进行，而CPU只与高速的输入带及输出带打交道，从而有效地减少了CPU等待慢速设备输入&#x2F;输出的时间。</p><h4 id="联机作业控制方式"><a href="#联机作业控制方式" class="headerlink" title="联机作业控制方式"></a>联机作业控制方式</h4><p>计算机：提供终端（键盘&#x2F;显示器）<br />用户：登录系统<br />OS：提供命令解释程序<br />用户：联机输入操作控制命令，直接控制作业步的执行<br />例：分时OS的交互控制方式</p><h4 id="命令解释程序"><a href="#命令解释程序" class="headerlink" title="命令解释程序"></a>命令解释程序</h4><p>命令解释程序：接受和执行一条用户提出的对作业的加工处理命令<br />当一个新的批作业被启动，或新的交互型用户登录进系统时，系统就自动地执行命令解释程序，负责读入控制卡或命令行，作出相应解释，并予以执行<br />会话语言：可编程的命令解释程序<br />图形化的命令控制方式<br />多通道交互的命令控制方式<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678074139871-35d3bb84-5288-4bf7-899a-f8d86e0cc96b.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678074155996-5eb61b10-e108-4b6e-a31d-a0e669f32d36.png" alt="image.png"></p><h3 id="人机交互的角度"><a href="#人机交互的角度" class="headerlink" title="人机交互的角度"></a>人机交互的角度</h3><h4 id="操作系统的人机交互部分"><a href="#操作系统的人机交互部分" class="headerlink" title="操作系统的人机交互部分"></a>操作系统的人机交互部分</h4><p>OS改善人机界面，为用户使用计算机提供良好的环境<br />人机交互设备包括传统的终端设备和新型的模式识别设备<br />OS的人机交互部分用于控制有关设备运行和理解执行设备传来的命令<br />人机交互功能是决定计算机系统友善性的重要因素，是当今OS研发热点</p><h4 id="人机交互的初期发展"><a href="#人机交互的初期发展" class="headerlink" title="人机交互的初期发展"></a>人机交互的初期发展</h4><p>交互式控制方式</p><ul><li>行命令控制方式：1960年代开始使用</li><li>全屏幕控制方式：1970年代开始使用</li></ul><p>斯坦福研究所提出的发展计划</p><ul><li>始于1960年代，1980年代广泛应用</li><li><strong>强调人而不是技术是人机交互的中心</strong></li><li>代表性成果：鼠标、菜单与窗口控制</li></ul><h4 id="人机交互发展-WIMP界面"><a href="#人机交互发展-WIMP界面" class="headerlink" title="人机交互发展-WIMP界面"></a>人机交互发展-WIMP界面</h4><p>缘起：70年代后期Xerox的原型机Star<br />特征：窗口(Windows) 、图标(Icons)、菜单(Menu) 和指示装置(PointingDevices)为基础的图形用户界面WIMP<br />得益：Apple最初采用并大力推动<br />时间：1990年代开始广泛使用<br />不足：不允许同时使用多个交互通道，从而产生人-机交互的不平衡</p><h3 id="程序接口的视角"><a href="#程序接口的视角" class="headerlink" title="程序接口的视角"></a>程序接口的视角</h3><h4 id="操作系统的程序接口"><a href="#操作系统的程序接口" class="headerlink" title="操作系统的程序接口"></a>操作系统的程序接口</h4><p>操作系统的程序接口：操作系统为程序运行扩充的编程接口<br />系统调用：操作系统实现的完成某种特定功能的过程；为所有运行程序提供访问操作系统的接口<br />POSIX支持</p><h4 id="系统调用的实现机制"><a href="#系统调用的实现机制" class="headerlink" title="系统调用的实现机制"></a>系统调用的实现机制</h4><ul><li>陷入处理机制：计算机系统中控制和实现系统调用的机制。   用户程序陷入系统程序</li><li>陷入指令：也称访管指令，或异常中断指令，计算机系统为实现系统调用而引起处理器中断的指令。  内核也称为管态</li><li>每个系统调用都事先规定了编号，并在约定寄存器中规定了传递给内部处理程序的参数</li></ul><p><strong>系统调用的实现要点</strong><br />编写系统调用处理程序<br />设计一张系统调用入口地址表，每个入口地址指向一个系统调用的处理程序，并包含系统调用自带参数的个数<br />陷入处理机制需开辟现场保护区，以保存发生系统调用时的处理器现场<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678075186766-63aacda4-9e40-4c9d-91b7-1e88c496c27c.png" alt="image.png"></p><ul><li>特权指令只能在内核空间中使用</li><li>系统调用没有建立名空间，只能按号调用</li><li>在用户态和内核态中不断切换</li><li>CPU在内核态中管理，需要消耗一段时间，但不能过多消耗</li><li>模式切换：类似C&#x2F;S client（请求方的进程） 与 server（应答方的进程），建立了请求应答的关系。特权指令被封装在内核态中，用户态无法直接执行相关指令，所以需要通过接口请求内核的服务</li><li>保护CPU现场：为了被停下来的进程A再恢复时，仍然能够从停止的地址开始（因为内核空间处理完后，处理器会继续调度，不一定会继续执行A）</li></ul><h4 id="Linux系统调用执行流程"><a href="#Linux系统调用执行流程" class="headerlink" title="Linux系统调用执行流程"></a>Linux系统调用执行流程</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678329562238-0dde6fb7-6d02-41d1-b81f-c432a5d1e567.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678329585387-cd689b1c-5408-45d5-bdf7-efec8019c730.png" alt="image.png"></p><p><code>dispatch</code> 查系统调用的入口地址表</p><h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><p>本质：修改模式位<br />用户：mode &#x3D; 1<br />内核：mode &#x3D; 0<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678330471224-0c4e64c6-715f-4e76-b63a-9bb051f1be40.png" alt="image.png"></p><h3 id="系统结构的视角"><a href="#系统结构的视角" class="headerlink" title="系统结构的视角"></a>系统结构的视角</h3><p>微内核：缩小内核的规模。<br />process要获得文件系统，需要先内核发起请求，再发给文件系统，然后再返回给内核，再返回给process，时间延长<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678331024053-6ea4d4f9-676a-4be6-8a92-f123eb226ba8.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二章 - 处理器管理</title>
      <link href="/2023/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20-%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20-%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="处理器与寄存器"><a href="#处理器与寄存器" class="headerlink" title="处理器与寄存器"></a>处理器与寄存器</h1><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><p>时钟信号：时间片轮转调度<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678332135419-f71c530c-3faf-4e3d-ab9f-ecb49c872d90.png" alt="image.png"></p><h2 id="用户程序可见寄存器"><a href="#用户程序可见寄存器" class="headerlink" title="用户程序可见寄存器"></a>用户程序可见寄存器</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678332196218-1763c684-cc1c-44b2-80d9-92dc2091c32a.png" alt="image.png"></p><h2 id="控制与状态寄存器"><a href="#控制与状态寄存器" class="headerlink" title="控制与状态寄存器"></a>控制与状态寄存器</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678332162419-c7d3179f-0a7e-4f3d-b2d6-519032d1f096.png" alt="image.png"></p><h2 id="程序状态字PSW"><a href="#程序状态字PSW" class="headerlink" title="程序状态字PSW"></a>程序状态字PSW</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1678332271635-bc928b95-db2d-405e-bdf1-566df1dde448.png" alt="image.png"></p><h1 id="指令与处理器模式"><a href="#指令与处理器模式" class="headerlink" title="指令与处理器模式"></a>指令与处理器模式</h1><h2 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h2><ul><li>机器指令是计算机系统执行的基本命令，是中央处理器执行的基本单位</li><li>指令由一个或多个字节组成，包括操作码字段、一个或多个操作数地址字段、以及一些表征机器状态的状态字以及特征码</li><li>指令完成各种算术逻辑运算、数据传输、控制流跳转</li></ul><h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p><strong>CPU根据PC取出指令，放入IR，并对指令译码，然后发出各种控制命令，执行微操作系列，从而完成一条指令的执行</strong><br />一种指令执行步骤如下：</p><ul><li>取指：根据PC从存储器或高速缓冲存储器中取指令到IR</li><li>解码：解译IR中的指令来决定其执行行为</li><li>执行：连接到CPU部件，执行运算，产生结果并写回，同时在CC<code>condition code</code>条件码，里设置运算结论标志；跳转指令操作PC，其他指令递增PC值</li></ul><h2 id="特权指令与非特权指令"><a href="#特权指令与非特权指令" class="headerlink" title="特权指令与非特权指令"></a>特权指令与非特权指令</h2><ul><li>用户程序并非能够使用全部机器指令，那些与计算机核心资源相关的特殊指令会被保护<ul><li>如：启动I&#x2F;O指令、置PC指令、等等</li><li>核心资源相关的指令只能被操作系统程序使用</li></ul></li><li>特权指令：<strong>只能被操作系统内核使用的指令</strong></li><li>非特权指令：<strong>能够被所有程序使用的指令</strong></li></ul><h2 id="处理器模式"><a href="#处理器模式" class="headerlink" title="处理器模式"></a>处理器模式</h2><p>计算机通过设置处理器模式实现特权指令管理<br />计算机一般设置0、1、2、3等四种运行模式，建议分别对应：0操作系统内核、1系统调用、<br />2共享库程序、3用户程序等保护级别</p><ul><li>0模式可以执行全部指令；3模式只能执行非特权指令；其他每种运行模式可以规定执行的指令子集</li><li>一般来说，现代操作系统只使用0和3两种模式，对应于内核模式和用户模式</li></ul><h2 id="处理器模式的切换"><a href="#处理器模式的切换" class="headerlink" title="处理器模式的切换"></a>处理器模式的切换</h2><p>简称模式切换，包括“用户模式→内核模式”和“内核模式→用户模式”的转换</p><ul><li>中断、异常或系统异常等事件导致用户程序向OS内核切换，触发：用户模式→内核模式<ul><li>程序请求<strong>操作系统服务</strong></li><li>程序运行时发生<strong>异常</strong></li><li>程序运行时<strong>发生并响应中断</strong></li></ul></li><li>OS内核处理完成后，调用<strong>中断返回指令</strong>（如Intel的iret <code>interrupt return</code>）触发：内核模式→用户模式</li></ul><h1 id="中断与中断源"><a href="#中断与中断源" class="headerlink" title="中断与中断源"></a>中断与中断源</h1><h2 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h2><p>中断是指程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程</p><ul><li>操作系统是“中断驱动”的；换言之，中断是激活操作系统的唯一方式</li><li>中断有广义和狭义之分，上述中断是指广义的中断</li><li>中断是实现多道程序设计的基础</li></ul><h2 id="中断、异常与系统异常"><a href="#中断、异常与系统异常" class="headerlink" title="中断、异常与系统异常"></a>中断、异常与系统异常</h2><ul><li>狭义的中断指来源于处理器之外的中断事件，即与当前运行指令无关的中断事件，如I&#x2F;O中断、时钟中断、外部信号中断等</li><li>异常指当前运行指令引起的中断事件，如地址异常、算术异常、处理器硬件故障等</li><li>系统异常指执行陷入指令而触发系统调用引起的中断事件，如请求设备、请求I&#x2F;O、创建进程等</li></ul><h2 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h2><h3 id="处理器硬件故障中断事件"><a href="#处理器硬件故障中断事件" class="headerlink" title="处理器硬件故障中断事件"></a>处理器硬件故障中断事件</h3><ul><li>由处理器、内存储器、总线等硬件故障引起</li><li>处理原则为：保护现场，停止设备，停止CPU，向操作员报告，等待人工干预</li></ul><h3 id="程序性中断事件"><a href="#程序性中断事件" class="headerlink" title="程序性中断事件"></a>程序性中断事件</h3><p>处理器执行机器指令引起</p><ul><li>除数为零、操作数溢出等算术异常：简单处理，报告用户；也可以由用户编写中断续元程序处理</li><li>非法指令、用户态使用特权指令、地址越界、非法存取等指令异常：终止进程</li><li>终止进程指令：终止进程</li><li><strong>虚拟地址异常：调整内存后重新执行指令</strong></li></ul><h3 id="自愿性中断事件"><a href="#自愿性中断事件" class="headerlink" title="自愿性中断事件"></a>自愿性中断事件</h3><p>处理器<strong>执行陷入指令请求OS服务</strong>引起；在操作系统中，它一般又被称作系统调用</p><ul><li>请求分配外设、请求I&#x2F;O、等等</li><li>处理流程是：陷入OS，保护现场，根据功能号查入口地址，跳转具体处理程序</li></ul><h3 id="I-x2F-O中断事件"><a href="#I-x2F-O中断事件" class="headerlink" title="I&#x2F;O中断事件"></a>I&#x2F;O中断事件</h3><p>来源于外围设备报告I&#x2F;O状态的中断事件</p><ul><li>I&#x2F;O完成：调整进程状态，释放等待进程</li><li>I&#x2F;O出错：等待人工干预 </li><li>I&#x2F;O异常：等待人工干预</li></ul><h3 id="外部中断事件"><a href="#外部中断事件" class="headerlink" title="外部中断事件"></a>外部中断事件</h3><p>由外围设备发出的信号引起的中断事件</p><ul><li>时钟中断、间隔时钟中断：记时与时间片处理</li><li>设备报到与结束中断：调整设备表</li><li>键盘&#x2F;鼠标信号中断：根据信号作出相应反应</li><li>关机&#x2F;重启动中断：写回文件，停止设备与CPU</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>let和var的理解</title>
      <link href="/2023/03/10/React%E5%AD%A6%E4%B9%A0/let%E5%92%8Cvar%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/03/10/React%E5%AD%A6%E4%B9%A0/let%E5%92%8Cvar%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> React学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2023/03/10/React%E5%AD%A6%E4%B9%A0/Promise/"/>
      <url>/2023/03/10/React%E5%AD%A6%E4%B9%A0/Promise/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h2><p>实例对象的一个内置属性<code>PromiseState</code></p><ol><li><code>pending 悬而未决的</code>变为<code>resolved 成功的</code></li><li><code>pending</code>变为<code>rejected 失败的</code></li></ol><p>说明:只有这2种，且一个promise对象只能改变一次无论变为成功还是失败,都会有一个结果数据成功的结果数据一般称为value，失败的结果数据一般称为reason</p><h2 id="Promise-对象的值"><a href="#Promise-对象的值" class="headerlink" title="Promise 对象的值"></a>Promise 对象的值</h2><p>实例对象中的一个属性 <code>PromiseResult</code> 保存着异步任务成功&#x2F;失败的结果</p><ol><li><code>resolve(result)</code></li><li><code>reject(result)</code></li></ol><h2 id="Promise的基本流程"><a href="#Promise的基本流程" class="headerlink" title="Promise的基本流程"></a>Promise的基本流程</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1673004880929-bcd999c1-a88c-46df-9764-68e18566d4f9.png" alt="image.png"></p><h2 id="APIⅠ-Promise-构造函数-Promise-excutor"><a href="#APIⅠ-Promise-构造函数-Promise-excutor" class="headerlink" title="APIⅠ- Promise 构造函数: Promise (excutor) {}"></a>API<br />Ⅰ- Promise 构造函数: Promise (excutor) {}</h2><p>(1) executor 函数: 执行器 (resolve, reject) &#x3D;&gt; {} <strong>函数类型的参数</strong><br />(2) resolve 函数: 内部定义成功时我们调用的函数 value &#x3D;&gt; {}<br />(3) reject 函数: 内部定义失败时我们调用的函数 reason &#x3D;&gt; {}<br />说明: executor 会在 Promise 内部<strong>立即同步调用</strong>,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 先输出111 再输出222</span></span><br></pre></td></tr></table></figure><h4 id="Ⅱ-Promise-prototype-then-方法-onResolved-onRejected-x3D-gt"><a href="#Ⅱ-Promise-prototype-then-方法-onResolved-onRejected-x3D-gt" class="headerlink" title="Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) &#x3D;&gt; {}"></a>Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) &#x3D;&gt; {}</h4><p>(1) onResolved 函数: 成功的回调函数 (value) &#x3D;&gt; {}<br />(2) onRejected 函数: 失败的回调函数 (reason) &#x3D;&gt; {}<br />说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p><h4 id="Ⅲ-Promise-prototype-catch-方法-onRejected-x3D-gt"><a href="#Ⅲ-Promise-prototype-catch-方法-onRejected-x3D-gt" class="headerlink" title="Ⅲ-Promise.prototype.catch 方法: (onRejected) &#x3D;&gt; {}"></a>Ⅲ-Promise.prototype.catch 方法: (onRejected) &#x3D;&gt; {}</h4><p>(1) onRejected 函数: 失败的回调函数 (reason) &#x3D;&gt; {}<br />说明: then()的语法糖, 相当于: then(undefined, onRejected)<br>(2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中</p><h4 id="Ⅳ-Promise-resolve-方法-value-x3D-gt"><a href="#Ⅳ-Promise-resolve-方法-value-x3D-gt" class="headerlink" title="Ⅳ-Promise.resolve 方法: (value) &#x3D;&gt; {}"></a>Ⅳ-Promise.resolve 方法: (value) &#x3D;&gt; {}</h4><p><strong>不属于实例对象，属于函数对象 快速返回一个成功的promise对象</strong><br />(1) value: 成功的数据或 promise 对象<br />说明: 返回一个成功&#x2F;失败的 promise 对象,直接改变promise状态</p><ul><li>如果传入的参数为非Promise类型的对象，则返回的结果为成功的Promise对象</li><li>如果传入的参数为Promise对象，则参数的结果决定了resolve的结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">999</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;ok&#x27;) resolve和reject同时写的话，只会调用最前面的一个</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>) <span class="comment">// 参数的状态决定了p2的状态</span></span><br><span class="line">&#125;))</span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Ⅴ-Promise-reject-方法-reason-x3D-gt"><a href="#Ⅴ-Promise-reject-方法-reason-x3D-gt" class="headerlink" title="Ⅴ-Promise.reject 方法: (reason) &#x3D;&gt; {}"></a>Ⅴ-Promise.reject 方法: (reason) &#x3D;&gt; {}</h4><p><strong>不属于实例对象，属于函数对象 快速返回一个失败的promise对象</strong><br />(1) reason: 失败的原因<br />说明: 返回一个失败的 promise 对象,直接改变promise状态，状态<strong>永远都是失败的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">999</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    <span class="comment">// reject(&#x27;error&#x27;)</span></span><br><span class="line">&#125;))</span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1673006425848-cef16d81-a444-47b3-892e-b7ff5a2abb43.png" alt="image.png"></p><h4 id="Ⅵ-Promise-all-方法-promises-x3D-gt"><a href="#Ⅵ-Promise-all-方法-promises-x3D-gt" class="headerlink" title="Ⅵ-Promise.all 方法: (promises) &#x3D;&gt; {}"></a>Ⅵ-Promise.all 方法: (promises) &#x3D;&gt; {}</h4><p>promises: 包含 n 个 promise 的数组<br />说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就直接失败<br />成功的结果是所有成功的promise组成的结果，失败的结果是失败的promise组成的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);  &#125;)</span><br><span class="line">   <span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;错误错误错误&#x27;</span>);</span><br><span class="line">   <span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;也是成功&#x27;</span>)</span><br><span class="line">   <span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><blockquote><p>只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。</p></blockquote><h4 id="Ⅶ-Promise-race-方法-promises-x3D-gt"><a href="#Ⅶ-Promise-race-方法-promises-x3D-gt" class="headerlink" title="Ⅶ-Promise.race 方法: (promises) &#x3D;&gt; {}"></a>Ⅶ-Promise.race 方法: (promises) &#x3D;&gt; {}</h4><p>(1) promises: 包含 n 个 promise 的数组<br />说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态,一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。<br />如p1延时,开启了异步,内部正常是同步进行,所以p2&gt;p3&gt;p1,结果是P2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;one&#x27;</span>); <span class="comment">//这种表示有点点奇怪</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1, promise2]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  <span class="comment">// Both resolve, but promise2 is faster</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: &quot;two&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Promise的几个关键问题"><a href="#Promise的几个关键问题" class="headerlink" title="Promise的几个关键问题"></a><br />Promise的几个关键问题</h2><h4 id="Ⅰ-如何改变-promise-的状态"><a href="#Ⅰ-如何改变-promise-的状态" class="headerlink" title="Ⅰ-如何改变 promise 的状态?"></a>Ⅰ-如何改变 promise 的状态?</h4><p>(1) resolve(value): 如果当前是 pending 就会变为 resolved<br />(2) reject(reason): 如果当前是 pending 就会变为 rejected<br />(3) 抛出异常: 如果当前是 pending 就会变为 rejected</p><h4 id="Ⅱ-一个-promise-指定多个成功-x2F-失败回调函数-都会调用吗"><a href="#Ⅱ-一个-promise-指定多个成功-x2F-失败回调函数-都会调用吗" class="headerlink" title="Ⅱ-一个 promise 指定多个成功&#x2F;失败回调函数, 都会调用吗?"></a>Ⅱ-一个 promise 指定多个成功&#x2F;失败回调函数, 都会调用吗?</h4><p>当 promise 改变为对应状态时都会调用,改变状态后,多个回调函数都会调用,并不会自动停止<br />如果状态是<code>pending</code>且没有发生改变时，则回调函数不会调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">  <span class="comment">///指定回调 - 1</span></span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); &#125;);</span><br><span class="line">  <span class="comment">//指定回调 - 2</span></span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="title function_">alert</span>(value);&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">//OK</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(value); <span class="comment">// undefined</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="Ⅲ-改变-promise-状态和指定回调函数谁先谁后"><a href="#Ⅲ-改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="Ⅲ- 改变 promise 状态和指定回调函数谁先谁后?"></a>Ⅲ- 改变 promise 状态和指定回调函数谁先谁后?</h4><p>(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调<br />先指定回调再改变状态(异步):先指定回调–&gt; 再改变状态 –&gt;改变状态后才进入异步队列执行回调函数<br />先改状态再指定回调(同步):改变状态    –&gt;指定回调 并马上执行回调<br />(2) 如何先改状态再指定回调? –&gt;注意:指定并不是执行<br />① 在执行器中直接调用 resolve()&#x2F;reject() –&gt;即,不使用定时器等方法,执行器内直接同步操作<br />② 延迟更长时间才调用 then() –&gt;即,在.then()这个方法外再包一层例如延时器这种方法<br />(3) 什么时候才能得到数据? 即 回调函数什么时候执行<br />① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据<br />② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//异步写法,这样写会先指定回调,再改变状态</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//这是同步写法,这样写会先改变状态,再指定回调</span></span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); </span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="Ⅳ-promise-then-返回的新-promise-的结果状态由什么决定"><a href="#Ⅳ-promise-then-返回的新-promise-的结果状态由什么决定" class="headerlink" title="Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?"></a>Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?</h4><p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定<br />(2) 详细表达:<br />① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常<br />② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值<br />③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//执行 then 方法</span></span><br><span class="line"><span class="keyword">let</span> result = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line"><span class="comment">// 1. 抛出错误 ,变为 rejected</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;出了问题&#x27;</span>;</span><br><span class="line"><span class="comment">// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved,结果为521</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">521</span>;</span><br><span class="line"><span class="comment">// 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve(&#x27;success&#x27;);</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Ⅴ-promise-如何串连多个操作任务"><a href="#Ⅴ-promise-如何串连多个操作任务" class="headerlink" title="Ⅴ- promise 如何串连多个操作任务?"></a>Ⅴ- promise 如何串连多个操作任务?</h4><p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用<br />(2) 通过 then 的链式调用串连多个同步&#x2F;异步任务,这样就能用then()将多个同步或异步操作串联成一个同步队列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value) <span class="comment">// success</span></span><br><span class="line">      <span class="comment">//    没有写返回值，所以是undefined，是非promise对象，所以是成功的结果</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 该promise的结果由第二个then中的返回值决定</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value) <span class="comment">// undefined</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result) </span><br><span class="line"><span class="comment">// 如果在1s内打开，则状态是pending；如果大于1s打开，则状态是fulfilled</span></span><br></pre></td></tr></table></figure><h4 id="Ⅵ-promise-异常传透"><a href="#Ⅵ-promise-异常传透" class="headerlink" title="Ⅵ-promise 异常传透"></a>Ⅵ-promise 异常传透</h4><ul><li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li><li>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res), <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被then的错误回调捕获&#x27;</span>, e))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//执行结果: 被then的错误回调捕获 Error: 抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** 利用异常穿透 ****************************************/</span></span><br><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)) <span class="comment">//此处差异,不指定 reject 回调,利用异常穿透传到最后</span></span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//执行结果:  错误捕获:  Error: 抛出异常</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Ⅶ-中断-promise-链"><a href="#Ⅶ-中断-promise-链" class="headerlink" title="Ⅶ- 中断 promise 链?"></a>Ⅶ- 中断 promise 链?</h4><p>在关键问题2中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何?<br />(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数<br />(2) 办法: 在回调函数中返回一个 pendding 状态的promise 对象  那么因为状态是pending，所以then就不会继续被调用了，实现了promise链的中断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">        <span class="comment">// reject(&#x27;error&#x27;)</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// 有且只有这一种方式</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;error!!&#x27;</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h2><h2 id="疑点"><a href="#疑点" class="headerlink" title="疑点"></a>疑点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;one&#x27;</span>); <span class="comment">//这种表示有点点奇怪</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为什么<code>result</code>的值为空</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;hello world!&#x27;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    result = value</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout与Promise的执行顺序</title>
      <link href="/2023/03/10/React%E5%AD%A6%E4%B9%A0/setTimeout%E4%B8%8EPromise%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2023/03/10/React%E5%AD%A6%E4%B9%A0/setTimeout%E4%B8%8EPromise%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903607276437517">settimeout(fn 0)与Promise的执行顺序 - 掘金</a></p><p><a href="https://juejin.cn/post/6844903459859202061">你应该知道的 setTimeout 秘密 - 掘金</a></p><p><a href="https://cloud.tencent.com/developer/article/1839124">如何将Promise.then中的值直接return出来 - 腾讯云开发者社区-腾讯云</a></p>]]></content>
      
      
      <categories>
          
          <category> React学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对象</title>
      <link href="/2023/03/10/React%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/03/10/React%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<ol><li>使用<code>for in</code>排序时，<strong>整数的属性</strong>会按照从小到大的顺序排序，其他属性则按照创建的顺序显示<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> codes = &#123;</span><br><span class="line">    <span class="string">&quot;49&quot;</span>: <span class="string">&quot;Germany&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test2&quot;</span>:<span class="string">&quot;wuwuwu&quot;</span>,</span><br><span class="line">    <span class="string">&quot;41&quot;</span>: <span class="string">&quot;Switzerland&quot;</span>,</span><br><span class="line">    <span class="string">&quot;44&quot;</span>: <span class="string">&quot;Great Britain&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test1&quot;</span>:<span class="string">&quot;hahaha&quot;</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="string">&quot;USA&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codesKey <span class="keyword">in</span> codes) &#123; <span class="comment">// 整数的属性会被排序，其他属性按照创建的顺序显示</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(codesKey); <span class="comment">// 1 41 44 49 &quot;test2&quot; &quot;test1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> React学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React组件三大属性</title>
      <link href="/2023/03/10/React%E5%AD%A6%E4%B9%A0/React%E7%BB%84%E4%BB%B6%E4%B8%89%E5%A4%A7%E5%B1%9E%E6%80%A7/"/>
      <url>/2023/03/10/React%E5%AD%A6%E4%B9%A0/React%E7%BB%84%E4%BB%B6%E4%B8%89%E5%A4%A7%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-state"><a href="#1-state" class="headerlink" title="1. state"></a>1. state</h2><ol><li>组件中<code>render</code>方法中的<code>this</code>为组件实例对象</li><li>组件自定义方法中<code>this</code>为<code>undefined</code><ol><li>通过<code>bind</code>强制绑定<code>this</code></li><li>箭头函数</li></ol></li><li>状态数据，不能直接修改或者更新<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器调用了 1 次</span></span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;constructor&quot;</span>)</span><br><span class="line">            <span class="variable language_">super</span>(props);</span><br><span class="line">            <span class="comment">// 构造器中的this一定是当前的实例对象</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">                <span class="attr">isHot</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">wind</span>:<span class="string">&#x27;windy&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// bind 会返回一个新函数</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">demo</span> = <span class="variable language_">this</span>.<span class="property">handleWeatherChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>); <span class="comment">// = 后面的handleWeatherChange是原型对象上的</span></span><br><span class="line">            <span class="comment">// 给实例对象自身又生成了一个 handleWeatherChange</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">handleWeatherChange</span>(<span class="params"></span>) &#123; <span class="comment">// 只有通过实例调用，this才会指向实例对象</span></span><br><span class="line">            <span class="comment">// 由于该函数是作为onClick的回调，所以不是通过实例调用的，是直接调用的</span></span><br><span class="line">            <span class="comment">// 又因为类中定义的方法默认是局部严格模式，所以该方法中的this默认是undefined</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                <span class="attr">isHot</span>: !<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHot</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// state中的属性不能直接修改,是一种合并，不是替换</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// render 调用了 1 + n 次 n是状态更新的次数</span></span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123; <span class="comment">// render 放在组件的原型对象上，通过实例对象进行调用</span></span><br><span class="line">            <span class="comment">// console.log(this.state)  // render中的this 代表的是实例对象</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;render&quot;</span>)</span><br><span class="line">            <span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="comment">// 调用的是实例对象上的demo。如果没有定义，则会顺着原型链找到原型对象上的 WeatherChange</span></span><br><span class="line">                <span class="comment">// 但是原型对象上的WeatherChange中的this是undefined</span></span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.demo&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>今天天气很&#123;this.state.isHot ? &#x27;hot&#x27; : &#x27;cool&#x27;&#125;,&#123;wind&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类中方法局部自动开启了严格模式，因此this默认不是window了</span></span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// speak 放在了类的原型对象上，供实例对象使用</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// this 指向person实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;austyn&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">p1.<span class="title function_">speak</span>(); <span class="comment">// 通过实例对象调用speak方法</span></span><br><span class="line"><span class="keyword">const</span> x = p1.<span class="property">speak</span>;</span><br><span class="line"><span class="title function_">x</span>(); <span class="comment">// 直接调用 this是undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> y = demo.<span class="title function_">bind</span>(&#123;<span class="attr">haha</span>: <span class="number">444</span>&#125;)</span><br><span class="line"><span class="title function_">y</span>();</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">isHot</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">wind</span>: <span class="string">&#x27;Windy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在实例对象上的自定义方法：赋值语句的形式+箭头函数</span></span><br><span class="line">    handleWeatherChange = <span class="function">() =&gt;</span> &#123; <span class="comment">// 只有通过实例调用，this才会指向实例对象</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="keyword">const</span> isHot = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHot</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">isHot</span>: !isHot&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123; <span class="comment">// render 放在组件的原型对象上，通过实例对象进行调用</span></span><br><span class="line">        <span class="keyword">const</span> &#123;isHot, wind&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleWeatherChange&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>今天天气很&#123;this.state.isHot ? &#x27;hot&#x27; : &#x27;cool&#x27;&#125;,&#123;wind&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-props"><a href="#2-props" class="headerlink" title="2. props"></a>2. props</h2><h3 id="2-1-批量传递标签属性"><a href="#2-1-批量传递标签属性" class="headerlink" title="2.1 批量传递标签属性"></a>2.1 批量传递标签属性</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;name, age, sex&#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>The name is &#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>The age is &#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>The sex is &#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = &#123;<span class="attr">name</span>: <span class="string">&#x27;austyn&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">sex</span>: <span class="string">&#x27;mail&#x27;</span>&#125;;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> &#123;<span class="attr">...p</span>&#125;/&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>&#123;...p&#125;</code>通过解构赋值的语法进行批量传递。</p><h4 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;jingxun&quot;</span>, <span class="attr">age</span>:<span class="number">18</span>, <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...person);</span><br></pre></td></tr></table></figure><p>报错信息说对象类型没有iterator接口，也就是说<strong>不能直接把展开运算符直接运用到一个对象上</strong>，也就是说展开运算符不能展开一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;jingxun&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> person2 = &#123;...person&#125;;</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;dschow&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2);</span><br></pre></td></tr></table></figure><p>展开运算符不能直接对对象进行展开，但是让我们在对象的{}内部的话是可以使用展开运算符来复制一个对象的，注意我这里说的是<strong>复制</strong>而<strong>不是展开对象</strong>。<br />所以说直接使用运算符作用在对象上是一个语法错误，如果<strong>在对象的{}内部用展开运算符展开作用在对象上则触发了一个新的语法，是复制一个对象。</strong></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>&lt;Person {…p} &#x2F;&gt;</p><ol><li>babel库和react的支持，使得我们可以在jsx语法环境下来用展开运算符来展开对象。但是在原生js语法中绝对是不允许展开对象的。</li><li>babel库虽然支持展开对象，但是并不允许我们随便使用，仅仅只在标签属性传递时才允许展开一个对象，别的地方都不行。</li><li>这里的<code>&#123;&#125;</code>代表的仍然是对<code>js</code>表达式的使用</li><li>这里的<code>...p</code>是展开对象，而不是复制对象了</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>props可以在标签中使用展开运算符展开一个对象来批量传入属性</li><li>props在使用展开运算符时必须确保被展开对象中的属性和解构props时的变量一致才能正常取数</li><li>展开运算符在原生js语法中不能展开对象</li><li>babel和react库支持仅在组件标签批量传入属性时展开对象</li></ul><h3 id="2-2-对props进行限制"><a href="#2-2-对props进行限制" class="headerlink" title="2.2 对props进行限制"></a>2.2 对props进行限制</h3><h4 id="对函数限制"><a href="#对函数限制" class="headerlink" title="对函数限制"></a>对函数限制</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">speak</span>:<span class="title class_">PropTypes</span>.<span class="property">function</span> <span class="comment">// 会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Warning: Failed prop type: Person: prop type <code>speak</code> is invalid; it must be a function, usually from the <code>prop-types</code>package, but received <code>undefined</code>in Person</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">speak</span>:<span class="title class_">PropTypes</span>.<span class="property">func</span> <span class="comment">// 不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>, <span class="comment">// 限制属性是否必须非空</span></span><br><span class="line">  <span class="attr">speak</span>:<span class="title class_">PropTypes</span>.<span class="property">func</span> <span class="comment">// 对函数进行限制</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">defaultProps</span> = &#123;  <span class="comment">// 提供默认值</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Austyn!!Default&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">1999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>限制并不是必须的</li><li>限制props必须引入prop-types</li><li>限制可以避免一些不必要的错误</li><li>限制有三种场景<ul><li>限制属性是否必须非空</li><li>限制属性类型</li><li>限制属性默认值</li></ul></li><li>限制属性类型为函数时，不能用function而要用func</li></ul><p></p><h3 id="2-3-简写props"><a href="#2-3-简写props" class="headerlink" title="2.3 简写props"></a>2.3 简写props</h3><ol><li>定义类组件</li><li>对props进行类型以及必要性限制</li><li>给props添加默认值</li><li>渲染组件到页面</li></ol><p>Person.propsTypes &#x3D; {…}还有Person.defaultProps &#x3D; {…}是给Person自身加了两个属性</p><ol><li>在类里直接写赋值语句是什么意思？**是给这个类的实例对象添加属性               **但是我们是要给类本身添加属性啊。</li><li>为什么不是给实例对象添加呢？我们说了propsTypes和defaultProps是类本身的属性，react要在实例化组件之前去类本身上去查找这两个属性，然后再实例化对象，如果是给实例化对象上添加属性是不是要通过实例化之后的对象才能拿到啊？但是这一步<strong>查找实是在实例化对象之前的</strong>，都没有实例对象react上哪去拿实例对象的属性呢？所以说必须把这两个属性加在类的自身上。</li></ol><p>在类没有被实例化就可以直接通过类名就调用到的属性和方法就是静态属性和静态方法。那么也就是说我们要把propsTypes和defaultProps作为Person类的静态属性。那么赋值语句前面加一个static关键字即可。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="title class_">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line">        <span class="attr">sex</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">        <span class="attr">speak</span>:<span class="title class_">PropTypes</span>.<span class="property">func</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">        <span class="attr">sex</span>:<span class="string">&#x27;Mail_Default&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">1999</span>,</span><br><span class="line">        <span class="attr">speak</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;default Func&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;name, age, sex&#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">speak</span>();</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>The name is &#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>The age is &#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>The sex is &#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>propsTypes和defaultProps必须是组件类自身的属性，不是实例对象的属性</li><li>用static关键字给类自身添加属性</li><li>props是只读的</li></ul><h3 id="2-4-类组件中构造器和props"><a href="#2-4-类组件中构造器和props" class="headerlink" title="2.4 类组件中构造器和props"></a>2.4 类组件中构造器和props</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1674807966337-fdbdc13b-306b-419c-8e84-ae718cd8bb17.png" alt="image.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>) <span class="comment">// 得到的是undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>) <span class="comment">// 可以得到具体的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul><li>类组件不写构造器完全可以，而且能不写就尽量不写</li><li>构造器中props传给super和不传给super的区别就是在构造器中能否通过this访问到props</li></ul><h3 id="2-5-函数式组件中props"><a href="#2-5-函数式组件中props" class="headerlink" title="2.5 函数式组件中props"></a>2.5 函数式组件中props</h3><ol><li>函数中没有实例，因此无法使用state和refs</li><li>函数有参数，通过参数将props传入</li><li>函数没有static的概念，因此必须在函数体外进行限制<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age, gender &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;gender&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age + 1&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">defaultProps</span> =&#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">  <span class="attr">gender</span>:<span class="string">&quot;男&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&#123;123&#125;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul><li>函数式组件目前只能使用props</li><li>函数式组件使用参数来接收props</li><li>函数式组件可以限制props但是只能写在函数体外</li></ul><h3 id="2-6-总结props"><a href="#2-6-总结props" class="headerlink" title="2.6 总结props"></a>2.6 总结props</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>props其实就是标签属性，是可以批量传入的，而且在react和babel的支持下可以在组件标签中对一个对象使用展开运算符来完成批量传入。</p><h4 id="对props进行限制"><a href="#对props进行限制" class="headerlink" title="对props进行限制"></a>对props进行限制</h4><p>并不是必须对props进行限制，如果想限制就限制，不想限制随便传也可以。<br />限制也很简单，只需要给标签自身添加propTypes属性就行了。<br />如果说我们要给props添加默认值的话，可以通过给组件自身添加defaultProps属性来完成</p><h4 id="构造器与props"><a href="#构造器与props" class="headerlink" title="构造器与props"></a>构造器与props</h4><p>构造器能省略就省略，实在不能省略的话，构造器一定要接收props并且传给super</p><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><h3 id="字符串形式的refs"><a href="#字符串形式的refs" class="headerlink" title="字符串形式的refs"></a>字符串形式的refs</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  showData = <span class="function">() =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  blurData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">input2</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;input1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;点击按钮提示&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span>&gt;</span>点击弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;input2&quot;</span> <span class="attr">onBlur</span>=<span class="string">&#123;this.blurData&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">placeholder</span>=<span class="string">&quot;失去焦点提示&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1674811472112-2cadd8af-cc04-4644-8999-150cedd5b419.png" alt="image.png"></p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul><li>refs是一个收集各个标签ref属性来作为标识的一个对象 <code>key-value</code>中，<code>key</code>代表人为定义的标识符&#x2F;关键字，而<code>val</code>则代表页面的节点</li><li>refs可以代替document.getElementById方法来获取页面节点</li><li>refs可以配合事件处理来完成相应的功能需求。</li></ul><h3 id="回调形式的refs"><a href="#回调形式的refs" class="headerlink" title="回调形式的refs"></a>回调形式的refs</h3><p>回调函数的特点：</p><ol><li>程序员自定义的函数</li><li>程序员自己没有调用</li><li>最终函数被执行了</li></ol><p>在<code>ref</code>中定义的回调函数，其参数就是<strong>页面节点</strong><br />回调函数的外层是render方法，render方法是react通过Demo组件的实例调用的，那么render方法中的this指向的就是组件的实例对象啊。因此，ref中定义的回调函数中的this就是render中的this，也就是组件的实例对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    showData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">input1</span>.<span class="property">value</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">BlurData</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">input2</span>.<span class="property">value</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;blur&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;val</span> =&gt;</span> this.input1 = val&#125; placeholder=&quot;点击按钮提示&quot; type=&quot;text&quot;/&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span>&gt;</span>点击弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;val</span> =&gt;</span> this.input2 = val&#125; onBlur=&#123;this.BlurData&#125; placeholder=&quot;失去焦点&quot;/&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1674811719269-8744b6e1-cafe-4fea-8b79-4360c0f0ee7b.png" alt="image.png"><br>为什么我们在回调函数里面返回了接到的参数refs却没有收集呢？</p><ol><li>这里不是字符串ref啊，那肯定就不支持这种方法了。</li><li>而且跟你有没有return没有关系，因为这个是<strong>定义一个回调函数</strong>又不是定义一个函数并获取返回值。</li><li>ref&#x3D;{ () &#x3D;&gt; {} }，这相当于ref&#x3D;function，按照字符串ref的规则，是不是应该收集function: DOM然后存放到this.refs里面？这是一对key-value，但是函数不用来做key的</li></ol><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><ul><li>回调式refs不会自动收集到this.refs中</li><li>字符串式refs有问题，后期可能会废弃</li><li>回调式refs所传入的ref属性是一个回调函数</li><li>回调式refs是将传入的标签节点传入回调函数，并<strong>通过回调函数将标签节点挂在实例自身</strong></li></ul><h3 id="3-3-回调式-ref-被调用的次数"><a href="#3-3-回调式-ref-被调用的次数" class="headerlink" title="3.3 回调式 ref 被调用的次数"></a>3.3 回调式 ref 被调用的次数</h3><h4 id="内联函数多次调用"><a href="#内联函数多次调用" class="headerlink" title="内联函数多次调用"></a>内联函数多次调用</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1674824305125-de578a4f-af73-47dd-be6c-6ef07e4903a9.png" alt="image.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input1</span> = val;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;###&quot;</span>);</span><br><span class="line">&#125;&#125; placeholder=<span class="string">&quot;点击按钮提示&quot;</span> type=<span class="string">&quot;text&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><ol><li>第一次渲染的时候，程序执行到这个input标签，<strong>发现指定了回调式的refs，那么程序就会自动调用这个回调函数。</strong>这是第一次渲染并执行了这一次。这一步没有任何问题。</li><li>但是当我们点击按钮更新了state之后<strong>出现了调用两次</strong>的情况。<strong>state会驱动页面更新，通过重新调用render方法</strong>。</li></ol><p>那么render方法重新执行的时候，这个input标签这一行是不是也要被重新执行？然后程序又发现你这个标签里面有一个回调式的refs，是不是又要来执行这个函数？但是这个函数已经是一个新函数了，之前的那个函数已经执行完成了，那一块内存就自动释放了。所以这里是一个全新的回调函数。但是程序并没法确定之前那次回调函数都接到了什么。虽然我们都知道上一次函数接到的是当前所在的DOM节点，但是程序是不知道的，正是这个原因。所以<strong>程序必须要保证上一次这个回调函数的结果被清空，所以才会先调一次这个回调函数并且传入null来确保上次的结果清空了，然后再调一次这个回调函数来传入当前所在节点。</strong></p><h4 id="class的绑定函数"><a href="#class的绑定函数" class="headerlink" title="class的绑定函数"></a>class的绑定函数</h4><ol><li>在构造器里调用this.method &#x3D; this.method.bind(this)</li><li>在类中使用赋值语句配合箭头函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;<span class="variable language_">this</span>.<span class="property">bindInput2</span>&#125; onBlur=&#123;<span class="variable language_">this</span>.<span class="property">blurData</span>&#125; placeholder=<span class="string">&quot;失去焦点&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>更新了状态也还是一次。所以说通过这种方法就可以解决回调式refs调用两次的情况。但是官方也明确说明了，即便调用两次这种内联函数的形式，其实对我们的程序没有任何影响。所以后期的开发或者是案例，我们还是以写内联函数居多。</li></ol><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><ul><li>回调式refs会在页面第一次被渲染时调用一次</li><li>如果回调式refs是内联函数形式，那么在state更新之后，会被重新调用两次</li><li>内联函数形式的回调式refs调用次数对程序不会有影响</li><li>类组件绑定函数的方式可以解决refs被多次调用的问题</li></ul><h3 id="3-4-使用-createRef"><a href="#3-4-使用-createRef" class="headerlink" title="3.4 使用 createRef"></a>3.4 使用 createRef</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  myRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;click&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  showData = <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">current</span>.<span class="property">value</span>); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其实只要调用了React.createRef那么就会得到一个容器，这个容器里面会收集所有被ref属性标识的DOM节点。</li><li>myRef &#x3D; React.createRef();把我们调用React.createRef得到的容器放在组件实例对象自身上的myRef属性了。那么我们在标签里的ref属性就直接ref&#x3D;{this.myRef}。</li><li>当react通过组件实例对象调用了render方法的时候发现这个input标签里面有个ref属性，而且这个属性还是React.createRef返回的一个容器，就自动把当前的DOM节点传入到了这个容器中</li><li>如果有多个<code>ref = this.myRef</code>，会覆盖掉</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1674828331178-8a4f41e7-f7a4-4411-b2f2-5ed43c52436d.png" alt="image.png"></p><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><ul><li>createRef可以返回一个容器用于存放被ref属性标识的DOM节点</li><li>createRef返回的容器“专人专用”</li><li>如果多个标签要被标识，就要创建多个容器</li></ul><h3 id="3-5-总结refs"><a href="#3-5-总结refs" class="headerlink" title="3.5 总结refs"></a>3.5 总结refs</h3><h4 id="字符串形式ref"><a href="#字符串形式ref" class="headerlink" title="字符串形式ref"></a>字符串形式ref</h4><p>在标签里直接写ref属性，然后给字符串形式的值<br />但是官方已经不在推荐使用字符串形式的ref所以说要尽量避免使用字符串形式的refs</p><h4 id="回调式refs"><a href="#回调式refs" class="headerlink" title="回调式refs"></a>回调式refs</h4><p>一个回调函数，直接通过回调函数把被标识的DOM节点挂在组件实例对象自身，不用纠结是不是内联函数，不重要，没有影响。也是我个人最喜欢的方式</p><h4 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h4><p>会返回一个容器，但是容器“专人专用”，多个标签被标识就要创建多个容器，最麻烦了。虽然官方最推荐这种。但是我不接受官方的推荐。</p>]]></content>
      
      
      <categories>
          
          <category> React学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React组件三大属性回顾</title>
      <link href="/2023/03/10/React%E5%AD%A6%E4%B9%A0/React%E7%BB%84%E4%BB%B6%E4%B8%89%E5%A4%A7%E5%B1%9E%E6%80%A7%E5%9B%9E%E9%A1%BE/"/>
      <url>/2023/03/10/React%E5%AD%A6%E4%B9%A0/React%E7%BB%84%E4%BB%B6%E4%B8%89%E5%A4%A7%E5%B1%9E%E6%80%A7%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="state属性"><a href="#state属性" class="headerlink" title="state属性"></a>state属性</h2><p>我们知道最难的属性就是组件的state属性。那么state中我们都学习了些什么呢？</p><h3 id="对state的理解"><a href="#对state的理解" class="headerlink" title="对state的理解"></a>对state的理解</h3><ul><li>state是一个状态属性，这个属性中存放着某些数据，<strong>通过更新state中的数据可以驱动页面重新渲染</strong>，从而使得页面可以动态加载和更新。</li><li>state在类组件的实例对象上</li><li>一个组件如果拥有state，那么该组件则是复杂组件</li></ul><h3 id="初始化state"><a href="#初始化state" class="headerlink" title="初始化state"></a>初始化state</h3><ul><li>state的类型是一个对象</li><li>satte初始化要<strong>借助构造器</strong>，或者<strong>直接使用赋值语句</strong></li><li>如果<strong>使用构造器方法需要接受props并且传给super方法</strong></li><li>需要通过this来调用state</li></ul><h3 id="react事件绑定"><a href="#react事件绑定" class="headerlink" title="react事件绑定"></a>react事件绑定</h3><ul><li>原生js添加点击事件有三种方法<ul><li>addEventListener方法</li><li>onclick方法</li><li>onclick属性配合回调函数</li></ul></li><li>react中允许使用原生js中的方法</li><li>react不推荐使用addEventListener和onclick，大力推崇onClick属性配合回调函数</li><li>react中onClick属性中click首字母必须大写</li><li>onClick属性不能用引号括起来，<strong>需要用{}括起来</strong></li><li>onClick属性<strong>必须是函数</strong>，所以函数名后面不可以加()</li></ul><h3 id="类方法中的this指向"><a href="#类方法中的this指向" class="headerlink" title="类方法中的this指向"></a>类方法中的this指向</h3><ul><li>react类组件中推荐将<strong>类组件需要用到的函数全部包含在类里，以方法的形式来写</strong></li><li>类组件中的<strong>方法要通过this调用</strong></li><li><strong>类方法赋值给变量或者作为事件监听的回调的话，对该方法的调用属于函数直接调用而不是通过类的实例对象调用</strong></li><li>类中所有方法都默认局部开启了strict模式</li><li>bind(this)做了两件事<ul><li>生成新函数</li><li><strong>修改新函数中的this指向</strong></li></ul></li><li>实例对象调用属性和方法会先从自身查找，自身没有才会顺着原型链去查找原型对象</li><li>this.notify &#x3D; this.notify.bind(this)是将原型对象上的notify方法生成新函数并修改this指向之后存放在实例对象自身</li></ul><h3 id="使用setState方法"><a href="#使用setState方法" class="headerlink" title="使用setState方法"></a>使用setState方法</h3><ul><li>react不支持直接修改state，<strong>必须通过setState方法来修改state</strong></li><li>setState存放在React.Component的原型对象上</li><li>setState方法<strong>接收的参数是一个对象</strong></li><li>setState方法并<strong>不是直接全局替换掉原来的state而是合并</strong></li><li>整个过程中类组件的构造器方法只被调用一次</li><li>render方法被调用1 + n次</li></ul><h3 id="简写state"><a href="#简写state" class="headerlink" title="简写state"></a>简写state</h3><ul><li>标准写法比较繁琐，在实际开发中会拖慢我们的进度，所以要进行精简</li><li>精简后的代码结构分为三个部分，就目前来说，不需要构造器，至于后面要不要我们再说</li><li><strong>赋值语句直接初始化状态</strong></li><li>render方法</li><li>自定义方法，所有<strong>自定义方法全部使用赋值语句加箭头函数来写</strong></li><li><strong>箭头函数自身没有this</strong></li><li>箭头函数中如果要使用this，那么就会去查找箭头函数外层的this并作为自己的this来使用</li></ul><h2 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h2><p>学习完了state属性之后，我们又开始了第二个属性props</p><h3 id="props的基本应用"><a href="#props的基本应用" class="headerlink" title="props的基本应用"></a>props的基本应用</h3><ul><li>props是一个对象</li><li>props是通过外面往组件内传入数据</li><li>props在组件的实例对象上可以通过this调用</li><li>props可以在组件标签处通过标签属性传入</li></ul><h3 id="批量传入props"><a href="#批量传入props" class="headerlink" title="批量传入props"></a>批量传入props</h3><ul><li>props可以在标签中使用<strong>展开运算符</strong>展开一个对象来批量传入属性</li><li>props在使用展开运算符时必须确保被展开对象中的属性和解构props时的变量<strong>一致才能正常取数</strong></li><li>展开运算符<strong>在原生js语法中不能展开对象</strong></li><li>babel和react库支持<strong>仅在组件标签批量传入属性时展开对象</strong></li></ul><h3 id="对props进行限制"><a href="#对props进行限制" class="headerlink" title="对props进行限制"></a>对props进行限制</h3><ul><li>限制并不是必须的</li><li>限制props必须引入prop-types</li><li>限制可以避免一些不必要的错误</li><li>限制有三种场景<ul><li>限制属性是否必须非空</li><li>限制属性类型</li><li>限制属性默认值</li></ul></li><li>限制属性类型为函数时，不能用function而要用func</li></ul><h3 id="简写props"><a href="#简写props" class="headerlink" title="简写props"></a>简写props</h3><ul><li>propsTypes和defaultProps必须是组件类自身的属性，不是实例对象的属性</li><li>用static关键字给类自身添加属性</li><li>props是只读的</li></ul><h3 id="类中构造器和props"><a href="#类中构造器和props" class="headerlink" title="类中构造器和props"></a>类中构造器和props</h3><ul><li>类组件不写构造器完全可以，而且能不写就尽量不写</li><li>构造器中props传给super和不传给super的区别就是在构造器中能否通过this访问到props</li></ul><h3 id="函数式组件使用props"><a href="#函数式组件使用props" class="headerlink" title="函数式组件使用props"></a>函数式组件使用props</h3><ul><li>函数式组件目前只能使用props</li><li>函数式组件使用参数来接收props</li><li>函数式组件可以限制props但是只能写在函数体外</li></ul><h2 id="refs属性"><a href="#refs属性" class="headerlink" title="refs属性"></a>refs属性</h2><p>那么我们来回忆一下最后一个属性。</p><h3 id="字符串形式的rfs"><a href="#字符串形式的rfs" class="headerlink" title="字符串形式的rfs"></a>字符串形式的rfs</h3><ul><li>refs是一个收集各个标签ref属性来作为标识的一个对象</li><li>refs可以代替document.getElementById方法来获取页面节点</li><li>refs可以配合事件处理来完成相应的功能需求。</li></ul><h3 id="回调形式的refs"><a href="#回调形式的refs" class="headerlink" title="回调形式的refs"></a>回调形式的refs</h3><ul><li>回调式refs不会自动收集到this.refs中</li><li>字符串式refs有问题，后期可能会废弃</li><li>回调式refs所传入的ref属性是一个回调函数</li><li>回调式refs是将传入的标签节点传入回调函数，并通过回调函数将标签节点挂在实例自身</li></ul><h3 id="回调式refs被调用的次数"><a href="#回调式refs被调用的次数" class="headerlink" title="回调式refs被调用的次数"></a>回调式refs被调用的次数</h3><ul><li>回调式refs会在页面第一次被渲染时调用一次</li><li>如果回调式refs是内联函数形式，那么在state更新之后，会被重新调用两次</li><li>内联函数形式的回调式refs调用次数对程序不会有影响</li><li>类组件绑定函数的方式可以解决refs被多次调用的问题</li></ul><h3 id="使用createRef"><a href="#使用createRef" class="headerlink" title="使用createRef"></a>使用createRef</h3><ul><li>createRef可以返回一个容器用于存放被ref属性标识的DOM节点</li><li>createRef返回的容器“专人专用”</li><li>如果多个标签要被标识，就要创建多个容器</li></ul>]]></content>
      
      
      <categories>
          
          <category> React学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见问题</title>
      <link href="/2023/03/10/React%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/10/React%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> React学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>return方法添加括号()或者[]</title>
      <link href="/2023/03/10/React%E5%AD%A6%E4%B9%A0/return%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7()%E6%88%96%E8%80%85%5B%5D/"/>
      <url>/2023/03/10/React%E5%AD%A6%E4%B9%A0/return%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7()%E6%88%96%E8%80%85%5B%5D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/fightjianxian/p/12350083.html">React之JSX里render中return方法添加括号()或者[] - 剑仙6 - 博客园</a></p><ol><li>圆括号的作用是分割作用域和执行，在render中是给babel-jsx解析用的，这样写更符号原生编码习惯的的思维，也方便解析</li><li>return的圆括号只是为了代码换行，不用括号的话将根元素和return写在同一行</li><li><strong>JavaScript 会自动给行末添加分号。如果 return 后面换行不加括号就会变成 return;</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> React学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>受控组件和非受控组件</title>
      <link href="/2023/03/10/React%E5%AD%A6%E4%B9%A0/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/"/>
      <url>/2023/03/10/React%E5%AD%A6%E4%B9%A0/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>React中的组件分为受控组件和非受控组件<br />受控组件的两个要点： </p><ul><li>组件的value属性与React中的状态绑定</li><li>组件内声明了onChange事件处理value的变化</li><li>非受控组件更像是传统的HTML表单元素，数据存储在DOM中，而不是组件内部，获取数据的方式是通过ref引用</li></ul><p>一些建议： </p><ul><li>尽可能使用受控组件</li><li>受控组件是将状态交由React处理，可以是任何元素，不局限于表单元素</li><li>对于有大量表单元素的页面，使用受控组件会使程序变得繁琐难控，此时使用非受控组件更为明智</li><li>在受控组件中，数据流是单向的(state是变化来源)，因此在改变state时都应该使用setState，而不要强制赋值</li><li>Refs不能用于函数式组件，因为函数式组件没有实例</li><li>在函数式组件内部，是可以使用Refs的</li></ul>]]></content>
      
      
      <categories>
          
          <category> React学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对象属性名</title>
      <link href="/2023/03/10/React%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%90%8D/"/>
      <url>/2023/03/10/React%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_43485006/article/details/115529266">ES6对象属性名简洁表示法和表达式、对象新方法、属性的遍历_对象的属性名可以是表达式_易函123的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> React学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4 - 朗顿的蚂蚁</title>
      <link href="/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter4%20-%20%E6%9C%97%E9%A1%BF%E7%9A%84%E8%9A%82%E8%9A%81/"/>
      <url>/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter4%20-%20%E6%9C%97%E9%A1%BF%E7%9A%84%E8%9A%82%E8%9A%81/</url>
      
        <content type="html"><![CDATA[<p>本章将介绍一个全新的人工生命模型——朗顿的蚂蚁。</p><h2 id="4-1-朗顿的蚂蚁"><a href="#4-1-朗顿的蚂蚁" class="headerlink" title="4.1 朗顿的蚂蚁"></a>4.1 朗顿的蚂蚁</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677592021921-46f18b95-8ed4-4bd4-9fc0-6b3f176e108a.png" alt="image.png"><br>我们会看到一只小蚂蚁在模拟世界里爬来爬去，神奇之处在于，模型运行时间足够长的话，这只蚂蚁会产生令人惊喜的行为，它会在模拟世界中修建出一条“高速公路”，而且这一现象是不依赖于初始条件的，如图4-1所示。通过这个人工生命的简单例子，我们还将介绍如何实现turtle与patch之间的互动。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677591076428-a4ce207e-dc63-4d94-9a3c-cdc1751d42d2.png" alt="image.png"></p><ol><li>规则一：如果当前这只蚂蚁所处的方格是白色的，则蚂蚁向右侧旋转90度，将方格涂成黑色，并且往前移动一格</li><li>规则二：如果当前这只蚂蚁所处的方格是黑色的，则蚂蚁向左侧旋转90度，将方格涂成白色，并且往前移动一格</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677591126273-94f10c33-9b08-4063-9429-e8fc22f26afe.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677591132834-24eeab24-95c0-4d1b-8f5e-31b58ee69378.png" alt="image.png"></p><h2 id="4-2-创建蚂蚁"><a href="#4-2-创建蚂蚁" class="headerlink" title="4.2 创建蚂蚁"></a>4.2 创建蚂蚁</h2><ol><li><code>heading</code>是<code>turtle</code>的一个属性</li><li><code>netlogo</code>字典中有<code>turtle</code>的相关属性和方法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">to setup</span><br><span class="line">    clear-all</span><br><span class="line">    create-turtles <span class="number">1</span> [</span><br><span class="line">        set heading random <span class="number">3</span> * <span class="number">90</span></span><br><span class="line">    ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol><h3 id="random命令"><a href="#random命令" class="headerlink" title="random命令"></a>random命令</h3><p><code>random x</code>。<br />x是一个整数，<br />如果x&gt;0, random x产生一个介于0和x之间的随机数<br />如果x&lt;0,random x产生一个介于x和0之间的随机数。<br />第3章提到了一个命令random-float，这里random x产生的随机数一定是整数，这是它和random-float最大的不同。<br />接下来具体解读<code>set heading random 3 * 90</code>这条语句。<br />大家可能会把它解读成设置turtle的朝向为在0度到270度之间随机取一个整数，它可以取30度、60度，也可以取90度。但其实并非如此，之所以大家会理解有误，主要原因在于不熟悉NetLogo的语法。<br /><strong>random命令后面的数字3是作为random这个函数的参数来调用的</strong>，它会先从0、1、2、3这4个数字里随机取一个整数，然后把数值乘以90。因此heading的取值只能有4种可能，分别是0、90、180、270。也就是说，这条语句相当于:<br /><code>set heading = (random 3) * 90</code></p><h2 id="4-3-让蚂蚁动起来"><a href="#4-3-让蚂蚁动起来" class="headerlink" title="4.3 让蚂蚁动起来"></a>4.3 让蚂蚁动起来</h2><ol><li><code>right x</code>是让蚂蚁向右转动<code>x</code>度 &#x3D; <code>left (-x)</code> </li><li><code>left x</code>是让蚂蚁向左转动<code>x</code>度</li><li>一个<code>turtle</code>对应于一个<code>patch</code>，但是一个<code>patch</code>可以对应多个<code>turtle</code>。如果要获得所有的<code>turtle</code>，使用<code>turtles-here</code>命令。所以在遍历<code>turtles</code>时，由于关系的对应，可以获得特定的<code>patch</code>的相关属性</li><li>使用<code>tick</code>计时<ol><li>tick来源于英文单词tick，这是一个象声词（“嘀嗒”），就像跑步比赛用秒表来计时一样，一开跑就按下秒表开始计时。</li><li>在setup代码中添加reset-ticks，也就是在<strong>每一次初始化时，重置秒表</strong>，然后在togo代码块中添加tick，表示<strong>每一个模拟周期计数一次</strong>。</li></ol></li><li>如果按下“go”按钮，它并不是一步一步运行的，原因是“<strong>视图更新方式</strong>”设置了“<strong>连续更新</strong>”，这里换成“<strong>按时间步更新</strong>”。现在运行就是一步一步显示了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">to go</span><br><span class="line">    ask turtles[</span><br><span class="line">        ifelse (pcolor = white)[</span><br><span class="line">            right <span class="number">90</span></span><br><span class="line">            set pcolor black</span><br><span class="line">            forward <span class="number">1</span></span><br><span class="line">        ][</span><br><span class="line">            left <span class="number">90</span></span><br><span class="line">            set pcolor white</span><br><span class="line">            forward <span class="number">1</span></span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">to setup</span><br><span class="line">  clear-all <span class="comment">// 清除页面中的所有元素</span></span><br><span class="line">  reset-ticks <span class="comment">// 重新设定计时器</span></span><br><span class="line">  create-turtles <span class="number">1</span>[ <span class="comment">// 创造 1 个turtle</span></span><br><span class="line">  <span class="function">set <span class="title">heading</span> <span class="params">(random <span class="number">3</span>)</span> * 90  </span></span><br><span class="line"><span class="function">    <span class="comment">// set heading random 3 * 90 两者是等价的</span></span></span><br><span class="line"><span class="function">  ]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">to go</span></span><br><span class="line"><span class="function">  ask turtles[</span></span><br><span class="line"><span class="function">    <span class="title">ifelse</span> <span class="params">(pcolor = white)</span>[</span></span><br><span class="line"><span class="function">      right 90</span></span><br><span class="line"><span class="function">      set pcolor black</span></span><br><span class="line"><span class="function">    ][</span></span><br><span class="line"><span class="function">      left 90</span></span><br><span class="line"><span class="function">      set pcolor white</span></span><br><span class="line"><span class="function">    ]</span></span><br><span class="line"><span class="function">    forward 1</span></span><br><span class="line"><span class="function">  ]</span></span><br><span class="line"><span class="function">  tick</span></span><br><span class="line"><span class="function">end</span></span><br></pre></td></tr></table></figure><blockquote><p>那为什么这只蚂蚁要在走一万多步以后才开始修建“高速公路”呢?<br>谁也不知道答案，包括朗顿自己。后来很多科学家想通过数学分析的方式给出答案。在不同的条件下是否会产生不同的轨道?我们反复不停地随机初始化它的条件，发现它在一万多步的时候总是会修建出这样的“高速公路”，尽管每次“高速公路”的朝向以及它起始的时间可能会不太一样，但是修建“高速公路”似乎是朗顿的蚂蚁模拟程序的一个吸引子一样。为什么朗顿的蚂蚁会修建这样一条“高速公路”仍然是一个谜，这就是复杂系统的涌现行为。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5  - 从羊－草生态系统深入turtle与plot画图</title>
      <link href="/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter5%20%20-%20%E4%BB%8E%E7%BE%8A%EF%BC%8D%E8%8D%89%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5turtle%E4%B8%8Eplot%E7%94%BB%E5%9B%BE/"/>
      <url>/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter5%20%20-%20%E4%BB%8E%E7%BE%8A%EF%BC%8D%E8%8D%89%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5turtle%E4%B8%8Eplot%E7%94%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>本章将介绍一个全新的NetLogo多主体模型，它是由羊和草两个物种构成的简单的生态系统。<br />羊-草生态系统模拟了自然界和人类社会都存在的最基本的生存逻辑：<strong>个体生存依赖一定的资源</strong>。这些资源可以是食物，也可以是财富、声望、权力、关系等。资源可以从环境中获得，它可以给个体带来好处（维持生存、达到行动目标），而失去资源将使个体处于不利的境地，不论是因为缺少食物而饿死，还是因为声誉损耗殆尽而无法在某地继续生存。<br /><strong>羊-草生态系统是关于系统内部食物、财富、声望、权力、关系等资源变化的基本模型，它以“羊”代表“个体”，以“草”代表“资源”</strong>，通过它我们可以研究资源分布、资源存量与个体生存及繁衍间的动态关系。掌握了羊-草生态系统模型，我们就可以将其扩展到其他资源和个体关系领域</p><h2 id="5-1-羊-草生态系统规则"><a href="#5-1-羊-草生态系统规则" class="headerlink" title="5.1 羊-草生态系统规则"></a>5.1 羊-草生态系统规则</h2><ol><li>这是一个由羊（turtle）和草（patch）两个物种构成的小型生态系统。</li><li>羊的内部有一个能量值。吃掉草可以增加能量值。每一个周期都在消耗能量。能量值小于或等于0，羊就会死掉。</li><li>羊能够繁殖。当能量累积到一定水平，就会繁殖。繁殖需要消耗能量。新出生的羊会天然具备一定的能量。</li><li>草可以自发地从地里长出来。</li></ol><h2 id="5-2-初始化羊－草生态系统"><a href="#5-2-初始化羊－草生态系统" class="headerlink" title="5.2 初始化羊－草生态系统"></a>5.2 初始化羊－草生态系统</h2><p>下面用NetLogo实现这个基本的程序，首先初始化生态系统。<br />在“界面”添加“setup”按钮。由于羊的内部都有一个能量值，因此我们需要<strong>自定义一个turtle的属性—— energy</strong>。跟第4章讲的patches-own语法类似，<strong>使用turtles-own命令</strong>，方括号内是变量名energy：<br /><code>turtles-own[energy]</code> <br />接下来，清空之前的所有状态，如下所示：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677601691209-8fa712e3-b43b-4f02-bce5-719e3b0ddd24.png" alt="image.png"><br>然后动态地向生态系统添加草。本次模拟设置20%的草，80%的空地。</p><ol><li>首先使用ask patches对所有patch进行循环，</li><li>random-float命令产生一个0<del>1之间的随机小数 <code>**random-float n**</code>**产生一个0</del>n之间的随机小数**</li><li>这个数值如果小于0.2，就把当前patch设置成绿色。<code>set pcolor green</code> &#x3D; <code>pcolor = green</code></li><li>因此总体运行效果就是近20%的patch变成绿色，这样草的初始化就完成了。代码如下：</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677601706109-7846cf84-a10e-4855-ba4b-647d34f43340.png" alt="image.png"><br>接下来初始化系统中的羊，使用<strong>create-turtles命令创建一只羊</strong>，并且把它的初始能量设置成100，否则这只羊没有能量用于移动。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677601715216-ae195212-c84e-4c0a-bae4-e6e16d8fda6f.png" alt="image.png"><br>以上这部分就是初始化功能，完成后我们可以运行一下。每次单击“setup”按钮，都会随机产生20%的绿草，羊就位于这个世界的中心位置。初始化的生态系统完整的初始化程序如下：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677601726244-093458f2-8100-43fc-937f-4b8cb08207aa.png" alt="image.png"></p><h2 id="5-3-添加to-go程序"><a href="#5-3-添加to-go程序" class="headerlink" title="5.3 添加to go程序"></a>5.3 添加to go程序</h2><p>接下来添加“go”按钮的程序，即每一个模拟周期要完成的功能。根据前述生态系统的规则，每一个模拟周期都要完成如下功能：</p><ol><li>草要自然生长</li><li>每只羊要不断地移动</li><li>羊在能量积累到一定值时繁育后代</li><li>如果羊的能量消耗尽，就会死亡。</li><li>我们用子函数（也称子模块）的方式实现这几个功能，在“go”按钮对应的代码中添加如下语句：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">to go</span><br><span class="line">    add_food                 ；；添加食物子函数</span><br><span class="line">    ask turtles[</span><br><span class="line">        turtle_move         ；；turtle移动子函数</span><br><span class="line">        turtle_breed        ；；turtle繁殖子函数</span><br><span class="line">        turtle_die          ；；turtle死亡子函数</span><br><span class="line">    ]</span><br><span class="line">    tick</span><br><span class="line">end</span><br></pre></td></tr></table></figure>执行程序时，它就会调用相应子函数，从而实现整体功能。接下来我们看看每一个功能模块如何操作。</li></ol><h3 id="5-3-1-add-food"><a href="#5-3-1-add-food" class="headerlink" title="5.3.1 add_food"></a>5.3.1 add_food</h3><p>为了实现添加草的功能，我们添加了一个<strong>自定义模块</strong>，该模块跟to setup、to go代码类似，<strong>用to作为关键词，后面跟要定义的模块名称，最后用end结束，这样用户就可以定义自己的函数了。</strong>add_food函数要实现的功能就是在每个周期都添加一定量的草。可以添加如下代码：</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677601790366-b00ba31f-fb22-40df-9de2-de77b23bac3e.png" alt="image.png"><br>这里用到了一个具有强大功能的函数——n-of。它的一般格式为：<code>**n-of size agentset**</code>。<br /><code>**n-of 10 patches**</code><strong>的作用就是从patches集合中随机挑选10个patch，形成了一个新的patches集合。</strong><br />有了集合以后，再对集合中的每一个元素进行循环，将其颜色设置成绿色，无论这个patch当前是绿色的还是黑色的。<br />该函数的作用相当于下了一场“食物雨”，每一个模拟周期都会运行一遍add_food函数，都会有10个单位的patch添加上草。<br />完成了第一步add_food的操作，接下来要做的就是循环访问现在系统中所有的turtle，并且每一个turtle的一生都伴随着3件事——移动、繁殖和死亡。</p><h3 id="5-3-2-turtle-move"><a href="#5-3-2-turtle-move" class="headerlink" title="5.3.2 turtle_move"></a>5.3.2 turtle_move</h3><p>关于第二个功能，首先我们来看羊的移动需要哪些操作，同样用一个子模块的方式定义移动相关代码，如下所示：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677601810252-1cba0107-6379-4059-a384-a88c94da31cb.png" alt="image.png"><br>它要实现的功能包括如下几点。</p><ol><li>如果当前patch是绿色的，即上面有草，那么这只羊会吃掉草，羊的能量也相应增加。这里设置羊的energy增加10，并将当前patch的颜色设置为黑色，表示草被吃掉了。这就是第一部分代码所完成的功能。</li><li>为了使羊的移动看起来更自然，我们<strong>让羊在每个周期以0.2的概率随机转换方向，其他时间都匀速直线前进</strong></li><li>羊的移动功能。每个周期都消耗1个单位的能量，向前移动一步。这三部分代码都可以通过前面讲过的知识完成。<strong>如何设置变量的值、如何产生随机数、如何设置turtle的运动方向、用fd 1完成移动</strong>（这里fd是forward的缩写），这些语句组合在一起就实现了turtle_move这个函数。</li></ol><h3 id="5-3-3-turtle-breed"><a href="#5-3-3-turtle-breed" class="headerlink" title="5.3.3 turtle_breed"></a>5.3.3 turtle_breed</h3><p>接下来用turtle_breed来完成繁殖这部分功能，代码如下所示<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677601844251-9dd9f48c-a635-4cc1-b98d-42bba1e271a5.png" alt="image.png"><br>在这部分代码中，<strong>首先检测这只羊的能量水平是否足够繁育后代</strong>，这里规定当它的能量值大于500时才能够繁育后代。繁育后代涉及两件事情，</p><ol><li>是自己的能量值减少。这部分代码也体现了为人父母的辛苦，养育后代要消耗自身大量能量。</li><li>是新生儿的出生。这里用到一个新命令——<strong>hatch</strong>。hatch的英文含义是孵化，非常形象。<strong>方括号内的这部分内容就是针对新出生的这只羊的。</strong>这只新出生的羊要完成两个操作，<ol><li>第一是往前走一步——fd 1，<strong>新出生的羊的指向heading是随机取值的，往前走一步就可以跟它的母体分开。</strong></li><li>第二个操作是<strong>给新出生的羊一个初始能量</strong>，否则它一出生就死掉了。此处把它的能量值设置成100。这样就完成了繁殖功能。</li></ol></li></ol><h3 id="5-3-4-turtle-die"><a href="#5-3-4-turtle-die" class="headerlink" title="5.3.4 turtle_die"></a>5.3.4 turtle_die</h3><p>最后一个功能是turtle_die，判断一只羊的能量值小于或等于0，它就会死掉。在NetLogo中，我们可以用die这个单词作为命令来杀死turtle。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677601862611-9d0b7a88-a522-4c6b-938d-aa25e00dff6d.png" alt="image.png"><br>以上就是羊-草生态系统模型所需要的代码，运行一下看看它的效果。单击“setup”按钮，然后单击“go”按钮，开始可能大家会觉得画面非常乱，稍微把速度调慢一点儿，这时你就会看到有一些用小箭头表示的羊在环境里随机游走，并且可以吃掉草<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677601899764-f1199f33-2630-4b7c-a89c-18f6416a771b.png" alt="image.png"> <br />我们可以重新运行程序，开始的时候只有一只羊，很快它就会繁殖出更多的羊，大家可以看到它的繁殖过程。只要吃掉的草足够多，它就可以进行繁殖。</p><h2 id="5-4-追踪某一个具体的turtle或者patch的行为"><a href="#5-4-追踪某一个具体的turtle或者patch的行为" class="headerlink" title="5.4 追踪某一个具体的turtle或者patch的行为"></a>5.4 追踪某一个具体的turtle或者patch的行为</h2><ol><li>右击turtle，可以对turtle进行inspect、watch和follow操作<ol><li>inspect：弹出记录了turtle属性的窗口</li><li>watch：指定的turtle周围出现聚焦的圆圈</li><li>follow：指定turtle出现在屏幕中心位置</li></ol></li><li>右击patch，可以对patch进行inspect操作</li></ol><h2 id="5-5-变量的主体"><a href="#5-5-变量的主体" class="headerlink" title="5.5 变量的主体"></a>5.5 变量的主体</h2><ol><li>NetLogo中的每一个变量都有隶属关系</li><li>如果不是在ask turtles这个循环里调用turtle_move子函数，它的调用主体就不是turtle了，而是一个全局的调用主体obsever，obsever没有pcolor、energy属性，程序就会提示错误。</li></ol><h2 id="5-6-添加绘图框"><a href="#5-6-添加绘图框" class="headerlink" title="5.6 添加绘图框"></a>5.6 添加绘图框</h2><ol><li>在NetLogo“界面”加号旁边的<strong>下拉框中选中“图”（plot）</strong>，选中时鼠标指针变成一个十字，然后在空白处单击，就会出现一个弹框</li><li>设置“名称”为Population（种群）；设置它的“X轴标记”为Time，显示时间；“Y轴标记”设置为Population，显示种群数量；X和Y的最小值和最大值可以设置，也可以不设置；<strong>勾选“自动调整尺度”后，如果曲线的最大值超过坐标的最大值，绘图框将自动调节坐标最大值</strong>；“显示图例”就是在绘图框右侧位置标出每一个片条对应的曲线；“绘图笔”对应图中曲线。</li><li>第一条曲线绘制系统中羊群数量随时间变化的趋势。我们可以修改绘图笔的颜色为黑色，名称设为sheep。这里<strong>请尽量用英文来设置</strong>，因为有时曲线名称会对应函数来进行调用，写中文的话可能会出错。</li><li>“绘图笔更新命令”表示实现这条曲线需要的代码，在每一次绘制这条曲线的新点的时候，需要激活这部分代码来实现绘图功能，默认代码plot count turtles刚好满足我们的需求。<strong>plot语句的作用就是绘制图形，count turtles就是统计turtle的数量。</strong></li><li>第二条曲线绘制草总量的变化情况。添加一个绘图笔，把它的颜色改为绿色，名称改成grass。这时绘图命令就需要我们手动填写了<code>plot count patches with [pcolor = green]</code>这条命令表示绘制曲线，统计当前pcolor属性是绿色的patch数量。单击“确定”，绘图框就设定好了。</li><li>重新运行程序，你会发现运行得很好，但是右侧新加入的绘图框没有任何反应。这是因为在NetLogo当前版本中，只有设定了tick，绘图框才会生效。这点不难理解，<strong>不设置tick时，模拟世界有一个时钟，绘图本身的更新也有一个时钟，我们用tick来做模拟世界和绘图框的时间同步。</strong>跟之前的程序设定一样，在setup代码中添加<strong>reset-ticks</strong>进行重置，然后在to go代码中添加<strong>tick</strong>进行计时。这时再运行程序，就画出了漂亮的曲线</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677646172478-8500f441-096f-4cdb-a59a-2e96a8b5c490.png" alt="image.png"></p><h2 id="5-7-小结"><a href="#5-7-小结" class="headerlink" title="5.7 小结"></a>5.7 小结</h2><ol><li>介绍了pcolor、energy等每一个属性变量都有一个相应的调用主体，在实现子模块时要特别注意。</li><li>介绍了操作NetLogo界面追踪某一个具体的turtle或者patch的方法。这对于模型调试，以及理解turtle的行为是否正确，起到了重要作用。</li><li>介绍了如何添加plot绘图框。绘图框的使用非常方便，通过简单的设置就可以完成。但是要记得添加tick代码，确保模拟世界和绘图框的时间同步。</li><li>介绍了hatch和die两个关键字<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">turtles-own[energy]</span><br><span class="line">to setup</span><br><span class="line">  clear-all</span><br><span class="line">  reset-ticks</span><br><span class="line">  ask patches[</span><br><span class="line">    <span class="keyword">if</span> (random-<span class="type">float</span> <span class="number">1</span>) &lt; <span class="number">0.2</span>[</span><br><span class="line">      set pcolor green </span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">  create-turtles <span class="number">1</span>[</span><br><span class="line">    set energy <span class="number">100</span></span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">to go</span><br><span class="line">  tick</span><br><span class="line">  addFood ;; 添加食物子函数</span><br><span class="line">  ask turtles[</span><br><span class="line">    turtleMove</span><br><span class="line">    turtleBreed ;;turtle繁殖子函数</span><br><span class="line">    turtleDie ;;turtle死亡子函数</span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">to addFood  ;;每一个模拟周期都会运行一遍add_food函数，都会有<span class="number">10</span>个单位的patch添加上草</span><br><span class="line">  ;; n-of <span class="number">10</span> patches的作用就是从patches集合中随机挑选<span class="number">10</span>个patch</span><br><span class="line">  ;; 形成了一个新的patches集合</span><br><span class="line">  ask n-of <span class="number">10</span> patches[</span><br><span class="line">    set pcolor green</span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line">to turtleMove</span><br><span class="line">  <span class="keyword">if</span> pcolor = green [</span><br><span class="line">    set energy energy + <span class="number">10</span></span><br><span class="line">    set pcolor black </span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">if</span> random-<span class="type">float</span> <span class="number">1</span> &lt; <span class="number">0.2</span> [</span><br><span class="line">    set <span class="built_in">heading</span> (random <span class="number">360</span>) ;; 在每个周期以<span class="number">0.2</span>的概率随机转换方向，其他时间都匀速直线前进。</span><br><span class="line">  ]</span><br><span class="line">  set energy energy - <span class="number">1</span> ;; 每个周期都消耗<span class="number">1</span>个单位的能量，向前移动一步。</span><br><span class="line">  forward <span class="number">1</span> ;;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">to turtleBreed</span><br><span class="line">  <span class="keyword">if</span> energy &gt; <span class="number">500</span> [</span><br><span class="line">    set energy energy - <span class="number">500</span></span><br><span class="line">    ;; hatch。hatch的英文含义是孵化，非常形象。方括号内的这部分内容就是针对新出生的这只羊的。</span><br><span class="line">    hatch <span class="number">1</span> [</span><br><span class="line">      forward <span class="number">1</span> ;; 新出生的羊的指向heading是随机取值的，往前走一步就可以跟它的母体分开</span><br><span class="line">      set energy <span class="number">100</span> ;; 给新出生的羊一个初始能量，否则它一出生就死掉了。此处把它的能量值设置成<span class="number">100</span>。</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line">to turtleDie</span><br><span class="line">  <span class="keyword">if</span> energy &lt;= <span class="number">0</span>[</span><br><span class="line">    die ;;给新出生的羊一个初始能量，否则它一出生就死掉了。此处把它的能量值设置成<span class="number">100</span>。</span><br><span class="line">  ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter6 - 人工经济模型与turtle间的互动</title>
      <link href="/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter6%20-%20%E4%BA%BA%E5%B7%A5%E7%BB%8F%E6%B5%8E%E6%A8%A1%E5%9E%8B%E4%B8%8Eturtle%E9%97%B4%E7%9A%84%E4%BA%92%E5%8A%A8/"/>
      <url>/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter6%20-%20%E4%BA%BA%E5%B7%A5%E7%BB%8F%E6%B5%8E%E6%A8%A1%E5%9E%8B%E4%B8%8Eturtle%E9%97%B4%E7%9A%84%E4%BA%92%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>本章将介绍一个人工经济模型，通过该模型进一步理解turtle之间的互动</p><h2 id="6-1-货币转移模型"><a href="#6-1-货币转移模型" class="headerlink" title="6.1 货币转移模型"></a>6.1 货币转移模型</h2><p>社会经济中有一个显著的现象：财富分布的不均衡性。<br />早在19世纪，意大利著名经济学家维弗雷多·帕累托（Vilfredo Pareto）就分析了大量实证数据，发现财富分布遵循一条幂律分布曲线。<br />这条幂律分布曲线满足帕累托法则（Pareto principle），也叫二八定律，即20%的财富被80%的穷人拥有（图中绿色的区域），而80%的财富被20%的富人占有（图中黄色的区域），二八定律充分反映了社会财富分布的不均衡性。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677651149858-800b6772-6be5-4931-bf57-98270eb4fbee.png" alt="image.png">为了解释这种分布不均衡性，2000年，物理学家Victor M.Yakovenk提出了一个非常简单的人工经济模型：<strong>货币转移模型（money transfer model）</strong>。<br />在这个模型里，他把经济体比喻成分子，把货币量比喻成能量。对于一个气体系统来说，气体分子在碰撞过程中，能量只能从一个分子转移到另一个分子，而总能量保持守恒。经过大量碰撞，最终气体分子会达到一个非常不均等的能量分布状态。<br />货币在该模型中的分布也具有类似的特性。因此，货币转移模型符合如下基本规则：</p><ol><li>经济系统中人和财富的总量保持不变；</li><li>开始的时候，每个人都有等量的货币；</li><li>每当两个主体相遇，他们就随机分配财富。</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677651360910-bd100f83-3729-4cc6-aa0c-75432b75a1de.png" alt="image.png"></p><h2 id="6-2-添加全局变量"><a href="#6-2-添加全局变量" class="headerlink" title="6.2 添加全局变量"></a>6.2 添加全局变量</h2><p>首先打开NetLogo“界面”，添加两个按钮：“setup”和“go”，添加“go”按钮时勾选“持续执行”。然后添加一个全新的控件——“滑块”，使用滑块控件可以很方便地调整变量的数值。在“添加”下拉框中点选“滑块”，然后在空白处单击添加，这时会出现弹框，如图6-3所示。首先输入全局变量名称num_agents，代表主体个数，即货币转移模型中一共有多少人。“最小值”“增量”“最大值”用于设定数值变化范围，这里设定数值从1开始变到1000，增量是1，初始值设置成100，单击“确定”，这样全局变量就创建好了。拖动滑块，就可以看到变量的取值发生变化。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677655668683-7c12338f-6d0a-4492-84dd-d8f2be20d4b7.png" alt="image.png"><br>与此类似，我们可以再添加一个滑块来控制系统中的货币总量，变量名为total_money，取值范围选取1到1 000 000，增量为1，默认值设为10 000。这两个滑块所定义的总量值都可以在我们的代码中应用。</p><h2 id="6-3-初始化模拟世界"><a href="#6-3-初始化模拟世界" class="headerlink" title="6.3 初始化模拟世界"></a>6.3 初始化模拟世界</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">to setup</span><br><span class="line">  clear-all</span><br><span class="line">  reset-ticks</span><br><span class="line">  create-turtles num_agents[</span><br><span class="line">    <span class="function">set <span class="title">money</span> <span class="params">(total_money / num_agents)</span> </span>;; 初始情况下每个turtle都拥有相同的货币量</span><br><span class="line">    setxy random-xcor random-ycor  ;; 设置为随机取值，实现随机分布</span><br><span class="line">  ] ;; 除号两侧要保留空格</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="6-4-主体之间如何交互"><a href="#6-4-主体之间如何交互" class="headerlink" title="6.4 主体之间如何交互"></a>6.4 主体之间如何交互</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">to go</span><br><span class="line">    ask turtles[</span><br><span class="line">        let agsets other turtles-here</span><br><span class="line">        <span class="keyword">if</span> count agsets &gt;= <span class="number">1</span></span><br><span class="line">        [</span><br><span class="line">            <span class="built_in">transaction</span> (one-of agsets)</span><br><span class="line">        ]</span><br><span class="line">        forward <span class="number">1</span></span><br><span class="line">    ]</span><br><span class="line">    tick</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>在NetLogo里，<strong>let和set都是赋值语句</strong>，它们的用法一样，但二者有一个非常重要的区别：<strong>set只能应用于已经定义好的变量，而let适用于为第一次使用的变量赋值，它包含定义变量的意思。</strong></li></ol><p>比如变量agsets，前文并未定义，如果用set去赋值，系统会提示错误，所以这时必须使用let语句给agsets赋初始值。为什么以前没有遇到过let呢？比如初始化money时就没有定义过，其实<strong>turtles-own就给每一个turtle定义了money变量</strong>。另外像pcolor这样的变量，赋值前也没有先定义，但是<strong>pcolor是每一个patch都有的属性，它是NetLogo自带的变量</strong>，因此在初始化模拟世界时，patch的pcolor属性已经定义了。</p><ol start="2"><li><code>other turtles-here</code>，顾名思义，就是<strong>其他</strong>所有turtles-here。第4章讲过，turtle和patch存在多个turtle对应一个patch的情况，比如当前turtle是我，我站在一个patch上，这个patch上也可能有其他turtle。<ol><li><code>turtles-here</code>返回值就是当前patch上<strong>包含了我的所有turtle的集合</strong></li><li><code>other turtles-here</code>返回值就是当前patch上<strong>除我以外其他turtle的集合</strong>，即我的潜在交易对象</li></ol></li><li><code>one-of agsets</code><ol><li><code>one-of agentset</code>，从集合agentset中随机选择一个元素；</li><li><code>n-of n agentset</code>，从集合agentset中随机选择n个元素。</li><li>当元素个数不满足时，比如集合为空，它返回的也为空；小于n时，就返回小于n的所有元素。</li></ol></li></ol><h3 id="6-4-1-transaction模块"><a href="#6-4-1-transaction模块" class="headerlink" title="6.4.1 transaction模块"></a>6.4.1 transaction模块</h3><ol><li>类比于函数，有自己的参数，<strong>通过方括号传入</strong></li><li><code>let money1 ([money] of trader)</code>此处<code>[money] of trader</code>相当于我们在写Java或者Python这种面向对象语言时用到的trader.money，<strong>在NetLogo中是用of来表示的，并且变量要用方括号括起来，如果要访问多个变量，可以用逗号隔开。</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">to transaction [trader]</span><br><span class="line">    let deltam <span class="number">0</span></span><br><span class="line">    <span class="function">let <span class="title">money1</span> <span class="params">([money] of trader)</span></span></span><br><span class="line"><span class="function">    let <span class="title">epsilon</span> <span class="params">(random-<span class="type">float</span> <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    set <span class="title">deltam</span> <span class="params">(epsilon - <span class="number">1</span>)</span> * money + epsilon * money1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> money + deltam &gt;</span>= <span class="number">0</span> <span class="keyword">and</span> money1 - deltam &gt;= <span class="number">0</span></span><br><span class="line">    [</span><br><span class="line">        set money money + deltam</span><br><span class="line">        ask trader[</span><br><span class="line">            set money money1 - deltam</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-4-2-变量作用域"><a href="#6-4-2-变量作用域" class="headerlink" title="6.4.2 变量作用域"></a>6.4.2 变量作用域</h3><p>在主体之间相互交互时，有一个关键点：变量的作用域。首先对所有turtle进行循环。因为每个turtle会随机选当前patch的另一个turtle做交易，所以<strong>transaction模块的所有变量，特别是money变量，隶属于当前turtle。</strong>也就是说，turtle在不停地进行循环。假如循环到的当前turtle是agent1，那么这时transaction模块的money就是agent1相应的属性<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677656294659-dc4973b4-6b4c-4b49-9a3d-fdb97dc147f0.png" alt="image.png"><br>除去<code>[money] of trader（方括号配合 of 的限定）</code>和<code>set money money1 - deltam（作用域的限定）</code>中的money是trader的属性，其他money都是当前turtle也就是agent1的属性。在所有NetLogo程序里，<strong>一定要捋清楚变量到底隶属于谁，当出现多层嵌套的时候，一定要清楚其中任意一个变量到底是哪个主体的。</strong></p><h2 id="6-5-命令中心"><a href="#6-5-命令中心" class="headerlink" title="6.5 命令中心"></a>6.5 命令中心</h2><p>在编程中，首先要保证语法通顺，但是在代码实现过程中，也可能有一些逻辑错误，这时系统并不会报错。针对这个例子，如何验证程序中的逻辑是否正确呢？根据货币转移模型规则，系统中的人和货币的总量不变，但是代码中并没有验证这两个量是否守恒，所以需要一个调试手段来验证程序的正确性。我们可以使用命令中心的功能，通过命令交互的方式来访问整个NetLogo的变量。比如对于货币总量，我们可以在“观察者”那里输入以下命令：<br /><code>sum [money] of turtles</code> <br />它的作用就是把所有turtle的money组成一个集合，然后进行累加求和。<br />NetLogo是一个面向对象的层次性结构，它的最上层是observer，是<strong>由observer直接对整个系统进行操作的。</strong>因此我们刚才输入的命令实际是观察者（observer）输入的，它的返回结果也是由observer给出的。从返回值可以看到，它跟系统引入的货币量是一致的，<strong>小数是由于计算误差引起的，特别是过程中有随机小数把这些钱不停地进行分割，因此它在允许范围内会有一定误差。</strong></p><h2 id="6-6-绘制财富分布直方图"><a href="#6-6-绘制财富分布直方图" class="headerlink" title="6.6 绘制财富分布直方图"></a>6.6 绘制财富分布直方图</h2><ol><li><strong>调整绘图笔为条形</strong>，这样它就会以柱状图的方式显示图形</li><li>绘图命令也要改，因为默认命令比较适合绘制时间序列曲线，例如横坐标轴是时间、纵坐标轴是种群数量的图形。但是当前需要绘制模型每一时刻的财富分布情况，因此要删掉绘图命令，并且修改X轴标记为Wealth，Y轴标记为Counts，<strong>在绘图更新命令中添加自定义函数</strong>——to-update-plot，这样在绘图时就会动态调用绘图更新命令。</li></ol><p><code>histogram</code>直方图</p><ol><li>定义一个变量lst，该变量的值是所有turtle的money属性组成的集合，lst是一个数值列表，其中每一个数值对应某个turtle的财富值。</li><li>设定了统计小区间的个数为100。</li><li>if not empty? lst判断lst这个列表是否为空。这里<strong>empty?</strong> 是NetLogo自带的变量，该变量是一个布尔型变量，返回true或false。因此整个判断语句的意思是，如果lst不为空，则执行下面两行代码</li><li><code>set-plot-x-range 0 (max lst)</code><strong>设定了X轴的取值范围</strong>是从0到财富值的最大值。在默认情况下，它的取值范围是0~10，但是这并不合理，因为当turtle发生交易后，财富值有可能非常大，所以这时我们要动态调整它的最大值。</li><li><code>histogram lst</code>的作用是<strong>把lst变量以直方图的方式进行统计，并且把统计结果绘制到绘图界面。</strong>histogram是NetLogo自带的命令。</li><li><strong>保持模拟世界和绘图界面同步更新。</strong>在初始化代码中加入reset-ticks，然后在to go函数中添加tick进行计时，最后记得把“视图更新方式”选项改为“按时间步更新”<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">to to-update-plot</span><br><span class="line">    let lst [money] of turtles</span><br><span class="line">    set-histogram-num-bars <span class="number">100</span> ;; 设定了统计小区间的个数为<span class="number">100</span>。</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> empty? lst [</span><br><span class="line">        set-plot-x-range <span class="number">0</span> max lst</span><br><span class="line">        histogram lst</span><br><span class="line">    ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">turtles-own [money]</span><br><span class="line">to setup</span><br><span class="line">  clear-all</span><br><span class="line">  reset-ticks</span><br><span class="line">  create-turtles num_agents[</span><br><span class="line">    <span class="function">set <span class="title">money</span> <span class="params">(total_money / num_agents)</span> </span>;; 初始情况下每个turtle都拥有相同的货币量</span><br><span class="line">    setxy random-xcor random-ycor  ;; 设置为随机取值，实现随机分布</span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line">to go</span><br><span class="line">  ask turtles [</span><br><span class="line">    let agsets other turtles-here ;; 其他所有turtles-here</span><br><span class="line">    let agentNum count agsets</span><br><span class="line">    <span class="keyword">if</span> agentNum &gt;= <span class="number">1</span> [</span><br><span class="line">      <span class="built_in">transaction</span> (one-of agsets)</span><br><span class="line">    ]</span><br><span class="line">    forward <span class="number">1</span></span><br><span class="line">  ]</span><br><span class="line"> tick</span><br><span class="line">end</span><br><span class="line">to transaction [trader]</span><br><span class="line">  let deltam <span class="number">0</span></span><br><span class="line">  let <span class="built_in">money1</span> ([money] of trader)</span><br><span class="line">  let <span class="built_in">epsilon</span> (random-<span class="type">float</span> <span class="number">1</span>) ;; 定义epsilon为一个<span class="number">0</span>~<span class="number">1</span>的随机数。前面用过random-<span class="type">float</span>，它会产生一个<span class="number">0</span>~<span class="number">1</span>的随机小数</span><br><span class="line">  -------------------</span><br><span class="line">    公式<span class="number">1</span></span><br><span class="line">    set deltam epsilon * money1 + (epsilon - <span class="number">1</span>) * money</span><br><span class="line">  <span class="keyword">if</span> money + deltam &gt;= <span class="number">0</span> <span class="keyword">and</span> money1 - deltam &gt;= <span class="number">0</span>[</span><br><span class="line">    set money money + deltam </span><br><span class="line">    ;;set [money] of trader money1 - deltam不能对其使用set</span><br><span class="line">    ask trader [</span><br><span class="line">      set money money1 - deltam </span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">    -------------------</span><br><span class="line">    公式<span class="number">2</span></span><br><span class="line">let all money + money1</span><br><span class="line">  set money epsilon * all</span><br><span class="line">  ask trader [</span><br><span class="line">    <span class="function">set <span class="title">money</span> <span class="params">(<span class="number">1</span> - epsilon)</span> * all</span></span><br><span class="line"><span class="function">  ]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">to to-update-plot</span></span><br><span class="line"><span class="function">    let lst [money] of turtles</span></span><br><span class="line"><span class="function">    set-histogram-num-bars 100</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> <span class="keyword">not</span> empty? lst [</span></span><br><span class="line"><span class="function">        set-plot-x-range 0 <span class="params">(max lst)</span></span></span><br><span class="line"><span class="function">        histogram lst</span></span><br><span class="line"><span class="function">    ]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 - 文件导出与复杂曲线绘制</title>
      <link href="/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter7%20-%20%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6/"/>
      <url>/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter7%20-%20%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>本章内容如下。学习导出数据文件，配合其他软件进行数据分析。NetLogo擅长仿真和模拟，并不擅长对数据做分析和统计，因此我们需要使用其他工具辅助分析。掌握洛伦兹曲线的概念。洛伦兹曲线能够非常方便地反映经济体系的财富分布不均衡现象。通过这样一条曲线，我们将很容易验证二八定律。绘制复杂曲线：洛伦兹曲线的若干编程技术。</p><h2 id="人工经济模型回顾及遗留问题"><a href="#人工经济模型回顾及遗留问题" class="headerlink" title="人工经济模型回顾及遗留问题"></a>人工经济模型回顾及遗留问题</h2><p>首先回顾第6章引入的模型。为了解释人类社会财富分布的不均衡现象，物理学家Victor M. Yakovenko提出了一个简单的人工经济模型，该模型符合如下基本规则：</p><ol><li>经济系统中人和财富的总量保持不变</li><li>开始的时候，每个人都有等量的货币</li><li>每当两个主体相遇，他们就随机分配财富</li></ol><p>第6章也遗留了一些问题。首先，<strong>模拟得到的财富分布曲线是否满足帕累托分布</strong>？即是否遵循幂律分布？其次，这样一条<strong>财富分布曲线是否服从二八定律</strong>？本章将会回答这两个问题。</p><h2 id="NetLogo导出文件"><a href="#NetLogo导出文件" class="headerlink" title="NetLogo导出文件"></a>NetLogo导出文件</h2><p>首先打开NetLogo，把财富分布数据导出到磁盘上的一个文件中。因为NetLogo分析数据的手段非常有限，所以我们需要借助其他工具来进行相应的统计分析。为了实现这个功能，需要创建一个新的按钮——<code>save-flie</code>，创建好后，添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">to save-file</span><br><span class="line">    file-open <span class="string">&quot;agents.txt&quot;</span></span><br><span class="line">    let wealths <span class="string">&quot;&quot;</span></span><br><span class="line">    ask turtles[</span><br><span class="line">        <span class="function">set <span class="title">wealths</span> <span class="params">(word wealths money <span class="string">&quot;\r\n&quot;</span>)</span></span></span><br><span class="line"><span class="function">    ]</span></span><br><span class="line"><span class="function">    file-print wealths</span></span><br><span class="line"><span class="function">    file-close</span></span><br><span class="line"><span class="function">end</span></span><br></pre></td></tr></table></figure><ul><li><code>file-open</code>是文件打开命令</li><li><code>file-print</code>是向文件中打印内容</li><li><code>file-close</code>是文件关闭命令</li><li><code>word</code>是将两个甚至多个字符串拼接在一起。<code>word value1 value2 value3 ...</code></li><li>相关其他命令需要查询和文件、字符串操作有关的命令</li><li>接下来就可以用MATLAB或其他你熟悉的工具，根据这些数据绘制简单的直方图了。</li></ul><h2 id="洛伦兹曲线"><a href="#洛伦兹曲线" class="headerlink" title="洛伦兹曲线"></a>洛伦兹曲线</h2><p>洛伦兹曲线（Lorenz curve）是经济学中一种反映财富分布不均衡现象的曲线，由美国经济学家M. O. 洛伦兹（Max Otto Lorenz）于1905年提出。<br />相较于前面讲到的概率分布函数曲线来说，洛伦兹曲线具有如下优点：</p><ol><li>绘制它并不需要我们对数据进行财富区间分组处理</li><li>它所反映的财富分布情况比概率分布曲线更客观、更准确</li><li>基于它，我们更容易计算基尼系数，这是一种可以客观反映财富分布不均衡性的常用指标</li></ol><p>接下来详细讲解如何绘制洛伦兹曲线。<br />首先用图形化的方式模拟一个国家的财富分布。假设这个国家一共有6个人，这些人的财富多少用身体大小来进行形象化的表示，如图所示。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677932749910-cb8bc07b-34d8-4ee4-a55a-b7e1db1ad80f.png" alt="image.png"></p><p>在现在这种状态下，他们的财富分布很不均衡。<br />接下来通过3个步骤得到洛伦兹曲线。<br />第1步，把这6个人<strong>按照财富值从小到大排序</strong>，财富最少的人排在最左边，财富最多的人排在最右边，如图7-8所示。这样可以得到一条单调上升的曲线，但它并不是洛伦兹曲线。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677932769905-dd106186-0627-4a78-9a3c-3863f7fac22f.png" alt="image.png"><br>第2步，<strong>对财富值进行累加</strong>。比如把前面3个人的财富之和跟第4个人的财富加在一起，形成一个高度，这个高度就是第4个人对应的洛伦兹曲线纵坐标的值。这样的话每个人在洛伦兹曲线上对应的纵坐标如图7-9所示，最后一个人即最富有的人，他所对应的纵坐标就是整个社会的财富总和。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677932785062-87c9667d-7bff-4989-8f77-c8d0ed5fb741.png" alt="image.png"></p><p>第3步，<strong>将这条曲线的横坐标和纵坐标归一化</strong>。在横坐标上除以最大值，由于这个国家一共有6个人，因此每个点的横坐标都除以6，所以第5个人的横坐标就是5&#x2F;6。同理，纵坐标也要除以社会的总财富。因此对于洛伦兹曲线来说，比如第i个点，它的<strong>横坐标就是从穷到富的前i&#x2F;N的人数，其中N为社会总人数，纵坐标对应的是这前i&#x2F;N的人所占有的财富与社会总财富的比例。</strong>图7-10所示的是最终的洛伦兹曲线。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677932859568-b578fa89-b476-4918-9dc8-7e43a32f3e59.png" alt="image.png"><br>图7-10的横坐标表示人口比例，纵坐标表示这些人所占财富的比例。洛伦兹曲线一定是这样一条弯曲的曲线，而且它一定会介于斜线A和竖线B与横坐标构成的三角形区域内部。<br />实际上，这两条特殊的线也有其经济含义，斜线A代表社会财富分布绝对均衡情况下的洛伦兹曲线。为什么可以这么说呢？我们可以想象，如果社会的财富分布极其均衡，即所有人的财富水平相等，那么当生成洛伦兹曲线的时候，一定是一条直线。<br />竖线B与横坐标构成的直角形折线，对应的就是社会财富分布极端不均衡的情况下的洛伦兹曲线。在这种情况下，一个人拥有全部社会总财富，而其他人的财富是0，所以这时只有最后一个人的纵坐标是1，而其他人都是0，因此刚好是这条折线。<br />由此可见，对于一般的随机的财富分布来说，洛伦兹曲线一定会介于这二者之间，而且越靠近折线，所反映的财富分布就越不均衡，越靠近斜线A财富分布就越均衡。<br />在这样一条洛伦兹曲线上很容易验证二八定律。那么如何验证呢？<br />我们可以作两条辅助线，<strong>首先找到横坐标为0.8的位置，这表示它对应的是社会按照从穷到富排序前80%的人口，找到它与洛伦兹曲线的交点，查看交点的纵坐标，这个纵坐标表示这80%的穷人所占据的财富比例。</strong></p><h2 id="用NetLogo实现洛伦兹曲线"><a href="#用NetLogo实现洛伦兹曲线" class="headerlink" title="用NetLogo实现洛伦兹曲线"></a>用NetLogo实现洛伦兹曲线</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677929264843-038a2449-3b7b-41b0-ac4b-504fc0fb5360.png" alt="image.png"></p><p>首先把名称设置成Lorenz curve，然后设定它的横纵坐标分别为population %和wealth %，接下来设定3个不同颜色的画笔，它们的名称分别设定为lorenz、equal和dominant，3个画笔分别对应洛伦兹曲线、对角线和表示财富分布极端不均衡的折线。然后把绘图更新命令改成自定义函数update-lorenz-plot，并把绘图笔更新命令处默认的命令删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">to update-lorenz-plot</span><br><span class="line">  clear-plot</span><br><span class="line">  ;; 绘制表示财富分布绝对均衡的斜线</span><br><span class="line">  set-current-plot-pen <span class="string">&quot;equal&quot;</span></span><br><span class="line">  plot <span class="number">0</span></span><br><span class="line">  plot <span class="number">1</span></span><br><span class="line">  ;; 绘制表示财富分布极端不均衡的折线</span><br><span class="line">  set-current-plot-pen <span class="string">&quot;dominant&quot;</span></span><br><span class="line">  plot-pen-down ;; plot-pen-down：开始绘图。</span><br><span class="line">  plotxy <span class="number">0</span> <span class="number">0</span></span><br><span class="line">  plotxy <span class="number">1</span> <span class="number">0</span></span><br><span class="line">  plotxy <span class="number">1</span> <span class="number">1</span></span><br><span class="line">  plot-pen-up ;; plot-pen-up：停止绘图。</span><br><span class="line">  </span><br><span class="line">  set-current-plot-pen <span class="string">&quot;lorenz&quot;</span></span><br><span class="line">  set-plot-pen-interval <span class="number">1</span> / num_agents ;; 按照x的一定间隔进行划分</span><br><span class="line">  plot <span class="number">0</span> </span><br><span class="line">  let sorted-wealths sort [money] of turtles ;; 对数组进行排序</span><br><span class="line">  let total-wealth sum sorted-wealths ;; 对数组进行求和</span><br><span class="line">  let wealth-sum-so-far <span class="number">0</span></span><br><span class="line">  let index <span class="number">0</span></span><br><span class="line">  repeat num_agents[ ;; 在<span class="keyword">for</span>循环中循环num_agents次</span><br><span class="line">    set wealth-sum-so-<span class="built_in">far</span> (wealth-sum-so-far + item index sorted-wealths)</span><br><span class="line">    <span class="built_in">plot</span> (wealth-sum-so-far / total-wealth)</span><br><span class="line">    <span class="function">set <span class="title">index</span> <span class="params">(index + <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">  ]</span></span><br><span class="line"><span class="function">end</span></span><br></pre></td></tr></table></figure><h3 id="绘图语句"><a href="#绘图语句" class="headerlink" title="绘图语句"></a>绘图语句</h3><p>NetLogo的图形化元素具有一定的层次结构，我们通常接触的有两个层次。</p><ul><li><code>plot</code>代表绘图</li><li><code>set-current-plot &quot;plot-name&quot;</code>表示把后面的绘图框激活，其中的名称跟设置的标题是一致的</li><li><code>pen</code>代表画笔</li><li><code>set-current-pen &quot;pen-name&quot;</code>每个图可能有多条曲线，比如目前要画的图有3条曲线，对应3个画笔。要完成某一条曲线的绘制就要激活相应的画笔。</li><li><code>plot-pen-down</code>代表开始绘图</li><li><code>plot-pen-up</code>代表停止绘图</li></ul><p>绘图命令：</p><ul><li><code>plot</code>这是一个使用频率比较高的指令，它的作用是等水平间隔地绘制点。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677929556766-734d6787-801f-4816-8646-fdae718c2cde.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear-plot</span><br><span class="line">    set-current-plot-pen <span class="string">&quot;equal&quot;</span></span><br><span class="line">    plot <span class="number">0</span></span><br><span class="line">    plot <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里使用了plot语句来画图，第一步先清空当前绘图Lorenz curve。在每一个绘图周期都要重新清空，然后用<code>set-current-plot-pen &quot;equal&quot;</code>语句激活“equal”画笔。我们在图形界面设置的equal画笔对应的是红色，因此这时绘制的线就是红色的。接下来的plot语句从坐标(0, 0)到(1, 1)绘制了一条红色对角线</p><ul><li><code>plotxy</code></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677929643621-f580e16d-29ad-4320-ac4f-1dafff56b096.png" alt="image.png"></p><h3 id="绘制洛伦兹曲线"><a href="#绘制洛伦兹曲线" class="headerlink" title="绘制洛伦兹曲线"></a>绘制洛伦兹曲线</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set-current-plot-pen <span class="string">&quot;lorenz&quot;</span></span><br><span class="line">set-plot-pen-interval <span class="number">1</span> / num_agents ;; 按照x的一定间隔进行划分</span><br><span class="line">plot <span class="number">0</span> </span><br><span class="line">let sorted-wealths sort [money] of turtles ;; 对数组进行排序</span><br><span class="line">let total-wealth sum sorted-wealths ;; 对数组进行求和</span><br><span class="line">let wealth-sum-so-far <span class="number">0</span></span><br><span class="line">let index <span class="number">0</span></span><br><span class="line">repeat num_agents[ ;; 在<span class="keyword">for</span>循环中循环num_agents次</span><br><span class="line">  set wealth-sum-so-<span class="built_in">far</span> (wealth-sum-so-far + item index sorted-wealths)</span><br><span class="line">  <span class="built_in">plot</span> (wealth-sum-so-far / total-wealth)</span><br><span class="line">  <span class="function">set <span class="title">index</span> <span class="params">(index + <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">]</span></span><br></pre></td></tr></table></figure><ol><li>确定间隔</li></ol><p>要绘制这条曲线，我们要先设定横坐标平移的间隔量。由于<strong>这条洛伦兹曲线针对货币转移模型里的所有主体</strong>，人数在模型中是变量<code>num_agents</code>，因此把洛沦兹曲线的横坐标划分成<code>num_agents</code>份，那么每一份的宽度就是<code>1 / num_agents</code>，于是用<code>set-plot-pen-interval 1 / num_agents</code>来设置间隔量。</p><ol start="2"><li>排序</li></ol><p>sort命令，该命令的作用是<strong>对一个列表中的元素按从小到大进行排序</strong>。那么<code>let sorted-wealths sort [money] of turtles</code>语句的列表就是<code>[money] of turtles</code>，其作用是把所有主体的财富值构成一个大的数值列表。但是数值排序是乱的，而用sort命令就可以对数值列表按从小到大进行排序。因此<code>sorted-wealths</code>这个变量就是排序好的财富值列表。</p><ol start="3"><li>循环与求和</li></ol><ul><li><code>repeat num_agents[ ]</code>是一个循环过程，其中repeat是一个多次的循环，相当于Python语言中的for循环，紧随其后的是循环次数<code>num_agents</code>。</li><li>在每一次循环中，首先<code>set wealth-sum-so-far (wealth-sum-so-far + item index sorted-wealths)</code>语句给<code>wealth-sum-so-far</code><strong>赋值</strong>，<code>wealth-sum-so-far</code>的含义相当于循环到第i个主体时积累的社会财富总量。这个量实际上是把<strong>前一次积累的财富总量加上当前主体所对应的财富量。</strong></li><li><code>item idx lst</code>表示从list的列表中取出下标编号为idx的元素，比如当前列表是[0123]，那么item 1 lst得到的数就应该是1。此处注意，在NetLogo语法里，<strong>它的列表下标始于0。</strong><code>item index sorted-wealths</code>，就是<strong>从排序好的财富列表里取出第index这个下标的元素</strong>。然后把取出的财富值加到<code>wealth-sum-so-far</code>这个变量里，就得到了前i个主体的财富总量。</li></ul><ol start="4"><li>归一化</li></ol><ul><li>纵坐标是归一化的财富总量。有了当前第i个主体的归一化的财富总量，直接用<code>wealth-sum-so-far /total-wealth</code>就可以得到相应的纵坐标。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677930099233-d5c52fc8-8620-47db-b262-0374fc69b81c.png" alt="image.png"><br>由图可知：这样的简单人工经济模型不满足二八定律</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>学会对文件和字符串进行操作的若干命令</li><li>学会<code>for</code>循环和对应下标值</li><li>了解洛伦兹曲线</li><li>了解<code>plot</code>绘图的相关命令<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">turtles-own [money]</span><br><span class="line">to setup</span><br><span class="line">  clear-all</span><br><span class="line">  reset-ticks</span><br><span class="line">  create-turtles num_agents[</span><br><span class="line">    <span class="function">set <span class="title">money</span> <span class="params">(total_money / num_agents)</span> </span>;; 初始情况下每个turtle都拥有相同的货币量</span><br><span class="line">    setxy random-xcor random-ycor  ;; 设置为随机取值，实现随机分布</span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line">to go</span><br><span class="line">  ask turtles [</span><br><span class="line">    let agsets other turtles-here ;; 其他所有turtles-here</span><br><span class="line">    let agentNum count agsets</span><br><span class="line">    <span class="keyword">if</span> agentNum &gt;= <span class="number">1</span> [</span><br><span class="line">      <span class="built_in">transaction</span> (one-of agsets)</span><br><span class="line">    ]</span><br><span class="line">    forward <span class="number">1</span></span><br><span class="line">  ]</span><br><span class="line"> tick</span><br><span class="line">end</span><br><span class="line">to transaction [trader]</span><br><span class="line">  let deltam <span class="number">0</span></span><br><span class="line">  let <span class="built_in">money1</span> ([money] of trader)</span><br><span class="line">  let <span class="built_in">epsilon</span> (random-<span class="type">float</span> <span class="number">1</span>) ;; 定义epsilon为一个<span class="number">0</span>~<span class="number">1</span>的随机数。前面用过random-<span class="type">float</span>，它会产生一个<span class="number">0</span>~<span class="number">1</span>的随机小数</span><br><span class="line">  let all money + money1</span><br><span class="line">  set money epsilon * all</span><br><span class="line">  ask trader [</span><br><span class="line">    <span class="function">set <span class="title">money</span> <span class="params">(<span class="number">1</span> - epsilon)</span> * all</span></span><br><span class="line"><span class="function">  ]</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">to to-update-plot</span></span><br><span class="line"><span class="function">    let lst [money] of turtles</span></span><br><span class="line"><span class="function">    set-histogram-num-bars 100</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> <span class="keyword">not</span> empty? lst [</span></span><br><span class="line"><span class="function">        set-plot-x-range 0 <span class="params">(max lst)</span></span></span><br><span class="line"><span class="function">        histogram lst</span></span><br><span class="line"><span class="function">    ]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">to save-file</span></span><br><span class="line"><span class="function">  file-open &quot;agent.txt&quot;</span></span><br><span class="line"><span class="function">  let wealths &quot;&quot;</span></span><br><span class="line"><span class="function">  ask turtles[</span></span><br><span class="line"><span class="function">    set <span class="title">wealths</span> <span class="params">(word wealths money <span class="string">&quot;\r\n&quot;</span>)</span></span></span><br><span class="line"><span class="function">  ]</span></span><br><span class="line"><span class="function">  file-print wealths</span></span><br><span class="line"><span class="function">  file-close</span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">to update-lorenz-plot</span></span><br><span class="line"><span class="function">  clear-plot</span></span><br><span class="line"><span class="function">  </span>;; 绘制表示财富分布绝对均衡的斜线</span><br><span class="line">  set-current-plot-pen <span class="string">&quot;equal&quot;</span></span><br><span class="line">  plot <span class="number">0</span></span><br><span class="line">  plot <span class="number">1</span></span><br><span class="line">  ;; 绘制表示财富分布极端不均衡的折线</span><br><span class="line">  set-current-plot-pen <span class="string">&quot;dominant&quot;</span></span><br><span class="line">  plot-pen-down ;; plot-pen-down：开始绘图。</span><br><span class="line">  plotxy <span class="number">0</span> <span class="number">0</span></span><br><span class="line">  plotxy <span class="number">1</span> <span class="number">0</span></span><br><span class="line">  plotxy <span class="number">1</span> <span class="number">1</span></span><br><span class="line">  plot-pen-up ;; plot-pen-up：停止绘图。</span><br><span class="line">  </span><br><span class="line">  set-current-plot-pen <span class="string">&quot;lorenz&quot;</span></span><br><span class="line">  set-plot-pen-interval <span class="number">1</span> / num_agents ;; 按照x的一定间隔进行划分</span><br><span class="line">  plot <span class="number">0</span> </span><br><span class="line">  let sorted-wealths sort [money] of turtles ;; 对数组进行排序</span><br><span class="line">  let total-wealth sum sorted-wealths ;; 对数组进行求和</span><br><span class="line">  let wealth-sum-so-far <span class="number">0</span></span><br><span class="line">  let index <span class="number">0</span></span><br><span class="line">  repeat num_agents[ ;; 在<span class="keyword">for</span>循环中循环num_agents次</span><br><span class="line">    set wealth-sum-so-<span class="built_in">far</span> (wealth-sum-so-far + item index sorted-wealths)</span><br><span class="line">    <span class="built_in">plot</span> (wealth-sum-so-far / total-wealth)</span><br><span class="line">    <span class="function">set <span class="title">index</span> <span class="params">(index + <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">  ]</span></span><br><span class="line"><span class="function">end</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>介绍</title>
      <link href="/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>lbs基于位置的社交产品，主打大学生情感焦虑和七日活动中交友的相关业务。</p><ul><li>C端：wecrushlite<ul><li>私信：主打用户之间较强的联系—已经心动的基础上才能聊天</li><li>闹闹广场：线下活动举办、记录笔记再次引流</li><li>crush广场：抽卡交友匹配，划卡认识用户-实现关系搭建</li><li>主打概念：五个闭环<ul><li>活动参与、活动组织、跨校、商业化、链路关系</li><li>推动跨校的活动、更大范围的传播</li></ul></li></ul></li><li>中后端 B端：嫦娥。商家、运营等定制化地配置</li><li>短平快地验证需求是否正确，验证功能地开发</li><li>主打App，web产品是用来用户迁移和功能验证。</li></ul><h1 id="嫦娥-中后台系统"><a href="#嫦娥-中后台系统" class="headerlink" title="嫦娥 中后台系统"></a>嫦娥 中后台系统</h1><ol><li>负责审核和业务配置</li><li>C端的审核–</li><li>数据监控、用户满意度、业务配置</li><li>C端的激励任务</li></ol><p>闭环：</p><ul><li>用户关系链路：注册、报名、划卡、感兴趣认识–C端私信交流</li><li>活动参与：选择想要参加的活动，打卡发布笔记，再次参与下一个活动</li><li>活动组织：发现潜在的活动组织者，分享活动体验，吸引更多的组织者</li><li>跨校业务：校际大循环</li><li>200 工作规范</li><li>产研流程等</li></ul><p>周会：每周五的晚上七点半<br />每周一次交流</p>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8 - 使用行为空间做实验</title>
      <link href="/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter8%20-%20%E4%BD%BF%E7%94%A8%E8%A1%8C%E4%B8%BA%E7%A9%BA%E9%97%B4%E5%81%9A%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter8%20-%20%E4%BD%BF%E7%94%A8%E8%A1%8C%E4%B8%BA%E7%A9%BA%E9%97%B4%E5%81%9A%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="更新人工经济模型的基本规则"><a href="#更新人工经济模型的基本规则" class="headerlink" title="更新人工经济模型的基本规则"></a>更新人工经济模型的基本规则</h2><p>首先回顾一下人工经济模型的基本交易规则：</p><ol><li>经济系统中人和财富的总量保持不变；</li><li>开始的时候，每个人都有等量的货币；</li><li>每当两个主体相遇，他们就随机分配财富。</li></ol><p>这样的经济系统非常野蛮、非常不合理，现实世界中并不是这样做交易的，通常你不会把自己的钱花光，而是会留存一定比例，然后把剩下的钱用于交易，因此我们可以考虑引入一个非常重要的变量——<strong>储蓄率，每个主体都有自己的储蓄率，它是一个(0, 1)之间的小数。每个人在交易的时候，会保留储蓄率乘以自己财富总量的财富，剩余财富用于交易，并且交易仍然是随机的。</strong>更新后的人工经济模型的交易规则变为：</p><ol><li>经济系统中人和财富的总量保持不变；</li><li>开始的时候，每个人都有等量的货币；</li><li>每个主体有自己的储蓄率；</li><li>每当两个主体相遇，他们会将除储蓄部分外的财富用于随机分配。</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677932971005-c52d1880-8e6b-4c0d-80d9-0d21aec23ff1.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677932981621-21601db3-12f2-4f36-9db2-f98546de3af1.png" alt="image.png"></p><h2 id="程序修改"><a href="#程序修改" class="headerlink" title="程序修改"></a>程序修改</h2><p>接下来看看如何用程序实现新的经济模型规则。首先引入储蓄率，增加一个turtles-own的变量——save_rate，因为每一个主体的储蓄率都不一样，所以要把它放在turtles-own的变量中。在有多个变量的情况下，用回车隔开不同变量，并且都放在方括号内。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">turtles-own [</span><br><span class="line">    money</span><br><span class="line">    save_rate</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接下来初始化的时候，要初始化save_rate的具体数值，我们在创建一个主体的时候，用random-float设定它的储蓄率是一个0~1之间的随机数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">to setup</span><br><span class="line">    clear-all</span><br><span class="line">    reset-ticks</span><br><span class="line">    create-turtles num_agents [</span><br><span class="line">        <span class="function">set <span class="title">money</span> <span class="params">(total_money / num_agents)</span></span></span><br><span class="line"><span class="function">        setxy random-xcor random-ycor</span></span><br><span class="line"><span class="function">        set save_rate random-<span class="type">float</span> 1</span></span><br><span class="line"><span class="function">    ]</span></span><br><span class="line"><span class="function">end</span></span><br></pre></td></tr></table></figure><p>而且这个数值一旦定下来将不再变化，道理很简单，因为每个人的储蓄率基本上是固定的。储蓄率越高，表示这个交易者比较保守，因为他只拿一小部分钱用于交易；反过来，储蓄率越低，表示交易者更偏向于冒险，他会用更多的钱来进行交易。<br />接下来，添加一个全新的“new_go”按钮，方便比较两套交易规则，to go代码完全保留，而把全新的交易规则放在to new_go代码块中，这两个按钮都带持续循环标志</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">to new_go</span><br><span class="line">    ask turtles[</span><br><span class="line">        let agsets other turtles</span><br><span class="line">        <span class="keyword">if</span> count agsets &gt;= <span class="number">1</span></span><br><span class="line">        [</span><br><span class="line">            <span class="built_in">transaction_new</span> (one-of agsets)</span><br><span class="line">        ]</span><br><span class="line">        forward <span class="number">1</span></span><br><span class="line">    ]</span><br><span class="line">    tick</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">to transaction_new [trader]</span><br><span class="line">    let deltam <span class="number">0</span></span><br><span class="line">    let <span class="built_in">money0</span> ((<span class="number">1</span> - save_rate) * money)</span><br><span class="line">    let <span class="built_in">money1</span> ((<span class="number">1</span> - ([save_rate] of trader)) * ([money] of trader))</span><br><span class="line">    let <span class="built_in">epsilon</span> (random-<span class="type">float</span> <span class="number">1</span>)</span><br><span class="line">    set <span class="built_in">deltam</span> (epsilon - <span class="number">1</span>) * money0 + epsilon * money1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> money + deltam &gt;= <span class="number">0</span> <span class="built_in">and</span> ([money] of trader) - deltam &gt;= <span class="number">0</span></span><br><span class="line">    [</span><br><span class="line">        set money money + deltam</span><br><span class="line">        ask trader[</span><br><span class="line">            set money money - deltam</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="两种规则下的财富分布对比"><a href="#两种规则下的财富分布对比" class="headerlink" title="两种规则下的财富分布对比"></a>两种规则下的财富分布对比</h2><p>执行go命令<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933135855-cc07c03c-17b5-4419-a194-a845a4b71756.png" alt="image.png"><br>执行new_go命令<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933144755-90605921-1ddc-45ea-ae45-84171f796328.png" alt="image.png"></p><h2 id="基尼系数的定义及程序实现"><a href="#基尼系数的定义及程序实现" class="headerlink" title="基尼系数的定义及程序实现"></a>基尼系数的定义及程序实现</h2><p>目前来看，这套全新的规则比较成功，能够复现我们感兴趣的现象。为了更加合理地刻画社会财富分布的不均衡性，也为了进一步比较不同的模型、不同的参数如何影响交易的不均衡性，我们引入一个全新的指标——基尼系数。</p><h3 id="什么是基尼系数"><a href="#什么是基尼系数" class="headerlink" title="什么是基尼系数"></a>什么是基尼系数</h3><p>基尼系数是国际通用的<strong>衡量一个经济体社会财富分布不均衡性的指标</strong>。基尼系数不仅能够用于衡量社会财富分布，也可以衡量更多其他量分布的不均衡性，比如衡量社交媒体上不同人粉丝数分布的不均衡性。</p><h3 id="基尼系数的计算方法"><a href="#基尼系数的计算方法" class="headerlink" title="基尼系数的计算方法"></a>基尼系数的计算方法</h3><p>第7章讲到洛伦兹曲线如果越弯曲越靠近折线，那么社会财富分布就越不均衡，因此我们不妨用洛伦兹曲线和对角线所围成的曲边三角形的面积来衡量社会财富分布的不均衡性，如图8-6所示。这个面积如果计算出来是S的话，那么最终<code>G = 2S</code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933240194-43a2e669-af36-4696-86aa-e0d0515fdd84.png" alt="image.png"></p><h3 id="基尼系数的程序实现"><a href="#基尼系数的程序实现" class="headerlink" title="基尼系数的程序实现"></a>基尼系数的程序实现</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933306504-adebf3fe-0b42-4c42-8438-55d0429b8772.png" alt="image.png"><br>设置名称为gini，横坐标是time，我们可以看到每一时刻基尼系数的大小，纵坐标就是基尼系数本身。这里面不修改绘图笔指令，具体绘制基尼系数的命令将在代码里完成。如何在计算机中计算这样一个洛伦兹曲线和对角线所围成的曲边三角形的面积？我们可以用数值积分的方法。具体思想是，对这个曲边三角形进行矩形刨分，把整个[0, 1]区间分成若干份，实际上有多少人口就划分成多少份。然后计算每一个小矩形的面积，再把所有小矩形的面积累加起来，就可以近似得到曲边三角形的面积，如图8-8所示。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933329779-b2647112-09f0-4ac1-a3d0-e8bcf61a8705.png" alt="image.png"><br>具体来讲，比如第i个小矩形的面积如何计算呢？首先可以计算每一个小矩形的宽度，我们把[0, 1]这个区间划分成num_agents份，因此每一份的宽度是<code>1 / num_agents</code>。小矩形的高度是：<br /><code>i / num_agents - wealth-sum-so-far / total_wealth</code><br />这里<code>i / num_agents</code>是对角线在该点的纵坐标，<code>wealth-sum-so-far / total_wealth</code>是洛伦兹曲线在该点的纵坐标。于是可以用“宽×高”计算出这个小矩形的面积。如此计算出所有矩形的面积，再把它们累加起来就得到了曲边三角形的面积。接下来看看如何编写代码。为了计算基尼系数，我们只要改动绘制洛伦兹曲线的这部分代码即可，前面都一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">to update-lorenz-plot</span><br><span class="line">    ;绘制财富分布绝对均衡的曲线</span><br><span class="line">    clear-plot</span><br><span class="line">    set-current-plot-pen <span class="string">&quot;equal&quot;</span></span><br><span class="line">    plot <span class="number">0</span></span><br><span class="line">    plot <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    ;绘制财富分布极端不均衡的曲线</span><br><span class="line">    set-current-plot-pen <span class="string">&quot;dominant&quot;</span></span><br><span class="line"></span><br><span class="line">    plot-pen-down</span><br><span class="line">    plotxy <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    plotxy <span class="number">1</span> <span class="number">0</span></span><br><span class="line">    plotxy <span class="number">1</span> <span class="number">1</span></span><br><span class="line">    plot-pen-up</span><br><span class="line"></span><br><span class="line">    ;绘制洛伦兹曲线</span><br><span class="line">    set-current-plot-pen <span class="string">&quot;lorenz&quot;</span></span><br><span class="line">    set-plot-pen-interval <span class="number">1</span> / num_agents</span><br><span class="line">    plot <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    let sorted-wealths sort [money] of turtles</span><br><span class="line">    let total-wealth sum sorted-wealths</span><br><span class="line">    let wealth-sum-so-far <span class="number">0</span></span><br><span class="line">    let index <span class="number">0</span></span><br><span class="line">    let gini <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    repeat num_agents [</span><br><span class="line">        set wealth-sum-so-<span class="built_in">far</span> (wealth-sum-so-far + item index sorted-wealths)</span><br><span class="line">        <span class="built_in">plot</span> (wealth-sum-so-far / total-wealth)</span><br><span class="line">        <span class="function">set <span class="title">index</span> <span class="params">(index + <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">        set gini gini + <span class="params">((index / num_agents) - (wealth-sum-so-far / total-wealth))</span> / num_agents</span></span><br><span class="line"><span class="function">    ]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    set-current-plot &quot;gini&quot; </span>;;指定绘画gini图</span><br><span class="line">    plot gini * <span class="number">2</span> ;; 一个时间点得到一个基尼系数</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933512143-20f480c0-9884-4522-b533-3228579923b8.png" alt="image.png"><br><strong>基尼系数表明，新规则造成的社会财富分布不均衡要比旧规则更严重。</strong> </p><h2 id="使用行为空间做重复实验"><a href="#使用行为空间做重复实验" class="headerlink" title="使用行为空间做重复实验"></a>使用行为空间做重复实验</h2><p>接下来系统地探索参数是如何影响基尼系数的。这里介绍一个全新的工具——行为空间（BehaviorSpace），它可以让你通过简单的参数设置，自动实现同时进行大量重复的计算机模拟实验，并将实验结果自动记录到一个数据库文件中，方便我们探索不同的模型参数组合。在NetLogo的菜单栏中找到“工具”菜单，然后选择“行为空间”项。我们将会看到图8-14所示的界面，单击“新建”，就可以开始一系列实验。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933598485-d112493a-2d9b-4eb2-8a01-b56ee9fc6501.png" alt="image.png"><br>在行为空间设置界面，首先将这个实验命名为gini-experiment，如图8-15所示。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933613311-d0d47eb4-53fb-4382-b64e-9249c682aedc.png" alt="image.png"><br>接下来指定参数变化的范围。我们希望探索的是，当num_agents等于100、200、300、……一直到1000，total_money等于10 000、20 000、30 000、……一直到100000，不同参数组合下的基尼系数。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933642150-0ea6bebe-4525-4f24-b7bb-895779c4f3cc.png" alt="image.png"><br><strong>每一个组合下都要进行重复实验。因为实验是随机性的</strong>，所以每一次计算出来的基尼系数都会有一定的波动<strong>。为了消除这种噪声影响，需要进行重复实验。</strong>这里设置每一个参数组合下重复10次，因此一共要做1000次实验。<br />接下来我们用这些报告测算运行结果，<strong>即每一种参数组合下的实验会有什么样的输出结果，这里不可能用动画或者图形作为输出，通常要计算并输出一些数值</strong>，对于本例就是基尼系数。<br />因此在“用这些报告器测算运行结果：”下输入一个自定义的函数——compute-gini。也就是<strong>当有一组参数值设定时，它就动态激活compute-gini代码去做模拟实验。</strong><br />最后需要设定它的终止条件，这里只要设定最大模拟周期为1000即可。这样就定义好了一个行为空间，接下来给出compute-gini代码的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">to-report compute-gini</span><br><span class="line">    let sorted-wealths sort [money] of turtles</span><br><span class="line">    let total-wealth sum sorted-wealths</span><br><span class="line">    let wealth-sum-so-far <span class="number">0</span></span><br><span class="line">    let index <span class="number">0</span></span><br><span class="line">    let gini <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    repeat num_agents [</span><br><span class="line">        set wealth-sum-so-<span class="built_in">far</span> (wealth-sum-so-far + item index sorted-wealths)</span><br><span class="line">        <span class="built_in">plot</span> (wealth-sum-so-far / total-wealth)</span><br><span class="line">        <span class="function">set <span class="title">index</span> <span class="params">(index + <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">        set gini gini + <span class="params">((index / num_agents) - (wealth-sum-so-far / total-wealth))</span> / num_agents</span></span><br><span class="line"><span class="function">    ]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    set-current-plot &quot;gini&quot;</span></span><br><span class="line"><span class="function">    report gini * 2</span></span><br><span class="line"><span class="function">end</span></span><br></pre></td></tr></table></figure><p>实际上，它就是把前面计算基尼系数的代码复制过来了，不同之处在于它不是to和end，而是to-report和end，<strong>report的意思是最终要有返回结果，即最终基尼系数要作为这个函数的结果输出。</strong><br />写完代码以后，这个实验就可以运行了。单击运行，设置一下运行选项，如图8-16所示。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933821249-fd5741bf-fcd3-4737-ae58-3ef9f591906a.png" alt="image.png"><br>如果出现报错：<code>没有选中的绘图。请使用set-current-plot指令选择绘图.</code> 则要在更新洛伦兹的函数里指明<code>set-current-plot &quot;Lorenz curve&quot;</code><br />模拟结果：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933840868-4fb527c3-c385-49f5-84de-3bdeaef67dd1.png" alt="image.png"><br>这个表单包括实验的名称、时间以及关键参数、多次模拟实验结果，并且记录了每一次模拟实验的参数取值、total_money取值、num_agents取值、最后的模拟步数以及基尼系数的运行结果。[final]这一行就是基尼系数的运行结果，因为这组结果是重复3次实验得到的，所以我们只需要把这3次的基尼系数求平均就可以得到参数组合下的基尼系数。<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677933954436-7167fa15-0d26-45b3-8750-2883c530f2cb.png" alt="image.png"><br>最后可以绘制一个曲面，x坐标和y坐标分别对应<code>total_money</code>和<code>num_agents</code>，而[坐标对应基尼系数。这样我们就对模型的性质有了更深刻的了解。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章首先更新了交易规则，然后讲解了如何计算基尼系数，以及如何用NetLogo实现简单的数值积分以计算基尼系数，最后介绍了行为空间，以及如何用行为空间做重复性实验。</p>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter9 - 透过人工鸟群模型Boids学习list的使用</title>
      <link href="/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter9%20-%20%E9%80%8F%E8%BF%87%E4%BA%BA%E5%B7%A5%E9%B8%9F%E7%BE%A4%E6%A8%A1%E5%9E%8BBoids%E5%AD%A6%E4%B9%A0list%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/10/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chapter9%20-%20%E9%80%8F%E8%BF%87%E4%BA%BA%E5%B7%A5%E9%B8%9F%E7%BE%A4%E6%A8%A1%E5%9E%8BBoids%E5%AD%A6%E4%B9%A0list%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本章我们将接触一个全新的模型——鸟群模型（Boids）。现实世界中鸟群的飞行非常优美，它们可以组成复杂的队形，还可以聪明地绕开障碍物并再次合成一队。看到这样复杂的行为，我们不禁会问，为什么它们能形成复杂的飞行动态？是因为某只领头鸟在发号施令，还是这些复杂的行为都写到了鸟的基因里面？<br />对这个问题进行思考的人不止我们。早在1983年，计算机图形学家Craig W.Reynolds就开始观察鸟群的飞行了，他立志在计算机上实现模拟的鸟群飞行。经过大量实验他发现，通过为每只模拟的人工鸟Boids制定3条简单的规则，就能够模拟逼真的鸟群行为。图9-1展示的就是他早年设计的用于模拟鸟群行为的3D模型。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677935896951-2c898c21-7bab-48f0-9780-80a6f1922e39.png" alt="image.png"><br>人工鸟群模型不仅可用于研究自然界中鸟群的行为，它在人类社会中也有用武之地。比如，人群行动的轨迹就与鸟群有着某些相似之处：人们总是倾向于跟随人群，而不是独自行动，尤其是在目的地相同时，人们的行动轨迹总是会与前面的人保持一致；同时，人们总是会下意识地与他人保持一定的社交距离等。这些现象存在于很多实际应用场景中，如规划城市交通布局、疫情下的社交距离控制，以及室内设施布局等。理解并掌握人工鸟群模型，对于将该模型扩展到其他有关主体行动轨迹的问题很有帮助。<br />本章将介绍人工鸟群模型，内容如下：</p><ul><li>如何进行矢量运算，并且用矢量的方法来模拟鸟群的飞行；</li><li>如何使用NetLogo中的list完成矢量运算，list是NetLogo中一个非常关键的数据结构；</li><li>如何运用欧拉法（Euler Method）来求解鸟群的飞行轨迹。</li></ul><h2 id="人工鸟群模型Boids"><a href="#人工鸟群模型Boids" class="headerlink" title="人工鸟群模型Boids"></a>人工鸟群模型Boids</h2><p>首先我们看看Boids模型。Boids模型假设每只鸟都有一个视野半径，就是图9-2中的灰色区域，只有这些半径范围内的邻居才会对当前这只鸟造成一定的影响。具体的规则有3条。</p><ul><li>靠近规则：尽可能靠近邻居的中心位置点，如图9-2所示。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677936028040-90f9fd62-e2ab-4100-9cbe-3ebabc72d352.png" alt="image.png"></p><ul><li>对齐规则：飞行方向与大家的飞行方向尽量一致，如图9-3所示。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677936045119-9d8f2952-8b3a-45d7-b227-162e1c766377.png" alt="image.png"></p><ul><li>分离规则：如果和别的鸟靠得太近，为了避免碰撞，彼此之间会产生斥力从而分离，如图9-4所示。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677936059021-479b3ebe-d491-412f-ae52-9560390bede3.png" alt="image.png"><br>接下来我们试着在NetLogo中实现这3条规则。然而要实现它并不简单，我们需要通过<strong>受力分析、力的合成以及矢量运算</strong>来完成鸟群模型。这里的基本思想是将鸟群飞行的模型转化成一个多质点的相互作用的力学模型，然后<strong>通过力的分析和合成</strong>来完成鸟群模拟，实现鸟群飞行的3条规则，再<strong>利用牛顿第二定律</strong>，将力学问题转化成运动学问题，最后<strong>用欧拉法实现数值积分运算</strong>，从而模拟鸟群飞行轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一课 发展历程</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%80%E8%AF%BE%20%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%80%E8%AF%BE%20%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>语言的多义性决定了语言的丰富。但是对于计算机而言，描述必须精准</p><ul><li>Syntax 语法</li><li>Semantics 语义</li><li>Pragmatics 语用</li></ul><p>BNF语法图<br />句型： Thank sb for sth. 其中sb和sth都可以由其他东西替代（可替代部分+不可替代部分）<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662444962624-1e45f756-8b6f-47cc-a90d-05b286820024.png" alt="image.png"><br>在BNF中，不可替代部分成为alphabet，又称作字。即：ASCII 定义了所有可以出现在程序中的字母表<br />如何判断标识符符合规定：</p><ol><li>deduct：“_a9”是一个identifier吗？</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662444573424-b85dd72b-ebf3-4b38-9328-eee446d3506c.png" alt="image.png"><br>根据定义，利用递归，从上往下推导</p><ol start="2"><li>reduce：按照递归树从下往上推导</li></ol><p><strong>语言是建立在一定的字母表上，按照一定的规则，所构成的符号串的集合。（集合是无穷无尽的，因为包含了递归）</strong><br /><strong>编译器：完成识别的过程，判断语言是不是符合对应的规则。把程序员所写的语言程序等价翻译为机器语言</strong></p><h3 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h3><p>语言的约束越强，对应的集合越小</p><ul><li>RG：Regular Grammer 正则语法  — FA：finite automata 有限状态自动机</li><li>CFG： Context Free Grammer  —PDA：push down automata</li><li>CSG：context sensitive Grammer —LBA： linear bounded automata 线性界限自动机</li><li>PSG —TM：</li></ul><p>程序语言：词法符合RG，语法大多数符合CFG  </p><h2 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h2><ol><li>programming 是一种 science</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662446400921-75e7ccb6-38c2-4e6c-a31a-46a47042ada6.png" alt="image.png"><br>用数学对前后置条件进行限制<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662446421868-55139af5-356e-4a8f-bfe8-d9a0fe23a1d9.png" alt="image.png"><br>经验：调试bug时要考虑数据流，而不是只是考虑输入流。看数值的变化是否满足对应的前后置的限制条件</p><ol start="2"><li>programming 是一种 art “The Art of Computer Programming”</li></ol><p>类比：以法国人的思维说法语</p><h2 id="Progarmming-Paradigm"><a href="#Progarmming-Paradigm" class="headerlink" title="Progarmming Paradigm"></a>Progarmming Paradigm</h2><h3 id="命令式程序设计-imperative-programming"><a href="#命令式程序设计-imperative-programming" class="headerlink" title="命令式程序设计 imperative programming"></a>命令式程序设计 imperative programming</h3><p>清楚的知道内存中数据的表示，每一条指令都是清晰的</p><ul><li>Procedural</li><li>Object-Oriented</li></ul><h3 id="declarative-programming"><a href="#declarative-programming" class="headerlink" title="declarative programming"></a>declarative programming</h3><ul><li>Functional: side effect函数副作用，函数发挥作用时受上下文环境影响。在此处的function不能有side effect。f() g()可以并行地发挥作用，前后顺序不影响结果</li></ul><p>例如：在排版系统中，加粗和调整字体都是functional programming</p><ul><li>Logical programming paradigm：根据已知的规则和事实进行判断 prolog</li></ul><h2 id="Development-History"><a href="#Development-History" class="headerlink" title="Development History"></a>Development History</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662450058611-31be0828-3f84-4b7b-ba44-bb6e55b54d28.png" alt="image.png"><br>simula 67 开销太大</p><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><ol><li>第一个程序设计语言 Fortran：解决了从汇编语言到高级程序设计语言的飞跃，主要问题是移植性差，从冯诺依曼结构产生出来，和机器硬件绑定太强</li><li>Algol 60：把程序设计语言作为一个学科，提出了结构化程序设计语言的发展&#x3D;&gt;Algol  68</li><li>CPL(combined programming language ) 和机器贴合紧密，过于注重细节&#x3D;&gt;B（bracket 闭合的语句块）CPL。把IO输入输出以库的形式提出，提出了闭合的相关概念&#x3D;&gt;B（进一步精简）&#x3D;&gt;C（写unix操作系统）</li><li>Simula 67</li></ol><p>C++：</p><ul><li>结构化程序设计基因：Algol 60</li><li>系统程序设计基因：CPL</li><li>object-oriented programming OO思想：Simula 67</li></ul><h3 id="OO的诞生-Simula-67"><a href="#OO的诞生-Simula-67" class="headerlink" title="OO的诞生-Simula 67"></a>OO的诞生-Simula 67</h3><ul><li>Simulation System:需要求的数值，但是没有现实的模型。需要映射出一个模型，通过实验的手段，在人为营造的环境中让系统不断演变</li><li>背景： Nygaard 做核反应堆铀棒直径的计算，需要做一个simulation system</li></ul><p>用新的表述方法（simulation language）去描述仿真系统中的活动，而不是人为的去用代码描述</p><ul><li>选择：Fortran or ALGOL 60</li></ul><p>后者：有块结构+优良的程序安全，问题更少+欧洲情结（Fortran在美洲）</p><ul><li>入手：打破LIFO（先进后出）<strong>仿真系统中有一些个体，并不是先创建就一定先消亡</strong> </li><li>措施：<ol><li>有一个可以描述行为的程序</li><li>有一个pointer能够控制实体</li><li>有些操作只能针对某些数据</li><li>需要管理者管理数据，控制其生命周期等</li></ol></li></ul><p>实现：写了一个runtime system，创建了一个关键字“SIMULA”（利用compiler先翻译为algol 60），兼容algol 60 &#x3D;&gt;SimulaI 1（不是设计语言）</p><h3 id="Simula-67-为什么没有进一步发展？"><a href="#Simula-67-为什么没有进一步发展？" class="headerlink" title="Simula 67 为什么没有进一步发展？"></a>Simula 67 为什么没有进一步发展？</h3><ol><li>Born：在欧洲出身，缺少大量应用，科技中心在美洲</li><li>Expensive</li><li>缺乏一个好的IDE，集成开发效率没有提示</li><li>没有更多的publication</li><li>程序占用体积非常大，对并发、数据类型、runtime的表述也不太好</li></ol><h3 id="C-的诞生"><a href="#C-的诞生" class="headerlink" title="C++的诞生"></a>C++的诞生</h3><p>Bjarne Stroustrup</p><h4 id="史前1979（剑桥实验室）"><a href="#史前1979（剑桥实验室）" class="headerlink" title="史前1979（剑桥实验室）"></a>史前1979（剑桥实验室）</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663072053058-c6dc0148-4586-4881-9689-7b8ef03548ed.png" alt="image.png"><br>PASCAL？？为什么不选择–类型系统的支持太弱<br />但是，遇到了<strong>灾难：缺点-性能差，无法从模拟器中获取数值，模拟器没有提供他所需要的数值</strong><br /><strong>问题：Linker 不适合大程序 原因：运行中 的类型检查和废料收集消费了80%</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663072325747-b891f2db-b861-4399-994c-a09f1c6749a6.png" alt="image.png"><br>第二阶段：BCPL 缺点：太复杂，Debug难<br />不使用C：对C语言不熟悉<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663072435974-0bfa7f50-0bed-4be1-941d-89fe7d211ef3.png" alt="image.png"><br>BCPL不是一个合适的工具，并且目前对C不熟悉<br />所以此时并没有发明C++的想法，有做一定的思考</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663072591666-877ea1f2-a96f-4666-a99c-5ed8a813728c.png" alt="image.png"><br>哲学观（对C++的指导有一定重要作用）：存在主义（与创始人-克尔凯郭尔同为丹麦人）&#x3D;&gt;尊重个体的差异性&#x3D;&gt;有用即可以包含进来&#x3D;&gt;成为各种工程师都可以使用的工具</p><ol><li>实验更重要</li><li>不是科学家的玩物（《地下室手记》）</li><li>不是证明一种观点，而是解决一个问题，可以风格多样，而不是“真理之路 ”</li></ol><h4 id="1979（Bell-Lab）"><a href="#1979（Bell-Lab）" class="headerlink" title="1979（Bell Lab）"></a>1979（Bell Lab）</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663073359288-2562db63-2fef-40b8-92c4-586dfca4776d.png" alt="image.png"><br>Bell Lab中有Unix的创始人（Ken Thompson）&#x3D;&gt;可以熟练使用C了</p><ul><li>并行用库实现</li><li>舍弃常用的科学数据的支持</li><li>遇到了Link问题，所以需要兼容C，利用C的link，放弃housekeeping</li></ul><p><strong>引入一切我觉得有用的东西，并且不轻易放弃 程序语言的设计者不替程序员做出决定</strong></p><h4 id="1982-发展"><a href="#1982-发展" class="headerlink" title="1982 发展"></a>1982 发展</h4><p>McIroy：做Unix的三剑客之一（RobPike、Thompson）<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663073562162-e06ec8a7-2bf5-4921-8b1a-20153a253b16.png" alt="image.png"></p><h4 id="1983-诞生"><a href="#1983-诞生" class="headerlink" title="1983 诞生"></a>1983 诞生</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663074332166-fa77cf41-8eb9-44a3-88ba-c3dc25dc1f8b.png" alt="image.png"><br>cPP:pre Process 预处理：做editor工作。define&lt;&#x3D;&gt;find &amp; replace 编辑不是编译<br />Cpre:C with class 翻译成C。如果出错则即使返回。由C compiler判定有无语法上的错误<br />Cfront：C++的语法检查器，此时C compiler不做语法上的检查<br />C++是C的扩充，编译时不是直接翻译成机器代码的，而是C，需要依靠C的link</p><ul><li>ANSI：科学家+工程师+工具的开发者。业界专业人士认可</li><li>ISO：国际组织</li></ul><p>正交性：功能上的冲突</p><h3 id="C和C-的关系"><a href="#C和C-的关系" class="headerlink" title="C和C++的关系"></a>C和C++的关系</h3><ol><li>C++是C的超集</li><li>C++支持C所支持的全部编程技巧</li><li>任何C程序都能被C++用基本相同的方法编写，并具备同等开销（时间、空间）</li></ol><p><strong>与可能出现的错误相比，更重要的是能做什么好的事情</strong><br /><strong>Programmer needs to be trusted</strong></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>C语言：</p><ul><li>开发效率低</li><li>易用性和安全性低（没有越界检查），是为了提高语言本身的表达能力</li><li>运行效率高&#x3D;&gt;硬件效率高仍然需要软件的运行效率高 例如：3D渲染、自动驾驶、功耗控制</li><li>具有不可替代性 不能保证新写的程序效果一定一样，程序正确性无法证明。早期用C语言写的，在关键领域中不能随意改变</li><li>灵活、高效、可用、可移植</li><li>某些语言结构不安全，没有舍弃C中的危险之处</li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663077652393-995d2800-b0b8-4c1d-88a0-1caa10540bdb.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663077620317-126e8c4f-6d5a-4159-982f-f59f7ab61308.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663077637077-bfe54c46-c02f-4d38-8a15-719e315d0d9a.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二课 SP</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%BA%8C%E8%AF%BE%20SP/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%BA%8C%E8%AF%BE%20SP/</url>
      
        <content type="html"><![CDATA[<p>思想：自顶向下，逐步求精<br />控制流：顺序、选择、重复，不允许随意出现goto语句。消除goto语句后，程序的表达能力不变<br />组成 &#x3D; Data structure + algorithm</p><ol><li>Built in data type：char int float double</li><li>计算控制</li><li>组织 function </li><li>构造数据类型：array struct union pointer</li></ol><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p><strong>Use const whenever possible</strong></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>int x &#x3D; 8;<br />组成：</p><ol><li>性质：变量、常量</li><li>名</li><li>值</li><li>地址—需要touch硬件。simula 67 把所有的数据都放入heap中，造成了效率缓慢</li><li>ADT：抽象数据类型–在计算机中，任何一个数据都是有限的、可数的、离散的。数据类型决定了值集 16位（-32768~32767）</li></ol><p>Data type 定义了值集和**同类型计算的语义 **例如int+double，是通过数据类型的转换实现的<br />类型系统：</p><ol><li>强类型语言、弱类型语言：体现对数据类型的容忍度的强弱，是否宽松。弱类型更灵活，但负载更大、问题更多</li><li>动态语言、静态语言：在compiler+linker阶段可以确定，则是静态类型，要运行阶段确定则是动态类型（例如实现多态时，只有在实际运行时调用，才能确定具体的数据类型，但是需要满足一定的约束）。    <strong>C++：强类型、动&#x2F;静结合</strong> <strong>类型安全不能代替测试</strong></li><li>更加灵活的语言类型：duck</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663250150255-bfe343b5-29c6-47a8-b69c-f595dce6df46.png" alt="image.png"> <br />都有quack（）则可以调用，不一定需要父子类关系</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ol><li>要考虑优先级、结合性</li><li>类型转换约定：混合类型转换（int可以转换为double） **逐个、趋强  **</li><li>求值次序：取决于compiler（副作用：破坏可移植性，降低可读性，一定要消除）</li></ol><p>表达式越清晰越好，副作用的产生没有任何好处。表达式效率由compiler决定</p><ol start="4"><li>谨防overflow</li><li>auto：由编译器推理出数据的类型，表达更加灵活（新引入的机制）</li></ol><p>种类：</p><ul><li>赋值：x&#x3D;8 是表达式             x&#x3D;8; 是表达式语句 目的：<strong>使语言更灵活，使得操作符可重载</strong></li></ul><p>左值：可以出现在赋值表达式左部的表达式，具有存放数据的确定地址。<strong>不一定是变量，例如函数（返回reference）</strong><br />类型不同时，先计算右值表达式的值，再转换为左值类型，然后赋值</p><ul><li>逗号</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663255686452-64b56afe-42f8-4ed6-9f88-2f21fba42839.png" alt="image.png"></p><ul><li>算术</li><li>关系和逻辑</li><li>条件运算符表达式：<ul><li>唯一的三目运算符</li><li>只计算一个运算分量</li><li>不可以操作重载</li><li>可嵌套：就近原则</li></ul></li><li>字位运算符表达式（用bit表示状态位）</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663255982050-b33523c9-acf7-48ee-ab7f-badc0f8fc70e.png" alt="image.png"><br>SSA：static single assignment 处理中间码-异或操作 </p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h4 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h4><p>表达式+分号：方便进行操作符的重载，给语言带来很大的灵活性</p><h4 id="IO语句"><a href="#IO语句" class="headerlink" title="IO语句"></a>IO语句</h4><p>封装在库，剥离开来</p><ul><li>cin、cout    iostream iostream.h</li><li><blockquote><blockquote><p>、&lt;&lt;可重载</p></blockquote></blockquote></li></ul><h4 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h4><p>顺序、选择、重复</p><ul><li>for：循环三要素：循环变量初始化、终止条件、改变循环控制变量。<strong>for将该三要素放在一起，方便更清晰地看清循环</strong></li><li>switch+整型表达式；case:整型常量表达式（在编译之时就知道值）。只用一次比较就可以跳转到其他地方，比if语句减少了许多比较的消耗。<strong>brake</strong>记得使用。**尽量避免用字面常量，该用符号常量或者enum枚举类型 **</li></ul><p>符号常量 const int RED &#x3D; 0；<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663257563741-1cfe6b2c-4277-4acc-aad9-5bff897315c6.png" alt="image.png"><br>代码结构非常一致：利用枚举和表的形式。同时表可以存储在外部文件（资源文件）中，不需要放置在源代码中<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663257801245-73a603d8-fa30-427c-8730-f94739c811fc.png" alt="image.png"></p><h2 id="C-的用途"><a href="#C-的用途" class="headerlink" title="C++的用途"></a>C++的用途</h2><ul><li>everywhere</li><li>everything</li><li>invisible</li></ul><p>Zero 零开销<br />语言的发展和Compiler的发展紧密相关。当compiler做的比人好时，才可以将对应的语言成分添加进来。<strong>避免效率上的降低。包含了C，又实现了抽象，同时又不降低效率</strong><br />Syntax - Deduct Reduce</p><h3 id="命令式编程范式"><a href="#命令式编程范式" class="headerlink" title="命令式编程范式"></a>命令式编程范式</h3><ul><li>结构化程序设计：<strong>顺序、选择、循环</strong> 三种控制结构决定了整个控制流</li><li>面向对象程序设计：<strong>封装、继承、多态</strong> 没有改变命令式编程范式的状态转换的思想</li></ul><h3 id="声明式编程范式"><a href="#声明式编程范式" class="headerlink" title="声明式编程范式"></a>声明式编程范式</h3><p><code>Select xxx form xxx when xxx</code>无法知道某一时刻程序的状态 &#x3D;&gt;数据库管理系统（<strong>有后台系统管理支撑</strong>）<br />风险：不可控，虽然描述简单，但无法对复杂度进行控制。 </p><ul><li>函数式编程：代码简洁、易于理解、并发（不依赖时间和环境）。要求：<strong>纯函数</strong>：<strong>不依赖环境，如果改变了外部环境，就会产生副作用</strong></li></ul><p>**但是，副作用在程序中非常有效     **</p><ul><li>逻辑程序设计</li></ul><h3 id="遗传程序设计-Genetic-Programming"><a href="#遗传程序设计-Genetic-Programming" class="headerlink" title="遗传程序设计 Genetic Programming"></a>遗传程序设计 Genetic Programming</h3><ol><li>算法不依赖于数据结构的特定实现，算法可以从特定实现中抽象出来，而且<strong>效率无损</strong></li><li>ADT把实现和接口分开，不应该忽略复杂度</li><li>template并不实际生成代码，类似于图纸，在编译时生成对应的数据类型。描述算法的时候不使用数据类型，但实际上运行时需要有代码，所以依靠的就是template</li><li>Alexander Stepanov 设计了STL（standard template library） - &gt; <strong>泛型程序设计</strong></li></ol><br /><h3 id="函数式程序设计-functonal-programming"><a href="#函数式程序设计-functonal-programming" class="headerlink" title="函数式程序设计 functonal  programming"></a>函数式程序设计 functonal  programming</h3><h3 id="结构化程序设计-Structured-Programming"><a href="#结构化程序设计-Structured-Programming" class="headerlink" title="结构化程序设计 Structured Programming"></a>结构化程序设计 Structured Programming</h3><h3 id="面向对象程序设计-Objected-oriented-Programming"><a href="#面向对象程序设计-Objected-oriented-Programming" class="headerlink" title="面向对象程序设计 Objected-oriented Programming"></a>面向对象程序设计 Objected-oriented Programming</h3><h2 id="历史发展路径"><a href="#历史发展路径" class="headerlink" title="历史发展路径"></a>历史发展路径</h2><p> <img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664261519533-1aad5d5d-00c7-4cd4-aaef-2d0eefcb7d31.png" alt="image.png"></p><hr><h2 id="C-是C的超集"><a href="#C-是C的超集" class="headerlink" title="C++是C的超集"></a>C++是C的超集</h2><p>C++ 支持 C 所支持的全部编程技巧<br />任何 C 程序都能被 C++ 用基本相同的方法编写，并具备同等开销（时间、空间）</p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO 设计</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/IO%20%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/IO%20%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="getline（）"><a href="#getline（）" class="headerlink" title="getline（）"></a>getline（）</h2><p>Get line from stream into string</p><ul><li>Extracts characters from <em>is</em> and stores them into <em>str</em> until the delimitation character <em>delim</em> is found (or the newline character, ‘\n’, for <em>(2)</em>).</li></ul><p>从is中提取字符并将其存储到str中，直到找到<strong>分隔符delim</strong>（或**换行符’\n’**，for（2））。</p><ul><li>The extraction also stops if the end of file is reached in <em>is</em> or if some other error occurs during the input operation.</li></ul><p>如果在中到达文件结尾，或者在输入操作期间发生其他错误，提取也会停止。</p><ul><li>If the delimiter is found, it is extracted and discarded (i.e. it is not stored and the next input operation will begin after it).</li></ul><p>如果找到分隔符，则会将其提取并丢弃（即不存储它，然后将开始下一个输入操作）。</p><ul><li>Note that any content in str before the call is replaced by the newly extracted sequence.<br />Each extracted character is appended to the <a href="https://cplusplus.com/string">string</a> as if its member <a href="https://cplusplus.com/string::push_back">push_back</a> was called.</li></ul><p>请注意，调用之前str中的任何内容都将被新提取的序列替换。<br />每个提取的字符都附加到字符串中，就好像调用了其成员push_back一样。</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>使用指针开辟数组时，一定要在使用前<strong>初始化值</strong></li><li>使用指针才能够开辟动态数组，但是不太容易得到数组的长度</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三课 Function</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%89%E8%AF%BE%20Function/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%89%E8%AF%BE%20Function/</url>
      
        <content type="html"><![CDATA[<p>BNF</p><ol><li>Associativity 结合性</li><li>Priority</li><li>Type conversion 混合类型运算时的数据类型转换（决定了二进制序列的解释方式）</li><li>Evaluation order 求值次序 &#x3D; &gt; side effect 从左往右和从右往左算的时候结果不一样 （表达式的副作用没有用，函数的副作用才有用）</li></ol><p>异常：Exception  <br />特征：</p><ol><li>可以预见到</li><li>无法避免</li></ol><p>类型：</p><ul><li>Side effect</li><li>精度问题：类型转换涉及精度变换   doube -&gt; int 窄转换</li><li>Overflow</li></ul><h2 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h2><p>许多改进都是为了<strong>更方便的写程序，减少错误</strong></p><ol><li>auto - 编译器根据表达式确定数据类型，避免数据类型名的重复。关键字的引入需要综合考虑，如果太短，会造成已有的变量名冲突，如果太长，则会不受欢迎</li><li>Range-for <code>for(auto i:vector )</code><ol><li>for <code>trivial</code>错误</li><li>避免for循环的边界错误</li></ol></li><li>Uniform Initialization 结构化和OO的初始化不一致</li><li>Constexpr  利用<strong>纯函数</strong>不能受到状态的影响</li></ol><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>以空间换时间：<br />用表存储switch的所有结果，实现一次比较找到目标<br />可以用if else 、表、平衡二叉树表示</p><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664432297062-f3537141-b196-4496-8fbc-1a7b58a3d4a4.png" alt="image.png"><br>Data 全局数据区：下界清楚，存放全局变量<br />栈：存放函数。可以重复利用有限空间，符合局部性原则，由编译器控制生死<br />堆：存放动态变量，malloc()，heap中的管理由程序员接管<br />栈和堆的大小由程序运行的逻辑决定，所以<strong>堆从下往上，栈从上往下</strong><br />代码区：以function为基本单位，函数有完整的逻辑。<br />函数有定义点和调用点。所以函数定义时也需要存储在符号表中。节省了重复代码的出现。<br /><strong>RAII</strong>机制<br /><strong>DLL</strong>按需所取，牺牲时间，节省空间，但是不是全平台自适应，因为不一定有对应的code<br />static：永远分配 - 》 给予固定空间：无法实现递归，好处是减少了和内存之间的交互<br />函数的调用：后进先出 – &gt; 表达能力更强（可以递归），但是在数据区付出了更多的<strong>COST 代价</strong><br />符号表的建立：</p><ol><li>当看到<strong>使用点</strong>时，在符号表中找到对应的地址，取值使用</li><li>当和lib进行link时，找到需要的变量</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664431914980-4d999132-86af-419c-a6ab-916fc037af8f.png" alt="image.png"></p><ol><li>C里面不允许函数重载，所以可以用fun代表 。但是如果重载，需要在符号表中嵌入参数</li><li><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664432871903-1ba977fa-21fe-42b0-a0a5-695cbe9d27a0.png" alt="image.png">  4代表后面四个字节为函数名，i代表int，d代表double   &#x3D;&gt;  使用Lib需要注意什么？ &#x3D;&gt; <strong>添加接口 <strong><code>**extern &quot;C&quot; **</code></strong> &#x3D;&gt; 判断有无name mangling</strong></li></ol><h3 id="函数的COST"><a href="#函数的COST" class="headerlink" title="函数的COST"></a>函数的COST</h3><p>函数：复用机制+自顶向下，逐步求精<br />指令开销+数据开销<br />能在不降低可读性的前提下，降低COST吗？</p><ol><li>在src源代码中写的是函数</li><li>在经过编译器编译后，将函数代码直接放在对应的代码块中，不产生函数调用，省去了压栈出栈的过程</li></ol><p>缺点：</p><ol><li>替换后代码会拉长</li><li>代码段的拉长会带来危害</li></ol><p>程序员主动使用<code>inline</code>，向编译器提出申请，直接把函数对应的代码放入源代码中 &#x3D;&gt; 因为不是完美的，所以需要程序员自己提出申请。但是，<strong>提出申请后，编译器有权驳回</strong><br />程序员使用<code>virtual</code> 提出<code>dynamic binding</code>，副作用：效率较低，以低效率获得语言的灵活性。不像java，全部默认为<code>dynamic binding</code>。 <strong>Programmer can be trusted</strong><br />原则</p><ul><li>定义不允许嵌套</li><li>先定义后使用：给描述以约束，同时提高编译器的效率：编译器是一个个cpp扫描的</li></ul><h3 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数 inline"></a>内联函数 inline</h3><p>要明智的申请inline函数</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>提高可读性，提高效率</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>编译系统将为 inline 函数创建一段代码，在调用点，以相应的代码替换</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法实现递归，语言表达能力降低</li><li>代码段的增加会带来效率的降低</li><li>函数指针</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ol><li>函数的长度短小，避免替代带来额外开销</li><li>使用频繁的代码</li><li>简单的代码：不要有多个转移接口的结构</li></ol><p><strong>构造函数</strong>适合inline函数。构造函数放入class的定义中，会自动申请inline</p><h4 id="局部性原则"><a href="#局部性原则" class="headerlink" title="局部性原则"></a>局部性原则</h4><p>为什么代码段增大会出现问题？为什么不能有复杂的数据结构？<br /><strong>时间局部性，空间局部性 &#x3D;&gt; 每一次都是调用相关的放入内存，如果有额外需要，再通过虚拟内存管理，从硬盘中获得对应数据</strong><br />因为内存是分级的，附近的代码放入Cache中（高速缓存）。原来的Cache中，为<code>x=1 ;f(1) ;</code>，一直都在Cache中循环。但如果<code>f(1)</code>替代为<code>Ablock</code>，因为Cache有限，block中的有些代码在Cache中，有些不在，需要不断调换block在Cache中的代码。Cache中会产生<strong>抖动</strong>，即<strong>调度的cost</strong></p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增大目标代码</li><li>病态的换页</li><li>降低指令快取装置的命中率</li></ul><h3 id="函数指针-？？"><a href="#函数指针-？？" class="headerlink" title="函数指针 ？？"></a>函数指针 ？？</h3><p>实现<code>framework</code></p><h3 id="函数的执行机制"><a href="#函数的执行机制" class="headerlink" title="函数的执行机制"></a>函数的执行机制</h3><ul><li>建立被调用函数的栈空间</li><li>参数传递</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664433776047-374a9de5-e426-45ea-83d0-ffed58580c62.png" alt="image.png"></p><ul><li>值传递</li><li>引用传递</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664435210023-67c5958e-e097-4127-b390-eabe1c7acef3.png" alt="image.png"></p><ul><li>保存调用函数的运行状态</li><li>将控制转交给被调用函数</li></ul><p><strong>局部变量要主动初始化</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664434310533-342546b2-d6c4-4495-a4f2-62321d71fe37.png" alt="image.png"></p><h3 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h3><h4 id="cdecl"><a href="#cdecl" class="headerlink" title="_cdecl"></a>_cdecl</h4><h4 id="stdcall"><a href="#stdcall" class="headerlink" title="_stdcall"></a>_stdcall</h4><p><strong>参数的空间是由被调用者返回，不支持参数是可变长的  — 适合平台的协作</strong></p><ul><li><strong>_cdecl：参数的空间是由调用者返回，支持参数是可变长的 例如：</strong><code>**printf(char  *s, ...) **</code></li></ul><p>可变参数的缺点： </p><ol><li><code>**printf(&quot;hi &quot;,num1,num2 )**</code> 有缺陷：没有用num1 num2，却可以拿到对应的值，不安全</li><li>会增大代码的长度。因为调用是复用多次的，所以积少成多了</li></ol><p><code>cout</code>中<code>&lt;&lt;</code>是双目操作符，实现原理是操作符重载，而不是可变参数的调用<br />调用者还和被调用者还<br />差别：发生在返回时</p><h4 id="fastcall"><a href="#fastcall" class="headerlink" title="_fastcall"></a>_fastcall</h4><p>参数传递放入的是寄存器中，而不是push到栈中<br />瓶颈：<br />寄存器数量有限，每用一个寄存器，寄存器中原有的值都要保存下来</p><h4 id="thiscall"><a href="#thiscall" class="headerlink" title="_thiscall"></a>_thiscall</h4><p>略</p><h3 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h3><h4 id="Call-by-name"><a href="#Call-by-name" class="headerlink" title="Call by name"></a>Call by name</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664436709907-02d36654-e2eb-453c-9fb1-810fd5d02fe6.png" alt="image.png"><br>结果: a[2] &#x3D; 3</p><h4 id="Call-by-value-result"><a href="#Call-by-value-result" class="headerlink" title="Call by value-result"></a>Call by value-result</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664436780089-f29835a9-326d-445d-afc1-dcd8c2a9302a.png" alt="image.png"></p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>原型：<code>void f（int ， int）</code><br />编译器在调用函数时，能根据原型生成正确的代码<br />如果编译没找到时，也会在link时找到</p><ul><li>遵循先定义后使用原则</li><li>自由安排函数定义位置</li><li>只需参数类型，无需参数名称</li><li>编译器检查</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>原则：</p><ul><li>名同，参数不同</li><li>返回值类型不作为区别重载函数的依据</li></ul><p>匹配原则</p><ul><li>会产生<strong>二义性</strong>：10可以转为long，也可以转为double <code>**ambiguous**</code></li><li>严格</li><li>内部转换</li><li>用户定义的转换</li></ul><p>意义：多态<strong>一名多用</strong> 属于语言的特征</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ol><li>默认参数的声明<ol><li>函数原型中给出 <code>int f(int =1,int =2,int =3)</code> <strong>原型决定默认参数</strong></li><li>先定义的函数给出</li></ol></li><li>默认参数的顺序<ol><li><br /></li></ol></li><li>默认参数与函数重载</li></ol><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><ul><li>提供坏地址 &#x3D; &gt; 指令和数据为正交</li><li>不自动写代码，而是选择指令去运行（借刀杀人）&#x3D;&gt; 内存地址的随机化，不会产生错误，只会产生异常</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计类题目</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E7%B1%BB%E9%A2%98%E7%9B%AE/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E7%B1%BB%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="355-设计推特"><a href="#355-设计推特" class="headerlink" title="355. 设计推特"></a><a href="https://leetcode.cn/problems/design-twitter/">355. 设计推特</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/10/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设计推特</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> timestamp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tweet</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tweet* next;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="built_in">Tweet</span>(<span class="type">int</span> id,<span class="type">int</span> time)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;time = time;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; followed;</span><br><span class="line">    Tweet* head;</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">int</span> userId)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = userId;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//        默认关注自己</span></span><br><span class="line">        <span class="built_in">follow</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        关注用户</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">follow</span><span class="params">(<span class="type">int</span> userId)</span></span>&#123;</span><br><span class="line">        followed.<span class="built_in">insert</span>(userId);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        取消关注</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unfollow</span><span class="params">(<span class="type">int</span> userId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (userId!= <span class="keyword">this</span>-&gt;id)&#123;</span><br><span class="line">            followed.<span class="built_in">erase</span>(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(<span class="type">int</span> tweetId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tweet = <span class="keyword">new</span> <span class="built_in">Tweet</span>(tweetId,timestamp);</span><br><span class="line">        timestamp++;</span><br><span class="line">        tweet-&gt;next = head;</span><br><span class="line">        head = tweet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> userId;</span><br><span class="line"><span class="comment">//    unordered_map&lt;int,*User&gt; userMap;</span></span><br><span class="line"><span class="comment">//    unordered_map&lt;int,User&gt; userMap;</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,User*&gt; userMap;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Twitter</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        c++ unordered_map不允许有重复的key。因此，如果key存在，则count返回1，如果不存在，则count返回0.</span></span><br><span class="line">        <span class="keyword">if</span> (!userMap.<span class="built_in">count</span>(userId))&#123;</span><br><span class="line">            User* newUser = <span class="keyword">new</span> <span class="built_in">User</span>(userId);</span><br><span class="line">            userMap.<span class="built_in">insert</span>(&#123;userId, newUser&#125;);</span><br><span class="line">            <span class="comment">//            userMap.insert(userId,*new User(userId))</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> user = userMap.<span class="built_in">find</span>(userId);</span><br><span class="line">        user-&gt;second-&gt;<span class="built_in">post</span>(tweetId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** follower 关注 followee */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若 follower 不存在，则新建</span></span><br><span class="line">        <span class="keyword">if</span> (!userMap.<span class="built_in">count</span>(followerId))&#123;</span><br><span class="line">            User *newUser = <span class="keyword">new</span> <span class="built_in">User</span>(followerId);</span><br><span class="line">            userMap.<span class="built_in">insert</span>(&#123;followerId,newUser&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 followee 不存在，则新建</span></span><br><span class="line">        <span class="keyword">if</span> (!userMap.<span class="built_in">count</span>(followeeId))&#123;</span><br><span class="line">            User *newUser = <span class="keyword">new</span> <span class="built_in">User</span>(followeeId);</span><br><span class="line">            userMap.<span class="built_in">insert</span>(&#123;followeeId,newUser&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        userMap.<span class="built_in">find</span>(followerId)-&gt;second-&gt;<span class="built_in">follow</span>(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** follower 取关 followee，如果 Id 不存在则什么都不做 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (userMap.<span class="built_in">count</span>(followerId))&#123;</span><br><span class="line">            <span class="keyword">auto</span> follower = userMap.<span class="built_in">find</span>(followerId);</span><br><span class="line">            follower-&gt;second-&gt;<span class="built_in">unfollow</span>(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt; 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (Tweet &amp;a, Tweet &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b.time &gt; a.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;Twitter::<span class="built_in">getNewsFeed</span>(<span class="type">int</span> userId) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!userMap.<span class="built_in">count</span>(userId))&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; followersId = userMap.<span class="built_in">find</span>(userId)-&gt;second-&gt;followed;</span><br><span class="line">    priority_queue&lt;Tweet*&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> id : followersId )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> usr = userMap.<span class="built_in">find</span>(id)-&gt;second-&gt;head;</span><br><span class="line">        <span class="keyword">if</span> ( !usr ) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        pq.<span class="built_in">push</span>(usr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( !pq.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( res.<span class="built_in">size</span>() == <span class="number">10</span> ) <span class="keyword">break</span>;</span><br><span class="line">        Tweet *twt = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(twt-&gt;id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( twt-&gt;next )</span><br><span class="line">        &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(twt-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先级队列实现"><a href="#优先级队列实现" class="headerlink" title="优先级队列实现"></a>优先级队列实现</h4><p><a href="http://c.biancheng.net/view/6987.html">C++ STL priority_queue容器适配器详解</a></p><h4 id="无序map容器"><a href="#无序map容器" class="headerlink" title="无序map容器"></a>无序map容器</h4><p><a href="http://c.biancheng.net/view/7231.html">C++ STL unordered_map容器用法详解</a></p><h4 id="运算符重载支持自定义比较函数"><a href="#运算符重载支持自定义比较函数" class="headerlink" title="运算符重载支持自定义比较函数"></a>运算符重载支持自定义比较函数</h4>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第四课 程序组织</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%9B%9B%E8%AF%BE%20%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%9B%9B%E8%AF%BE%20%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87/</url>
      
        <content type="html"><![CDATA[<h2 id="程序组织"><a href="#程序组织" class="headerlink" title="程序组织"></a>程序组织</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664867305730-0e04b845-a0b6-4d31-aa70-fbecfdec6975.png" alt="image.png"></p><p>作用域scope </p><ul><li>程序级：link中都是可见的</li><li>函数级</li><li>块级</li><li>文件级</li></ul><p>生命周期：获得内存 - &gt; 失去内存。生命周期外的数据都是无效的<br /><strong>idle point</strong> 悬挂指针 – 想要的资源被人夺走了</p><h3 id="引入外部数据"><a href="#引入外部数据" class="headerlink" title="引入外部数据"></a>引入外部数据</h3><p>extern：非本地定义的，进行引入<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664867669847-e620aea7-f570-46e5-b616-4690212bce65.png" alt="image.png"><br>头文件：将给别人的接口、数据写在头文件中。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664867774586-de2f9ca1-0927-40a5-853d-154892edfe4e.png" alt="image.png"><br><code>#</code><strong>编译预处理符号，作用为</strong><code>**editor**</code>   include找到对应头文件，ctrl+all+进行copy。后缀<code>.h</code>不是必须的，是统一规范好的<br />static：<strong>将作用域由程序级限制为文件级</strong>。因此，即使变量重名，互相不影响。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664868100617-e238648c-b115-4faf-9d73-aa65434e94f9.png" alt="image.png"><br>公开的放入头文件中，为程序级。私有的设置<code>static</code>，为文件级。<br />对于常量：默认属性为static<br />使用常量头文件<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664868126354-ddc3d778-37eb-4e42-ad50-6adc61a4d339.png" alt="image.png"></p><p>main中的局部变量是<strong>全生命周期的</strong><br />static定义的局部变量是静态局部变量，当自己创建后不会被消除</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ol><li>常量定义</li><li>变量、函数声明</li><li>编译预处理</li><li>类型定义</li><li>inline函数</li></ol><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664868545815-d0187d6c-f2f8-4b82-96bd-e9dec6ae584f.png" alt="image.png"><br>declaration：类似绝对路径<br />directive：使用目录，批量处理</p><ul><li>开放：当需要补充时，直接在当前文件补充代码即可</li><li>别名</li><li>全局</li><li>可嵌套</li><li>重载：不建议在同一作用域两次使用using-directive，优先考虑  using-declaration</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664868814834-34f93d66-d599-4ce2-a441-1a7fc0989488.png" alt="image.png"></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><a href="https://blog.csdn.net/ypshowm/article/details/89030194#:~:text=static%20%E6%98%AFC%2F,C%2B%2B%E4%B8%AD%E7%9A%84%20%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%E3%80%82">c++中static的作用</a></p><ol><li>修饰<strong>局部变量</strong>时，表明该变量的值不会因为函数终止而丢失。  </li><li>修饰<strong>函数</strong>时，表明该函数只在同一文件中调用。</li><li>修饰<strong>全局变量</strong>时，表明一个全局变量只对定义在同一文件中的函数可见。</li></ol><h3 id="编译预处理"><a href="#编译预处理" class="headerlink" title="编译预处理"></a>编译预处理</h3><p>不理解cpp的语法，没有程序设计的概念。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664869191454-f81af710-8dbe-4e6b-bbc0-d833d90153ac.png" alt="image.png"></p><ul><li>穿透作用域</li><li>潜伏于环境  <code>gcc -7 -Dsqrt=rand -Dreturn=exit </code>等价 <code>#define sqrt random</code></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664869150689-3cb3aaff-4613-431d-bf6c-264d9679f6f1.png" alt="image.png"></p><p>替代编译预处理：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664869273741-1ab1e243-846c-42f9-8bdf-0fcd3a656191.png" alt="image.png"><br>log：记录执行时间、次数等，利用<code>_FILE_</code>等宏。</p><h4 id="ifdef"><a href="#ifdef" class="headerlink" title="ifdef"></a>ifdef</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> check </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> release 定义最后将要发布的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  如果check没有定义，则后面的相关代码根本不会产生。让程序员选择</span></span><br><span class="line">将要参与编译的语句。仍然是在editor期间发挥作用</span><br></pre></td></tr></table></figure><ul><li>版本控制</li><li>注释代码</li></ul><h4 id="pragma"><a href="#pragma" class="headerlink" title="pragma"></a>pragma</h4><ol><li>error</li><li>warning：包含潜在的错误，进行预警<ol><li>local variable没有定义</li><li>strcpy 的两个长度不同</li><li>强制转换时会产生精度损失</li></ol></li></ol><p>利用pragma可以把warning升级为error</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic <span class="keyword">error</span> <span class="string">&quot;-Wuninitialized&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i;    <span class="built_in">printf</span>(“%d\n<span class="string">&quot;, i);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>利用pragma进行编译预处理，常用于没有ide时</p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++常用处理</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/C++%E5%B8%B8%E7%94%A8%E5%A4%84%E7%90%86/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/C++%E5%B8%B8%E7%94%A8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-输入多行字符串出错"><a href="#1-输入多行字符串出错" class="headerlink" title="1. 输入多行字符串出错"></a>1. 输入多行字符串出错</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; ws;</span><br><span class="line"><span class="comment">//    输入整数后，后面会跟着一个换行符，需要额外进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        string line;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关键：使用<code>**cin&gt;&gt;ws**</code>来吸收残存在输入流中的换行符</p><h3 id="2-判断字符串内容是否为整数"><a href="#2-判断字符串内容是否为整数" class="headerlink" title="2. 判断字符串内容是否为整数"></a>2. 判断字符串内容是否为整数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(<span class="type">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> &amp;c: str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键：调用<code>**isdigit()**</code>函数，一个一个进行判断，不要嫌弃麻烦<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664888337017-65e8ea0f-6c34-43cb-8043-8c3f78ad0cb4.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664888353963-5d911b02-9b7a-4761-91d1-1799257bd802.png" alt="image.png"></p><h3 id="3-字符串按字符切割"><a href="#3-字符串按字符切割" class="headerlink" title="3. 字符串按字符切割"></a>3. 字符串按字符切割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">stringSpilt</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> <span class="type">char</span> split, vector&lt;string&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">    string token;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(iss, token, split)) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键：</p><ol><li>调用<code>**istringstream iss (str)**</code></li><li>调用 <code>**getline(iss,token,split)**</code></li></ol><h3 id="4-修改哈希表中的值"><a href="#4-修改哈希表中的值" class="headerlink" title="4. 修改哈希表中的值"></a>4. 修改哈希表中的值</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setVariable</span><span class="params">(string &amp;str, string &amp;val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">checkVal</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (mapVal.<span class="built_in">count</span>(str))&#123;</span><br><span class="line">        mapVal.<span class="built_in">erase</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    mapVal.<span class="built_in">insert</span>(&#123;str, <span class="built_in">stoi</span>(val)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>直接使用数组的表现形式进行增加或者修改</p><h3 id="5-字符串转数字"><a href="#5-字符串转数字" class="headerlink" title="5. 字符串转数字"></a>5. 字符串转数字</h3><p><strong>stoi</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;2&quot;</span>) &lt;&lt; endl;   <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;21214 avb&quot;</span>) &lt;&lt; endl;<span class="comment">//21214</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;1000&quot;</span>, <span class="literal">nullptr</span>, <span class="number">2</span>) &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stof</span>(<span class="string">&quot;221.4240&quot;</span>) &lt;&lt; endl;<span class="comment">//221.424</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;221.4240&quot;</span>) &lt;&lt; endl;<span class="comment">//221</span></span><br></pre></td></tr></table></figure><h3 id="6-纯手工char数组转数字"><a href="#6-纯手工char数组转数字" class="headerlink" title="6. 纯手工char数组转数字"></a>6. 纯手工char数组转数字</h3><p>写该函数时，涉及到的小的细节特别的多，需要条理清晰地进行解答。</p><ol><li><code>index</code>问题，因为涉及到<code>arr</code>和<code>tmp</code>双数组，且分别用了<code>i</code> <code>j</code> <code>count</code>三个数字来表示下标。因此，很容易出错。<strong>如果发现输入不同却输出相同时，很可能是下标</strong><code>**j**</code>** 使用时不小心打的是**<code>**count**</code></li><li>初始化问题。因为传入的cmd数组初始化时是<code>**char* cmd[20] = &#123;&#39;0&#39;&#125;;**</code> 。但是，最终赋值的时候，却初始化的是 <code>**&#39;\000&#39;**</code> ，对应的ASCII码值是0。而在这之中，我一直是以48的ASCII码值去进行计算。最终导致结果总是不对</li><li><strong>下标和指数的不一致：该问题很经典。对于一个数组，读取时是需要从右往左读的，但是，这样子时，常用的</strong><code>**i**</code><strong>就不能直接作为pow的第二个参数使用，而是要额外使用一个变量。即：读取时是从右往左，计算时却是从左往右</strong></li><li>最后的一个处理是char数组的结束符是跟随系统的变化而变化的，因此要十分小心。</li><li>关于<strong>负数</strong>🍀~蚌埠住了哇Σ(っ °Д °;)っ。还有<strong>小数</strong>的处理。要<strong>根据需要进行优化</strong>吧<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *tmp = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * DEF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; DEF; ++i) &#123;</span><br><span class="line">        tmp[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = start; j &lt; DEF; ++j) &#123;</span><br><span class="line">        <span class="type">char</span> x = cmd[j];</span><br><span class="line">        tmp[count] = cmd[j];</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="comment">//        int x = tmp[i]-&#x27;0&#x27;;</span></span><br><span class="line"><span class="comment">//        x 被赋值为1 或者 -48 了 原因是cmd初始化时里面是 0&#x27;\000&#x27; 而不是 48&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">//          两者的区别造成了算数时无法统一</span></span><br><span class="line">        <span class="keyword">if</span> (tmp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最开始是使用tmp[count] OMG！！怎么会这么不小心</span></span><br><span class="line">        ans += (tmp[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>,w );</span><br><span class="line">        w++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="7-去重"><a href="#7-去重" class="headerlink" title="7. 去重"></a>7. 去重</h3><h4 id="set-assign"><a href="#set-assign" class="headerlink" title="set+assign"></a>set+assign</h4><p>在三数求和为0的题目中，需要进行去重。那么最好的方式是使用<code>set</code>集合进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;vector&lt;<span class="type">int</span>&gt;&gt; tmp&#123;ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()&#125;;</span><br><span class="line">ans.<span class="built_in">assign</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure><p>此处<code>ans</code>中有重复的元素，则利用<code>set&lt;T&gt;</code>进行 初始化后再重新赋值即可</p><ul><li>assign可以理解为利用迭代器<strong>重新进行赋值</strong>。那么其ans中的原本数据会丢失<blockquote><p>函数原型是：<br>1:void assign(const_iterator first,const_iterator last);<br>2:void assign(size_type n,const T&amp; x &#x3D; T());<br>第一个相当于个<strong>拷贝函数，把first到last的值赋值给调用者</strong>；（<strong>注意区间的闭合-前闭后开</strong>）<br>第二个把n个x赋值给调用者；</p></blockquote></li></ul><h4 id="sort-unique-erase"><a href="#sort-unique-erase" class="headerlink" title="sort+unique+erase"></a>sort+unique+erase</h4><ol><li>unique函数属于STL中比较常用函数，它的功能是元素去重。即<strong>”删除”序列中所有相邻的重复元素(只保留一个)<strong>。此处的删除，并不是真的删除，而是</strong>指重复元素的位置被不重复的元素给占领了</strong>(详细情况，下面会讲)。由于它”删除”的是相邻的重复元素，所以<strong>在使用unique函数之前，一般都会将目标序列进行排序</strong>。</li><li>unique函数通常和erase函数一起使用，来达到删除重复元素的目的。(注：此处的删除是真正的删除，即从容器中去除重复的元素，<strong>容器的长度也发生了变换</strong>；而单纯的使用unique函数的话，<strong>容器的长度并没有发生变化</strong>，只是元素的位置发生了变化)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> myints[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(myints)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(myints, myints + len)</span></span>;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    vec.<span class="built_in">erase</span>(<span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : vec)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>iterator unique(iterator it_1,iterator it_2);<br>这种类型的unique函数是我们最常用的形式。其中这两个参数表示对容器中[it_1，it_2)范围的元素进行去重(注：区间是前闭后开，即不包含it_2所指的元素),返回值是一个迭代器，<strong>它指向的是去重后容器中不重复序列的最后一个元素的下一个元素。</strong><br>unique函数的去重过程实际上就是不停的把后面不重复的元素移到前面来，也可以说是用不重复的元素占领重复元素的位置。</p></blockquote></li></ol><h3 id="8-二分法"><a href="#8-二分法" class="headerlink" title="8. 二分法"></a>8. 二分法</h3><h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h4><ol><li><p>原型1:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,  <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>原型2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h5 id="模板参数解释"><a href="#模板参数解释" class="headerlink" title="模板参数解释"></a>模板参数解释</h5><ol><li><code>ForwardIterator</code>就是一个迭代器，<code>vector&lt; int &gt; v</code>，v数组的首元素就是 <code>v.begin()</code></li><li><code>T&amp;val</code> , 就是一个T类型的变量</li><li><code>Compare</code> 就是一个比较器，可以传仿函数对象，也可以传函数指针</li></ol><h5 id="函数作用："><a href="#函数作用：" class="headerlink" title="函数作用："></a>函数作用：</h5><p>前提是<strong>有序</strong>的情况下，<code>lower_bound</code>返回指向第一个值不小于<code>val</code>的位置，也就是返回第一个<strong>大于等于</strong><code>val</code>值的位置。（通过二分查找）</p><h5 id="参数、返回值含义"><a href="#参数、返回值含义" class="headerlink" title="参数、返回值含义"></a>参数、返回值含义</h5><ul><li><strong>first,last</strong>: 迭代器在排序序列的起始位置和终止位置，使用的范围是<code>[first,last)</code>包括</li></ul><p><code>first</code>到<code>last</code>位置中的所有元素</p><ul><li><strong>val</strong>: 在<code>[first,last)</code>下，也就是区分（找到<strong>大于等于</strong>val值的位置，返回其迭代器）</li><li><strong>comp</strong>： 主要针对于原型二，传一个函数对象，或者函数指针，按照它的方式来比较</li><li><strong>返回值</strong>：返回一个迭代器，指向第一个大于等于val的位置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v= &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//先排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()); <span class="comment">// 1 2 3 4 8</span></span><br><span class="line"><span class="comment">// 定义两个迭代器变量 </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter2; </span><br><span class="line">iter1 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">3</span>);<span class="comment">//迭代器指向3</span></span><br><span class="line">iter2 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">8</span>);<span class="comment">//迭代器指向8（因为第一个大于等于8）</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; *iter1 &lt;&lt; endl; <span class="comment">//输出3</span></span><br><span class="line">    cout &lt;&lt; *iter2 &lt;&lt; endl; <span class="comment">//输出8 说明能够找到最后一个元素</span></span><br><span class="line">    cout &lt;&lt; *iter3 &lt;&lt; endl; <span class="comment">//输出为0</span></span><br><span class="line">cout &lt;&lt; iter1 - v.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//下标 2</span></span><br><span class="line">cout &lt;&lt; iter2 - v.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//下标 4 </span></span><br><span class="line">    cout &lt;&lt; iter3 - v.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//下标5</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">end</span>() - v.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//返回值为5</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h4><p>用法和上面类似。<strong>只是把lower_bound的大于等于换成大于</strong>。仿函数等等<strong>全是相同的用法</strong></p><h3 id="9-迭代器"><a href="#9-迭代器" class="headerlink" title="9. 迭代器"></a>9. 迭代器</h3><h4 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h4><p>容器的end()方法，返回一个<a href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&spm=1001.2101.3001.7020">迭代器</a>，需要注意：这个迭代器<strong>不指向实际的元素</strong>，而是<strong>表示末端元素的下一个元素</strong>，这个迭代器起一个哨兵的作用，<strong>表示已经处理完所有的元素</strong>。<br />因此，在查找的时候，<strong>返回的迭代器，不等于end()，说明找到了目标</strong>。<strong>等于end()，说明检查了所有元素，没有找到目标。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(matrix[i].<span class="built_in">begin</span>(),matrix[i].<span class="built_in">end</span>(),target);</span><br><span class="line">        <span class="keyword">if</span> (it != matrix[i].<span class="built_in">end</span>() &amp;&amp; *it ==target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 此处用二分法获得迭代器，但同时使用 💥!=end() 来说明已经找到了</span></span><br><span class="line">            <span class="comment">// 因为没找到都是默认返回end迭代器，或者说是最后一个元素的下一个元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-自定类处理"><a href="#10-自定类处理" class="headerlink" title="10. 自定类处理"></a>10. 自定类处理</h3><h4 id="vector存储"><a href="#vector存储" class="headerlink" title="vector存储"></a>vector存储</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">movie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> movieId;</span><br><span class="line">    <span class="type">bool</span> isRented;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="type">int</span> shopId;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">movie</span>(<span class="type">int</span> movieId, <span class="type">int</span> price, <span class="type">int</span> shopId) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;movieId = movieId;</span><br><span class="line">        <span class="keyword">this</span>-&gt;price = price;</span><br><span class="line">        <span class="keyword">this</span>-&gt;shopId = shopId;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isRented = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于<code>movie</code>类，如果要用<code>vector</code>存储，有以下可能的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;movie&gt; movieList;</span><br><span class="line"><span class="comment">// 1.在vector中直接存储对象</span></span><br><span class="line">vector&lt;*movie&gt; movieList;</span><br><span class="line"><span class="comment">// 2.错误的使用指针的表示方式</span></span><br><span class="line">vector&lt;movie*&gt; movieList;</span><br><span class="line"><span class="comment">// 3.使用指向movie的指针</span></span><br></pre></td></tr></table></figure><p>建议不直接存储对象</p><ol><li><code>STL</code>的存储实际上是拷贝，因此会重新调用构造函数，再进行赋值，开销大</li><li>从<code>STL</code>中获得的值也不是原来的对象，而是一份新的拷贝，所以存储的指针的值也会改变</li><li>因此，使用指针能够节省成本</li></ol><h4 id="STL删除"><a href="#STL删除" class="headerlink" title="STL删除"></a>STL删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;obj *&gt;m_list;</span><br><span class="line">list&lt;obj *&gt;::iterator ite;</span><br><span class="line"><span class="keyword">for</span>( ite = m_list.<span class="built_in">begin</span>(); ite != m_list.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">delete</span> (*ite);</span><br><span class="line">ite = m_list.<span class="built_in">erase</span>(ite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先<code>delete</code>，释放内存，在将其从容器中删除</p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><ol><li><code>shop *shop = new class shop_(_shopId_)_;</code></li></ol><p><code>auto *ptr = new class shop_(_shop_)_;</code><br />如果只使用<code>shop *shop;</code>则在重新赋值的时候会出现错误</p><ol start="2"><li>容器中最好存储指针，否则也会出现一些错误，使用指针在进行函数的调用和参数的传递时是比较方便的。</li></ol><h3 id="11-自定义函数比较"><a href="#11-自定义函数比较" class="headerlink" title="11. 自定义函数比较"></a>11. 自定义函数比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;movie*&gt; movieRented;</span><br><span class="line">std::<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;movieRented.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;movieRented.<span class="built_in">end</span>(), compMovie);</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compMovie</span><span class="params">(<span class="type">const</span> movie *mov1, <span class="type">const</span> movie *mov2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mov1-&gt;price == mov2-&gt;price) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mov1-&gt;shopId == mov2-&gt;shopId) &#123;</span><br><span class="line">            <span class="comment">// * 5.如果仍然相同，则 moviej 较小 的排在前面</span></span><br><span class="line">            <span class="keyword">return</span> mov1-&gt;movieId &lt; mov2-&gt;movieId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// * 4.如果价格相同，则 shopj 较小 的排在前面</span></span><br><span class="line">        <span class="keyword">return</span> mov1-&gt;shopId &lt; mov2-&gt;shopId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// * 3.res 中的电影需要按 价格 升序排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mov1-&gt;price &lt; mov2-&gt;price;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; target;</span><br><span class="line">std::<span class="built_in">sort</span>(target.<span class="built_in">begin</span>(), target.<span class="built_in">end</span>(), compShop);</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compShop</span><span class="params">(vector&lt;<span class="type">int</span>&gt; x, vector&lt;<span class="type">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x[<span class="number">1</span>] == y[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// * 2.商店需要按照 价格 升序排序</span></span><br><span class="line"><span class="comment">// * 3.如果价格相同，则 shopi 较小 的商店排在前面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-子串的寻找"><a href="#12-子串的寻找" class="headerlink" title="12. 子串的寻找"></a>12. 子串的寻找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s1 &gt;&gt; s2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() &gt;= s2.<span class="built_in">size</span>())</span><br><span class="line">            cout &lt;&lt; (s1.<span class="built_in">find</span>(s2) != string::npos) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; (s2.<span class="built_in">find</span>(s1) != string::npos) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-得到子串"><a href="#13-得到子串" class="headerlink" title="13. 得到子串"></a>13. 得到子串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1.<span class="built_in">substr</span>(index, num)</span><br><span class="line"><span class="comment">// 从字符串str1的index索引位置开始获取num个字符；</span></span><br><span class="line">str1.<span class="built_in">substr</span>(index)</span><br><span class="line"><span class="comment">// 从字符串str1的index索引位置开始获取，一直获取到末尾的字符；</span></span><br></pre></td></tr></table></figure><h3 id="14-字符串大小写转换"><a href="#14-字符串大小写转换" class="headerlink" title="14. 字符串大小写转换"></a>14. 字符串大小写转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-字符串替换"><a href="#15-字符串替换" class="headerlink" title="15. 字符串替换"></a>15. 字符串替换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//将当前字符串</span></span><br><span class="line"></span><br><span class="line">从pos索引开始的n个字符，替换成字符串s</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">size_t</span> n1, <span class="type">char</span> c)</span></span>; <span class="comment">//将当前字符串从pos索引开始的n个字符，替换成n1个字符c</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="function">string&amp; <span class="title">replace</span><span class="params">(iterator i1, iterator i2, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;<span class="comment">//将当前字符串[i1,i2)区间中的字符串替换为字符串s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello,world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s1.<span class="built_in">size</span>()&lt;&lt;endl;                     <span class="comment">// 结果：12</span></span><br><span class="line">    s1.<span class="built_in">replace</span>(s1.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);           <span class="comment">// 结果：hello,world.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的6表示下标  5表示长度</span></span><br><span class="line">    s1.<span class="built_in">replace</span>(<span class="number">6</span>,<span class="number">5</span>,<span class="string">&quot;girl&quot;</span>);                    <span class="comment">// 结果：hello,girl.</span></span><br><span class="line">    <span class="comment">// s1.begin(),s1.begin()+5 是左闭右开区间</span></span><br><span class="line">    s1.<span class="built_in">replace</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">begin</span>()+<span class="number">5</span>,<span class="string">&quot;boy&quot;</span>); <span class="comment">// 结果：boy,girl.</span></span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-字符串的构造函数"><a href="#16-字符串的构造函数" class="headerlink" title="16. 字符串的构造函数"></a>16. 字符串的构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">string str：生成空字符串</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str)</span>：生成字符串为str的复制品</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, strbegin,strlen)</span>：将字符串str中从下标strbegin开始、长度为strlen的部分作为字符串初值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(cstr, char_len)</span>：以C_string类型cstr的前char_len个字符串作为字符串s的初值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(num ,c)</span>：生成num个c字符的字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, stridx)</span>：将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">eg:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    string str1;</span>               <span class="comment">//生成空字符串</span></span><br><span class="line">    <span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;  <span class="comment">//生成&quot;1234456789&quot;的复制品</span></span><br><span class="line">    <span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;<span class="comment">//结果为&quot;123&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;012345&quot;</span>, <span class="number">5</span>)</span></span>;  <span class="comment">//结果为&quot;01234&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>;       <span class="comment">//结果为&quot;11111&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;      <span class="comment">//结果为&quot;3456789&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="built_in">size</span>()和<span class="built_in">length</span>()：返回string对象的字符个数，他们执行效果相同。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="built_in">max_size</span>()：返回string对象最多包含的字符数，超出会抛出length_error异常</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="built_in">capacity</span>()：重新分配内存之前，string对象能包含的最大字符数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="17-数字与字符串的相互转换"><a href="#17-数字与字符串的相互转换" class="headerlink" title="17. 数字与字符串的相互转换"></a>17. 数字与字符串的相互转换</h3><h4 id="数字to字符串"><a href="#数字to字符串" class="headerlink" title="数字to字符串"></a>数字to字符串</h4><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    string str;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    ss &lt;&lt; x;</span><br><span class="line">    ss &gt;&gt; str;</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 浮点数会附带小数点后六位，不足补零，不推荐浮点数使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    str = <span class="built_in">to_string</span>(x);</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符串to数字"><a href="#字符串to数字" class="headerlink" title="字符串to数字"></a>字符串to数字</h4><h5 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用&lt;string&gt;中的stoi()函数，其中还有对于其他类型的函数，如stod()，stof()等，根据类型选取</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    x = <span class="built_in">stoi</span>(str);</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    string str;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    ss &lt;&lt; str;</span><br><span class="line">    ss &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="18-溢出"><a href="#18-溢出" class="headerlink" title="18. 溢出"></a>18. 溢出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">long</span> <span class="type">long</span> right = <span class="built_in">min</span>(a,b)*(<span class="type">long</span> <span class="type">long</span> )n;</span><br><span class="line"><span class="comment">/// 如果不对n进行强制类型转换，那么溢出。</span></span><br><span class="line"><span class="comment">// 虽然right已经定义了long long，但是在乘法计算时就已经溢出了</span></span><br></pre></td></tr></table></figure><h3 id="19-map遍历"><a href="#19-map遍历" class="headerlink" title="19. map遍历"></a>19. map遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;_map;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">while</span>(iter!=_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; iter-&gt;second&lt;&lt;endl;</span><br><span class="line">    iter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(iter = _map.<span class="built_in">begin</span>(); iter != _map.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于数组和指针的分析</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="Array-type-is-not-assignable"><a href="#Array-type-is-not-assignable" class="headerlink" title="Array type is not assignable"></a>Array type is not assignable</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">  str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, str[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: array type <span class="string">&#x27;char [4]&#x27;</span> is <span class="keyword">not</span> assignable</span><br></pre></td></tr></table></figure><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">4</span>] = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>在变量初始化时，就进行赋值。在长度为4的char数组中，’a’放进str[0]，’b’放进str[1]，’c’放进str[2]，’\0’放进str[3]分别放入a b c 元素</p><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str;</span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>这是声明一个<strong>char型指针变量 str，</strong>然后创建一个字符串常量”abc”，然后char指针 str 指向这个常量的内存，其实你可以试试，你可以<strong>通过str输出这个字符串（可以读），但是不能更改它（不能写）</strong>。因此在C++11里，对类型加了更强的定义，<strong>即指针指向的内容如果不可修改，就建议把该指针确认为const指针类型；</strong>如果不加const标志符，就提示一个警告。</p><h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>这种是有语法错误的，先声明一个char数组str[4]，这时候str[4]有一块内存，而<strong>str作为数组名，相当于一个指针常量</strong>，固定指向str[4]这个数组的第一个元素的地址。<br />而你使用str&#x3D;”abc”，相当于想要给一个指针常量赋值，所以显然是有语法错误的。想想你对一个常量赋值，当然会有错误！！</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>数组名只是代表数组第一个元素的地址的值</strong>，比如数组 int a[10]，a实际上就是 &amp;a[0]，它只是一个值，就像 5 这类东西一样，<strong>是不能作为左值的，不能给它赋值。</strong><br />所谓<strong>指针只是一种保存地址的变量，单独用数组名的时候它只是数组第一个元素的地址的值，<br />并不是保存第一个元素地址的变量</strong>。<br />所以在任何时候都不能把数组名直接放在等号的左边，这个问题跟字符串什么的并没有什么关系。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="字符串常量修改与赋值"><a href="#字符串常量修改与赋值" class="headerlink" title="字符串常量修改与赋值"></a>字符串常量修改与赋值</h3><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>数组c的声明，是将<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>常量“复制”到数组中，复制来的字符串是可以修改的</li><li>指针p的声明，指向的是字符串常量的地址，而常量只读不可修改</li><li>关键：如果直接赋值字符串（<strong>实际上是赋值地址</strong>）时，<strong>会在字符串常量区开辟对应内存存放字符串</strong>，如果赋值给指针p，那么p中的内容就不可修改。因为p是指向常量区的，而<strong>常量区中的内容是不可修改的</strong>。如果是动态分配，在赋值字符串，同理；但是如果使用<code>strcpy</code>，那么就相当于再堆内存中写入对应的<strong>字符串内容，而非直接赋值地址</strong>，那么此时p指向的内容就可以修改。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p, *m;</span><br><span class="line">p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">m = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">p = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* q=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> c[<span class="number">30</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">p[<span class="number">2</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">puts</span>(p);</span><br></pre></td></tr></table></figure></li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>指针p的存储地址为 0x004FFD5C<br />指针q的存储地址为 0x004FFD44<br />你会发现他们地址几乎都在一起，因为他们存储的地方是栈内存<br />要知道<code>p = &quot;hello&quot;</code>;意思是将字符串<code>&quot;hello&quot;</code>的地址存储到p内<br />而p内存储字符串的地址为 0x00667B30<br />q内存储的字符串的地址为 0x00667B30<br />你会发现存储的地址是一样的，说明字符串<code>&quot;hello&quot;</code>的地址放在一个地方，也就是我们说的<strong>字符串常量区，字符串常量区内的元素，只读不可修改</strong>。<br />你们会问，为什么p内的地址为字符串常量的地址呢？<br />首先，<strong>指针p申请动态内存后，p内存储的是申请的内存的起始地址，而之后，p又存储字符串“hello”的地址，所以，最后p内存储的地址为字符串常量“hello”的地址。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span>* p, *m;</span><br><span class="line">p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">m = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//p = &quot;hello&quot;;</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">char</span>* q=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> c[<span class="number">30</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">p[<span class="number">2</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">puts</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家又会问：为什么用<code>strcpy(p, &quot;hello&quot;);</code><br />因为<strong>字符串被复制到堆内存中，而不是访问字符串常量区</strong><br /><strong>指针p首先动态申请内存，这时，指针p的值是申请的内存起始地址，所以strcpy是将字符串复制到申请的内存当中。</strong>所以使用strcpy后，p中的内容是可以修改的。</p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OJ 使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/OJ%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/OJ%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="答案不一致"><a href="#答案不一致" class="headerlink" title="答案不一致"></a>答案不一致</h4><p>如果出现本地IDE和OJ上输入相同，输出不同的情况，考虑是否为系统不一致的情况：</p><ol><li>是否为IO的处理不同。当输入整数后，为了吸收换行符，建议统一使用<code>**cin &gt;&gt; ws**</code> 进行处理</li><li>如果排除掉IO的情况后，可以考虑结束符号的不同。例如，在Windows中，char数组的结束符号为<code>**&#39;\0&#39;**</code>；而在我调试代码时，发现在OJ上，结束符号为<code>**&#39;\r&#39; **</code>。因此需要特别小心</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第五课 数组与指针</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%BA%94%E8%AF%BE%20%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%BA%94%E8%AF%BE%20%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.yuque.com/austyn-c3emm/yxffx0/ob20zu">关于数组和指针的分析</a></p><blockquote><p>指明了类型，就指明了操作</p></blockquote><p>特征：</p><ul><li>相同类型</li><li>连续存储</li></ul><p>可以按下标访问，也可以按地址访问。<strong>C++是基于实现的</strong><br />C++中的二维数组是复合类型，没有Array。<br />数据类型决定范围和取值方式，<strong>什么样的类型定义了什么样的访问方式</strong><br /><code>int len = sizeof(arr)/sizeof(arr[0])</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">f</span>(a)  <span class="comment">//在参数传递时，发生了变化，变成了表达式，由一个数组变成了相关的指针</span></span><br><span class="line"><span class="comment">// a是数组类型，只不过进行了隐式类型转换</span></span><br><span class="line">    <span class="comment">// 所有的指针的sizeof(*p) 都是一样的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(a[<span class="number">0</span>]);i++)&#123;</span><br><span class="line">        <span class="comment">// 所以此时不能输出a中的每一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 因此，元素个数需要通过参数显式给出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++是允许数组下标越界的，因为越界是<strong>有用的</strong>前提是空间是合理的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(<span class="type">char</span>[] a )</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (a[i+ <span class="number">1</span>] !=<span class="string">&#x27;/0&#x27;</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665470118492-ef584ee7-e92f-400c-966e-4a0dfbbc1e76.png" alt="image.png">** <strong><br />所以</strong>输出s2时，会一直输出下去**，直到刚好碰到<code>&#39;\0&#39;</code><br />没有初始化的空间全部默认为 0xcc，代表中文的烫<br />利用malloc时不初始化，空间会默认为0xcd，代表中文的屯。【debug版本中打开&#x2F;GZ开关，方便找到潜在的错误 &#x3D; 》现在使用&#x2F;RTC1】<br />C++中的变量是不会自己初始化的<br />mallopt指定自己配置的空间是什么【写在代码中的】<br />valgrind设置栈、堆里面的填充【不修改代码】</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针必须初始化，防止调用垃圾地址并修改了其中的内容<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665470614133-7c6a4d2b-0068-4eb5-ae6a-7e2d2c25c935.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665470621676-09712e81-2dda-48c5-b4ba-919448538fb2.png" alt="image.png"></p><h3 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h3><p><code>void *v</code> 则 <code>*v</code>是不被运行的。所以<code>**v**</code><strong>可以作为任何类型指针的公共接口，只具有记录地址的作用，是可以被信任的。任何指针都可以赋值给</strong><code>**void ***</code><strong>，但void * 不能赋值给其他指针</strong><br />清零<br />int a[100]  全部赋值为0</p><ol><li><code>for</code>循环</li><li><code>memset函数(起始地址，大小)</code> 则起始地址必须为<code>**void ***</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">memset</span><span class="params">(<span class="type">void</span> *p,<span class="type">int</span>  n)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *q = (<span class="type">char</span> *)p; <span class="comment">// 进行强制类型转换为char *，一个一个字节的删除即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    *(q+i) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665471919019-8d7f5fe9-3fe5-40e7-874b-6e48c8a30770.png" alt="image.png"><br><strong>a 是一个常量指针，数组名是常量指针</strong></p><ol><li><strong>通过数组下标访问</strong></li><li><strong>通过指针访问</strong></li><li><strong>通过数组名访问</strong></li></ol><p>动态数组<br /><code>int *p =(int*) malloc (……)</code></p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>通过一维数组不断复合，依然是一段连续的数据。<br />参数传递：缺少第一维，因为对应的就是<strong>指针</strong>，指向后面的维度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>]; <span class="comment">// </span></span><br><span class="line"><span class="keyword">using</span> T = <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] &lt;=&gt; T a[<span class="number">3</span>]; 相当于额外定义了基类型</span><br></pre></td></tr></table></figure><p>升维操作：动态多维数组需要借助一维数组来实现，利用升维操作 </p><h4 id="降维操作p-i"><a href="#降维操作p-i" class="headerlink" title="降维操作p[i]"></a>降维操作<code>p[i]</code></h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665581024915-f41d6b67-1dab-441b-844b-52c88e4c310b.png" alt="image.png"></p><h4 id="降维操作q-i-j"><a href="#降维操作q-i-j" class="headerlink" title="降维操作q[i][j]"></a>降维操作<code>q[i][j]</code></h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665581379222-762137c7-14c5-486f-b348-21e20686a00a.png" alt="image.png"><br>为了能通过<code>q[i][j]</code>的形式表示，则需要<code>q</code>指针指向的是一个小方块，而不是一个具体从存储单元。在这个小方块中，包含若干个的最小存储单元，从而通过<code>j</code>这一坐标找到最小的存储单元<br /><code>**p+11**</code><strong>其实是越界了，方便用数组的形式访问多维数组</strong></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665581592478-98bde056-546e-4210-a1db-9b9f172eb4da.png" alt="image.png"></p><h3 id="数组升维降维"><a href="#数组升维降维" class="headerlink" title="数组升维降维"></a>数组升维降维</h3><h4 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665473312121-9afd89d3-dc73-4752-a275-03d745a1eece.png" alt="image.png"></p><h4 id="升维"><a href="#升维" class="headerlink" title="升维"></a>升维</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665473730499-f85ba331-6cbb-4a7f-bef5-34ec0b9b8c30.png" alt="image.png"></p><h4 id="ragged-array"><a href="#ragged-array" class="headerlink" title="ragged array"></a>ragged array</h4><p>java 中的二维数组不是规整的，可能是锯齿状的，不对等的<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665472501018-b591c0b0-b173-4784-90f8-bedc5fdba0cf.png" alt="image.png"></p><h3 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = mall</span><br></pre></td></tr></table></figure><p>在使用new时，会<strong>逐个调用constructor</strong>，从而实现强制类型转换。OO使得数据进入时能进行部分操作<br />new malloc 和inline一样，可能会申请不成功，所以需要<strong>有效性判定</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665474543745-69965375-c6bd-413e-976a-18b57777cde8.png" alt="image.png"></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li>可以预见：new可能会失败</li><li>无法避免</li></ol><p>可以由系统处理，也可以自定义处理。为了allocate成功，可以自己选择释放一些特定内存，要么停掉，要么交给系统处理，要么自主修改环境</p><h3 id="归还"><a href="#归还" class="headerlink" title="归还"></a>归还</h3><p>防止内存泄漏</p><ul><li>操作符 <code>new</code>、<code>delete</code></li><li>函数 <code>malloc</code>、<code>free</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  *p1  =<span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">8</span>);</span><br><span class="line"><span class="type">int</span>  *p2 = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span>  *q  = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span>  *q2 = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">8</span>);</span><br></pre></td></tr></table></figure>int *q &#x3D; new int[8]<br />delete q 只调用一个析构函数<br />delete [] q  逐个调用析构函数<br />free(q) <br />如何知道有8个？</li></ul><ol><li>符号表：耗时+会导致表的大小未定，空间不确定</li><li>用空间换取时间：在分配内存时，额外用一个空间<code>**cookie**</code>，<code>cookie</code>中存储块的大小</li></ol><p>申请的指针不要随意改变，否则容易归还失败。因此使用时要用<code>int *p1 = p;</code> </p><h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><p>compiler会自动调用<code>destructor</code>，确保对象被释放。生命周期结束的时候会自动调用delete，利用析构函数的自动调用防止内存泄漏，确保资源的初始化。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074024946-ffa46879-1310-4887-b37d-4909916b340a.png" alt="image.png"><br>unique_ptr shared _ptr  解决资源共享或者独享问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span>  i;</span><br><span class="line">    <span class="type">int</span>  *p;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="built_in">A</span>()&#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A a;<br />A b &#x3D;a;<br />会导致悬挂指针<code>idle point</code>，a 和 b 的生命周期结束不一致。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Sturct"><a href="#Sturct" class="headerlink" title="Sturct"></a>Sturct</h3><p>定义数据的顺序会影响到内存的占用，<strong>会数据对齐</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074365737-1888f32f-4ded-4835-bdcb-21ff0757e473.png" alt="image.png"></p><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074423419-fb8927df-deaa-42b3-b5ae-2604197c1924.png" alt="image.png"><br><strong>B的存储空间是最大占有的内存</strong>，所有的域代表一个公共的空间，<strong>里面的内容共享一块存储空间</strong>。<br />对于<code>struct</code>，</p><h4 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h4><p>表示方法1：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074582185-d728c632-d5ba-4306-ac70-9ac07edefba7.png" alt="image.png"><br>表示方法2：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074654444-cd439362-d28e-4643-a723-db033c24cc2d.png" alt="image.png"><br>两种访问方式：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074727649-7e1b8cd2-af2f-4f95-917d-a453a7bc54c5.png" alt="image.png"></p><h4 id="数组-—-多态性"><a href="#数组-—-多态性" class="headerlink" title="数组 — 多态性"></a>数组 — 多态性</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666075224937-9b6c1cc8-bcb7-47f6-b725-39a5908b45f3.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666075202245-1d61c00f-e253-41a1-b4cf-f65e5e719670.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第六课 指针</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%85%AD%E8%AF%BE%20%E6%8C%87%E9%92%88/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%85%AD%E8%AF%BE%20%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>作用：</p><ol><li>管理地址信息</li><li>读写信息</li><li>调用代码</li></ol><h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>指向常量的指针</p><ol><li>常量指针可以指向变量：从而消除函数副作用<strong>只有读的能力，没有写的能力</strong>。既保护了数据，也提高了效率</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666075777093-1be322c6-8b15-4de7-8581-bdbd851e85eb.png" alt="image.png"></p><ol start="2"><li>变量指针不可以指向常量：因为担心变量指针改变常量</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666075677750-f2f8eac3-f8fe-4a2a-a24e-37e0dd786bda.png" alt="image.png">提供一个权利，相信变量指针不会改变常量<br /><strong>Use const whenever possible</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666076607331-77fe9ca5-7db6-42b8-af95-1e1d6adc6499.png" alt="image.png"><br>会把const变量转换为字面常量。所以c直接代替为128</p><h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666076675033-8b943735-7813-49fd-a483-382662982f12.png" alt="image.png"></p><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666076762509-b550ee49-3eae-45fc-9ff2-f6db42de3935.png" alt="image.png"></p><p>异步程序的调用 – 通过主程序的返回值确定<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666077003993-4a6a14e3-b5d3-490d-ac78-e57ab4b65886.png" alt="image.png"></p><h3 id="指针与结构"><a href="#指针与结构" class="headerlink" title="指针与结构"></a>指针与结构</h3><p><strong>class不写访问控制，对应的是private；struct默认的是public</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666077598289-ae50a974-adfc-4e7b-8562-a5b88cc271f9.png" alt="image.png"></p><h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><h4 id="指针作为行参"><a href="#指针作为行参" class="headerlink" title="指针作为行参"></a>指针作为行参</h4><ul><li>提高传输效率</li><li>函数副作用</li><li>常量指针</li></ul><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>作用：</p><ol><li>写框架，实现剥离</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666079041998-07398089-77d2-4d40-8acb-da84230a4cf3.png" alt="image.png"></p><ol start="2"><li>泛型</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666078881715-246db21d-3096-4f77-91a4-8d180b80d648.png" alt="image.png"><br><code>callback() function</code><br />改善：</p><ul><li>用<code>template</code></li><li>用<code>lambda function</code></li></ul><h3 id="多级指针？？"><a href="#多级指针？？" class="headerlink" title="多级指针？？"></a>多级指针？？</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666079167053-b70934ad-5d35-42ca-b080-be39cc5d29cf.png" alt="image.png"></p><h3 id="引用？？"><a href="#引用？？" class="headerlink" title="引用？？"></a>引用？？</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666079216734-616c94d5-1c7a-49e9-8f17-18cc6ba0ee54.png" alt="image.png"></p><ol><li>不能返回局部变量、全局变量，只能返回调用者有关的</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机考</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E6%9C%BA%E8%80%83/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E6%9C%BA%E8%80%83/</url>
      
        <content type="html"><![CDATA[<ol><li>小心使用指针</li></ol><p>如果直接传入字符串，则选择接收的是其内容，而不要用指针的方式接收，因为传入参数后，该地址就被自动释放，并被后面的字符串常量覆盖，造成错误。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666679605225-6050dc2e-8714-48f8-839b-0f7a2684eb73.png" alt="image.png"></p><ol start="2"><li>要放轻松，尽力就好，重点还是在笔试</li><li><strong>一定要看清题意，最好将对应的步骤描述复制到对应的函数中去</strong></li><li>在面对长段文字时，首先要从最简单的几个入手，获得一定的分数，再去做更复杂的题目</li><li>如果发现能对几个，但是对的不多，且不是算法题目，那么就要<strong>多考虑细节</strong>，要<strong>重新回到题干上进行分析</strong></li><li><strong>按照步骤读题干，同时关注已给出的加粗&#x2F;标红部分</strong></li><li><strong>多造用例，抓捕一些脑海中一闪而过的可能的错误用例，不要小看每一个特殊用例，不要觉得这个肯定不会涉及，如果有想到的，就一定要去修复，可能会有额外收获</strong></li><li>注意输出的格式是否正确。有时思路没问题，但是<strong>输出格式有误</strong>，例如：<strong>大小写输出、空格数量输出</strong>等情况</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七课 OOP</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20OOP/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20OOP/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u014391177/article/details/82228662">C++拷贝构造函数、构造函数和析构函数</a></p><ol><li>encapsulation<ol><li>减少类之间的耦合</li><li>类内部的结构可以自由的进行修改</li><li>对成员进行控制</li><li>对代码的理解性更好</li></ol></li><li>information hidding：不需要知道如何初始化，只需要使用提供的接口</li><li>Cfront 第一个C++的编译器，转为C</li></ol><ul><li>基于对象：没有继承</li><li>面向对象：封装、继承、多态</li></ul><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>开发效率、软件外部质量、软件内部质量都得到明显提升</p><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul><li>成员变量</li><li>成员函数</li><li>头文件、源文件：C++是一个个编译单元进行编译，所以需要提前知道其他编译单元的相关信息（存储在头文件中），只需要知道声明，不需要知道具体定义，减少编译复杂度</li></ul><p>将方法放在头文件中时，会将该方法当作<code>inline</code>函数。<br />主调函数运行时，如果有其他函数，会先运行其他函数，在返回主调函数。如果其他函数很短，则会在调用上消耗太多时间，所以需要变为<strong>内联函数–直接用函数体代替函数调用，代码展开，提高性能。</strong>但是，如果函数体很大时，会把代码变得很长。所以，<strong>一般的</strong><code>**set**</code>**函数 **<code>**get**</code><strong>函数、代码十行之内、没有</strong><code>**for**</code><strong>循环、没有</strong><code>**switch**</code><strong>语句声明成内联函数</strong></p><hr><p>为了优化编译，使用其他编译单元时，先不引入进来，而是在链接过程中，保证有定义即可。所以需要<strong>先声明，再使用</strong>，告诉本编译单元，该函数是合法的，所以需要<strong>头文件</strong>。</p><ol><li>本地单元进行编译时，头文件和源文件是一致的，肯定是合法的，减少了编译时的依赖关系，只需要和头文件建立依赖关系就可以了。</li><li>减少编译时引入的内容</li><li>把定义和声明放入一块，是为了支持<code>inline</code>：<strong>直接替换函数调用</strong>。如果头文件中没有具体声明，则无法使用<code>inline</code>。所以，<code>inline</code>要求<strong>头文件中必须要有声明</strong></li><li><strong>所以</strong><code>**inline**</code><strong>过多，会使编译单元过于庞大，不适合写在头文件中，而是写在源文件中</strong></li></ol><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>如果提供了有参构造函数，则编译系统不再提供默认构造函数</li><li>当类中未提供构造函数时，由编译系统提供</li><li>如果没有指定c++默认初始化，则各种变量都会有<strong>不确定的值</strong></li><li>成员变量如果是成员对象，则总是会初始化的，需要为成员对象设置构造函数</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666852754296-ad99d7fb-af8e-4267-88d6-ec874ca6cfbb.png" alt="image.png"></p><ul><li>全局变量和静态变量，未初始化，默认为0</li><li>局部变量、成员变量，未初始化，默认为不确定的值</li><li>编译系统提供的默认构造函数不会对成员变量进行处理，主要功能是<strong>完成对象的初始化，创建标识符，开辟内存空间</strong>，最后再根据传入的参数或者默认值进行对数据的处理。</li><li>构造函数可定义为<code>private</code>，避免在其他代码中创建该对象，所以<strong>只能通过类内部的方法进行创建</strong>，而类内部的方法是我自己写的，因此<strong>可以接管对象的创建</strong>，例如保证单例，或者保证只有十个对象创建</li></ul><h5 id="数组构造"><a href="#数组构造" class="headerlink" title="数组构造"></a>数组构造</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666853395899-ddd69b85-d7cd-4245-98cb-f1348a7c37f2.png" alt="image.png"></p><h4 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h4><p>在冒号和花括号之间的代码部分称为构造函数的初始值列表，<strong>它的作用是给创建的对象的某些成员赋初值</strong>。这种是在构建对象的时候的初始化，是在对象创建成功之前完成的，和在函数体内赋值是不一样的，<strong>函数体内赋值是你的对象成员都已经创建好后对成员进行的赋值。</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666854123003-fdd90dc6-e5eb-48e5-89e6-da3c44f41345.png" alt="image.png"></p><ol><li><code>static const</code>类的常量</li><li>引用类型必须初始化，不能重新赋值</li><li><strong>构造函数内赋值，实际上是先初始化为默认值，再赋值，相当于两次赋值</strong></li><li>如果使用初始化表，则是在初始化的同时进行赋值，效率更高</li><li>声明处进行初始化最为方便</li><li>在构造函数内进行赋值，成员变量已经初始化了，这次是<strong>二次赋值</strong>，效率上更低</li></ol><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> t) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hour = t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1990</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">    : _year(year), _month(month), _day(day), <span class="built_in">t</span>(<span class="number">10</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year = <span class="number">1990</span>;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">    Time t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>对于<code>const</code>和引用类型，必须要进行初始化，所以他们<strong>必须在初始化列表中进行初始化</strong>。</li><li>当类类型成员有缺省（默认）的构造函数时，在创建对象的时候系统会默认调用，因为不用传参。当你的构造函数不是缺省的，如果不在初始化列表中进行调用构造函数，系统就无法知道怎么调用t的构造函数，那么就无法创建t了。</li></ol><p>如上代码中，需要在参数列表中调用t的构造函数才不会出错</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666854897871-99657b81-0c7f-48ef-a2e0-e0176f35ddaa.png" alt="image.png"><br>数据太多，可以在声明的同时进行初始化。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li>在上面的初始列表中，每个成员只能出现一次，因为一个变量多次初始化是无意义的。</li><li>初始化列表的顺序并不限定初始化的执行顺序。<strong>成员的初始化顺序是与类中定义的顺序保持一致。</strong>最好让构造函数初始值的顺序与成员声明的顺序保持一致。</li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p><strong>程序员负责资源的申请和释放</strong><br />类的析构函数，它是类的一个成员函数，名字由波浪号加类名构成，是执行与构造函数相反的操作：释放对象使用的资源，并销毁非static成员。<br />同样的，我们来看看析构函数的几个特点：</p><ol><li>函数名是在类名前加上~，无参数且无返回值。</li><li>一个类只能有且有一个析构函数，如果没有显式的定义，系统会生成一个缺省的析构函数（合成析构函数）。</li><li>析构函数不能重载。<strong>每有一次构造函数的调用就会有一次析构函数的调用。</strong></li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666855022119-3cdc0f73-c223-45d6-96a5-bb88dfc0c1f7.png" alt="image.png"></p><ol><li>对象离开作用域</li><li>使用<code>delete</code>方法调用</li><li>作用：把对象在运行中获得的额外资源进行释放</li></ol><h4 id="声明为private"><a href="#声明为private" class="headerlink" title="声明为private"></a>声明为<code>private</code></h4><blockquote><ol><li>禁止用户对此类型的变量进行定义，即<strong>禁止在栈内存空间内创建此类型的对象。</strong>要创建对象，只能用 <code>new</code> 在堆上进行。 </li><li>禁止用户在程序中使用 <code>delete</code> 删除此类型对象。对象的删除只能在类内实现，也就是说只**有类的实现者才有可能实现对对象的 <strong><code>**delete**</code>，用户不能随便删除对象。</strong>如果用户想删除对象的话，只能按照类的实现者提供的方法进行 **</li><li>如果一个类不打算作为基类，通常采用的方案就是将其析构函数声明为<code>private</code>，限制栈对象，却不限制继承</li></ol></blockquote><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666855595621-be2da256-d2c5-4676-bf14-af1ad5626581.png" alt="image.png"><br>系统无法调用析构函数，因为是自动消亡的，内存分配在栈中，<strong>离开作用域就会自动消亡</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666855682941-ad51ba16-2810-465e-9b83-fadc93e2ef83.png" alt="image.png"><br><strong>通过将对象的析构函数定义为</strong><code>**private**</code><strong>，强制在堆上分配内存</strong>，场景：栈的内存有限，对象的内存很大。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666855753254-11b614b3-9ee7-4179-ae25-edecafd4b756.png" alt="image.png"><br>这种方法也能够将<code>p</code>指针重新定义为空指针，更好</p><h4 id="栈对象的生命"><a href="#栈对象的生命" class="headerlink" title="栈对象的生命"></a>栈对象的生命</h4><ol><li>会移动栈顶指针以“挪出”适当大小的空间</li><li>在这个空间上直接调用对应的构造函数以形成一个栈对象</li><li>当函数返回时，会调用其析构函数释放这个对象</li><li>调整栈顶指针收回那块栈内存。</li></ol><h4 id="GC-垃圾回收"><a href="#GC-垃圾回收" class="headerlink" title="GC 垃圾回收"></a>GC 垃圾回收</h4><ol><li>存在效率障碍，发生时间不确定</li><li>存在不能使用GC的场合</li><li>只能回收内存，不能回收文件操作的句柄等 <code>finalize</code></li><li>不能由程序员自己控制</li></ol><h4 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII  Resource Acquisition Is Initialization"></a>RAII  Resource Acquisition Is Initialization</h4><blockquote><p>资源获取就是初始化</p></blockquote><ol><li>什么时候获取什么时候释放都是确定的</li><li>对象获得的资源都是要在析构函数中释放的</li><li>栈上的内存资源自动释放，堆上的内存资源需要通过析构函数释放</li></ol><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li>一个对象<strong>以值传递的方式传入函数</strong></li><li>一个对象<strong>以值传递的方式从函数中返回</strong></li><li>一个对象<strong>需要通过另外一个对象进行初始化</strong></li></ol><ul><li>创建对象时，用一个同类的对象对其初始化</li><li>自动调用：<code>Test(Test &amp;c_t)是自定义的拷贝构造函数，**拷贝构造函数的名称必须与类名称一致**，函数的形式参数是**本类型的一个引用变量,且必须是引用**</code></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666856126500-f78dbc74-bfbc-495a-af46-8fb9045d3e4c.png" alt="image.png"></p><ol><li>使用引用：<strong>如果不写引用，则传参本身就会引发拷贝构造函数</strong>，导致递归</li><li>使用<code>const</code>：防止拷贝时值被修改</li><li>默认拷贝构造函数：<ol><li>逐个成员初始化</li><li>对于对象成员，该函数是递归的</li></ol></li></ol><p><strong>需要深拷贝时，要自己提供拷贝构造函数</strong></p><h4 id="浅拷贝-深拷贝"><a href="#浅拷贝-深拷贝" class="headerlink" title="浅拷贝 深拷贝"></a>浅拷贝 深拷贝</h4><ul><li>如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的位拷贝。位拷贝又称浅拷贝，后面将进行说明。</li><li>自定义拷贝构造函数是一种良好的编程风格，它可以阻止编译器形成默认的拷贝构造函数，提高源码效率。</li><li>浅拷贝：在某些状况下，类内成员变量需要动态开辟堆内存，如果实行浅拷贝，就是<strong>把对象里的值完全复制给另一个对象</strong></li></ul><p>深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，<strong>资源重新分配</strong>，这个过程就是<strong>深拷贝</strong>，反之，<strong>没有重新分配资源，就是浅拷贝。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CA</span></span><br><span class="line">&#123;</span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　<span class="built_in">CA</span>(<span class="type">int</span> b,<span class="type">char</span>* cstr)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　a=b;</span><br><span class="line">　　　str=<span class="keyword">new</span> <span class="type">char</span>[b];</span><br><span class="line">　　　<span class="built_in">strcpy</span>(str,cstr);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">CA</span>(<span class="type">const</span> CA&amp; C)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　a=C.a;</span><br><span class="line">　　　str=<span class="keyword">new</span> <span class="type">char</span>[a]; <span class="comment">//深拷贝</span></span><br><span class="line">　　　<span class="keyword">if</span>(str!=<span class="number">0</span>)</span><br><span class="line">　　　　<span class="built_in">strcpy</span>(str,C.str);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">　　&#125;</span><br><span class="line">　　~<span class="built_in">CA</span>()</span><br><span class="line">　　&#123;</span><br><span class="line">　　　<span class="keyword">delete</span> str;</span><br><span class="line">　　&#125;</span><br><span class="line">　<span class="keyword">private</span>:</span><br><span class="line">　　<span class="type">int</span> a;</span><br><span class="line">　　<span class="type">char</span> *str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="function">CA <span class="title">A</span><span class="params">(<span class="number">10</span>,<span class="string">&quot;Hello!&quot;</span>)</span></span>;</span><br><span class="line">　CA B=A;</span><br><span class="line">　B.<span class="built_in">Show</span>();</span><br><span class="line">　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="浅拷贝危害"><a href="#浅拷贝危害" class="headerlink" title="浅拷贝危害"></a>浅拷贝危害</h5><p>如A&#x3D;B。这时，如果<strong>B中有一个成员变量指针已经申请了内存</strong>，那A中的那个成员变<strong>量也指向同一块内存</strong>。这就出现了问题：当B把内存释放了（如：析构），这时<strong>A内的指针就是野指针了</strong>，出现运行错误。<br /><strong>浅拷贝资源后在释放资源的时候会产生资源归属不清的情况导致程序运行出错。</strong></p><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p><strong>程序员如果不会去做一件事，则编译器会接管，但如果程序员接管了，则编译器什么都不做</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666856786049-79893964-d3f9-48a0-8aa1-644089f67d07.png" alt="image.png"></p><h4 id="易错"><a href="#易错" class="headerlink" title="易错"></a>易错</h4><p><strong>显式地定义了析构函数的情况下，应该也把拷贝构造函数和赋值操作显式定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year=<span class="number">1990</span>,<span class="type">int</span> month=<span class="number">1</span>,<span class="type">int</span> day=<span class="number">1</span>)</span><br><span class="line">        : _year(year),_month(month),  _day(day)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Date</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year=<span class="number">1990</span>;  </span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员中有动态开辟的指针成员，在析构函数中对它进行了delete，如果不显式的定义拷贝构造函数，当你这样：Date d2（d1）来创建d2，我们都知道默认的拷贝构造函数是浅拷贝，那么这么做的结果就会是d2的成员p和d1的p是指向同一块空间的，那么<strong>调用析构函数的时候回导致用一块空间被释放两次</strong>，程序会崩溃的哦！</p><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p><code>A&amp;&amp;</code>右值引用<br />左值：赋值操作符左边的值。是可以赋值的，通常是一个变量<br />右值：赋值操作符右边的值。是一个值，通常是一个常数、表达式、函数调用</p><ul><li>不能把右值绑定在非<code>const</code>的引用上</li><li>临时变量在再次赋值时可能已经被销毁了</li><li>右值只能绑定在<strong>常量引用</strong>上 <code>const int ＆z = 5</code></li><li>右值通常不能修改</li><li>右值引用可以绑定在右值引用上</li></ul><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>使用<code>swap</code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667283981580-614f64e6-dbb8-4c2f-8ebb-b76bc6905b3e.png" alt="image.png"><br>缺点：总是需要不断拷贝</p><ul><li>移动构造：<strong>把移动完的指针置为</strong><code>**Null**</code><strong>，防止二次释放</strong></li><li>右值绑定在右值引用上时，则<strong>右值可以修改了</strong>，因为获得了其对应的内存</li><li><strong>右值引用是为了提高效率</strong></li><li>没有定义拷贝构造、拷贝赋值、析构函数，则会提供移动构造函数：移动构造是为了降低拷贝的消耗，一旦定义了拷贝构造，则编译器不再提供默认</li><li>定义了析构函数，是对申请资源进行释放，额外的资源需要如何拷贝、如何移动，编译器不知道，所以不会提供移动构造</li></ul><h3 id="类型的匹配顺序"><a href="#类型的匹配顺序" class="headerlink" title="类型的匹配顺序"></a>类型的匹配顺序</h3><p>优先级：<strong>不需要进行数据转换的优先</strong></p><ol><li>如果既有移动构造又有拷贝构造：<ol><li>普通变量：调用拷贝</li><li>右值（临时变量）：调用移动</li></ol></li><li>临时变量的值不能绑定到左值上</li><li>临时变量+<code>const</code>，可以绑定到</li><li>拷贝</li></ol><h2 id="五三原则"><a href="#五三原则" class="headerlink" title="五三原则"></a>五三原则</h2><p><strong>在c++ 中，当我们定义一个类时，我们显式或隐式地定义了此类型的对象在拷贝、赋值和销毁时做什么？</strong><br />一个类通过定义三种特殊成员成员函数来控制这些操作：拷贝构造函数、拷贝赋值函数、析构函数。<br />什么是三法则<br />C++三法则：如果需要析构函数，则一定需要拷贝构造函数和拷贝赋值操作符。<br />如何理解这句话，通常，若一个类需要析构函数，则代表其合成的析构函数不足以释放类所拥有的资源，其中最典型的就是指针成员。<br />所以，我们需要自己写析构函数来释放给指针所分配的内存来防止内存泄露。<br />那么为什么说“一定需要拷贝构造函数和赋值操作符”呢？<br />原因还是这样：类中出现了指针类型的成员。有指针类型的成员，我们必须防止浅拷贝问题，所以，一定需要拷贝构造函数和赋值操作符，这两个函数是防止浅拷贝问题所必须的。<br />什么是五法则<br />在较新的 C++11 标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“C++五法则”；<br />也就是说，“三法则”是针对较旧的 C++89 标准说的，“五法则”是针对较新的 C++11 标准说的；为了统一称呼，后来人们干把它叫做“C++ 三&#x2F;五法则”；<br /><strong>因此，如果自定义了拷贝构造函数&#x2F;拷贝赋值&#x2F;析构函数，则不会提供默认的移动构造函数&#x2F;移动赋值函数</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引用、取地址符、指针</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E3%80%81%E6%8C%87%E9%92%88/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E3%80%81%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>n 是m的一个引用（reference），m 是被引用物（referent）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> &amp;n = m;</span><br></pre></td></tr></table></figure><p><strong>n 相当于 m 的别名</strong>（绰号），<strong>对 n 的任何操作就是对m的操作</strong>。<br />所以 n 既不是m的拷贝，也不是指向 m 的指针，其实<strong>n就是 m 它自己</strong>。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol><li>引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）</li><li>不能有NULL引用，引用必须与合法的存储单元相关联（指针则可以是NULL）</li><li>一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）</li></ol><h3 id="取地址符"><a href="#取地址符" class="headerlink" title="取地址符"></a>取地址符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> &amp;y = x;</span><br><span class="line"><span class="type">int</span> *p = &amp;x;</span><br><span class="line">cout &lt;&lt; y &lt;&lt; endl; <span class="comment">// 100</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl; <span class="comment">// 0x7ffe4c99cdfc</span></span><br><span class="line">cout &lt;&lt; &amp;y &lt;&lt; endl; <span class="comment">// 0x7ffe4c99cdfc</span></span><br></pre></td></tr></table></figure><ul><li><strong>&amp;(引用)</strong>&#x3D;&#x3D;&gt;用来传值，出现在变量声明语句中<strong>位于变量左边时,表示声明的是引用。</strong></li><li><strong>&amp;(取地址运算符)</strong>&#x3D;&#x3D;&gt;用来获取首地址，在给变量赋初值时<strong>出现在等号右边</strong>或在<strong>执行语句中作为一元运算符</strong>出现时表示<strong>取对象的地址</strong>。</li></ul><h4 id="和引用的区别"><a href="#和引用的区别" class="headerlink" title="和引用的区别"></a>和引用的区别</h4><h4 id="实例如下：1）引用在赋值-x3D-的左边，而取地址在赋值的右边，比如"><a href="#实例如下：1）引用在赋值-x3D-的左边，而取地址在赋值的右边，比如" class="headerlink" title="实例如下：1）引用在赋值&#x3D;的左边，而取地址在赋值的右边，比如"></a>实例如下：1）引用在赋值&#x3D;的左边，而取地址在赋值的右边，比如</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>；</span><br><span class="line"><span class="type">int</span> &amp;b=a；        <span class="comment">//引用</span></span><br><span class="line"><span class="type">int</span> *p=&amp;a;        <span class="comment">//取地址</span></span><br></pre></td></tr></table></figure><p>  2）和类型在一起的是引用，和变量在一起的是取址。 举例同样如上，还有下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;  <span class="comment">//引用</span></span><br></pre></td></tr></table></figure><p>3）对于vector，上面2条同样适合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;  <span class="comment">//initialize vec1: 10 elements, every element&#x27;s value is 1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; &amp;vec2 = vec1; <span class="comment">// vec2 is  reference to vec1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; *vec3 = &amp;vec2; <span class="comment">//vec3 is addresss of vec1 and vec2</span></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="每一种编程语言都使用指针。C-将指针暴露给了用户-程序员-，而Java和C-等语言则将指针隐藏起来了。"><a href="#每一种编程语言都使用指针。C-将指针暴露给了用户-程序员-，而Java和C-等语言则将指针隐藏起来了。" class="headerlink" title="每一种编程语言都使用指针。C++将指针暴露给了用户(程序员)，而Java和C#等语言则将指针隐藏起来了。"></a>每一种编程语言都使用指针。C++将指针暴露给了用户(程序员)，而Java和C#等语言则将指针隐藏起来了。</h4><p>“Everything uses pointers. C++ just exposes them rather than hiding them,”<br />It’s easier to give someone an address to your home than to give a copy of your home to everyone.</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>指针能够有效的表示数据结构；</li><li>能<strong>动态分配内存</strong>，实现内存的自由管理；</li><li>能较方便的<strong>使用字符串</strong>；</li><li>便捷高效地使用数组</li><li><strong>指针直接与数据的储存地址有关</strong>，比如：<strong>值传递不如地址传递高效</strong>，因为值传递先从实参的地址中取出值，再赋值给形参代入函数计算；而指针则把形参的地址直接指向实参地址，使用时直接取出数据，效率提高，特别在频繁赋值等情况下（注意：形参的改变会影响实参的值！）</li></ul><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><p>本质：引用是别名，指针是地址，具体的：</p><ol><li>从现象上看，<strong>指针在运行时可以改变其所指向的值</strong>，而<strong>引用一旦和某个对象绑定后就不再改变</strong>。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变。</li><li>从内存分配上看，<strong>程序为指针变量分配内存区域，而不为引用分配内存区域</strong>，因为引用声明时必须初始化，从而指向一个已经存在的对象。引用不能指向空值。</li></ol><p>注：标准没有规定引用要不要占用内存，也没有规定引用具体要怎么实现，具体随编译器 <a href="http://bbs.csdn.net/topics/320095541">http://bbs.csdn.net/topics/320095541</a></p><ol start="3"><li>从编译上看，程序在编译时分别将指针和引用添加到<strong>符号表</strong>上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而<strong>引用</strong>在符号表上对应的地址值为<strong>引用对象的地址值</strong>。符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。这是使用指针不安全而使用引用安全的主要原因。从某种意义上来说<strong>引用可以被认为是不能改变的指针</strong>。</li><li><strong>不存在指向空值的引用</strong>这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。</li><li>理论上，对于指针的级数没有限制，但是引用只能是一级。如下：<br />int** p1;         &#x2F;&#x2F; 合法。指向指针的指针<br />int*&amp; p2;         &#x2F;&#x2F; 合法。指向指针的引用<br />int&amp;* p3;         &#x2F;&#x2F; 非法。指向引用的指针是非法的<br />int&amp;&amp; p4;         &#x2F;&#x2F; 非法。指向引用的引用是非法的<br />注意上述读法是<strong>从左到右</strong>。 </li><li>引用的大小是所指向的变量的大小，因为引用只是一个别名而已；<strong>指针是指针本身的大小，4个字节</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Map的使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Map%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Map%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol><li>可以根据目标键值对位于 map 容器中的位置，实现删除该键值对的目的。erase() 方法的语法格式如下：</li></ol><p><strong>&#x2F;&#x2F;删除 map 容器中指定位置的键值对<br />iterator erase (const_iterator position);</strong><br />其中，position 为迭代器，指向要删除的键值对。同时该<strong>方法会返回一个 iterator 迭代器，其指向的是删除键值对之后的那个键值对。</strong><br />注意，如果删除的键值对位于 map 容器中最后的位置，则该方法返回的迭代器指向的是最后一个键值对之后的位置（等同于 end() 成员方法返回的迭代器）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除 map 容器中指定位置的键值对</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="comment">//删除 map 容器中键为 k 的键值对</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>除了向 erase() 传入目标键值对位于 map 容器中的位置外，还可以传入目标键值对的键的值，该方法会自行根据指定的键找到目标键值对，并将其删除。erase() 方法的语法格式如下：</li></ol><p><strong>&#x2F;&#x2F;删除 map 容器中键为 k 的键值对<br />size_type erase (const key_type&amp; k);</strong><br />其中，参数 k 为要删除键值对的键的值，该方法的返回值为成功删除的键值对的个数。</p><ol start="3"><li>在某些实际场景中，可能需要删除某个指定区域内的所有键值对，也可以通过 erase() 方法实现，其语法格式如下：</li></ol><p><strong>&#x2F;&#x2F;删除 map 容器中位于 [first，last) 区域内的所有键值对<br />iterator erase (const_iterator first, const_iterator last);</strong><br />其中，参数 first 和 last 都是迭代器，它们的组合 [first, last) 就表示 map 容器中的某个范围，该方法会删除此范围内的所有键值对，并返回一个迭代器，其指向删除范围之后的第一个键值对。<br />注意，如果 [fist,last) 范围之后，不再有任何键值对，则 erase() 方法返回的迭代器将指向 map 容器最后一个键值对之后的位置（等同于 end() 成员方法返回的迭代器）。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol><li>find函数</li><li>count函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt;:: iterator ii=m.<span class="built_in">find</span>(<span class="string">&quot;uuu&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(ii==m.<span class="built_in">end</span>())&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;没有查找到uuu&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;查找uuu成功，并且它的值=&quot;</span>&lt;&lt;ii-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ii=m.<span class="built_in">count</span>(<span class="string">&quot;uuu&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(ii==<span class="number">1</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;查找成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;查找失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;_map;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">while</span>(iter!=_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; iter-&gt;second&lt;&lt;endl;</span><br><span class="line">    iter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(iter = _map.<span class="built_in">begin</span>(); iter != _map.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>对于<code>map</code>的插入，可以使用<code>insert</code>或者<code>[]</code>的形式。</p><ul><li><p><code>insert</code>插入非重复的值，如果插入的值重复出现了，则丢弃要插入的值，对原<code>map</code>不作处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> x = viewSumMap.<span class="built_in">find</span>(creators[i])-&gt;second;</span><br><span class="line">viewSumMap.<span class="built_in">erase</span>(creators[i]);</span><br><span class="line">viewSumMap.<span class="built_in">insert</span>(&#123;creators[i], views[i] + x&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>[]</code>用来插入值，如果没有出现过，则成功插入，如果插入的值重复出现了，则覆盖原<code>map</code>中已经有的值</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viewSumMap[creators[i]] += views[i];</span><br><span class="line"><span class="keyword">if</span> (viewSumMap[creators[i]]&gt;maxView)&#123;</span><br><span class="line">    maxView = viewSumMap[creators[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>一.  map、set、multimap、multiset</strong><br />上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:</p><ul><li>插入: O(logN)</li><li>查看: O(logN)</li><li>删除: O(logN)</li></ul><p><strong>二. unordered_map、unordered_set、unordered_multimap、 unordered_multiset</strong><br />上述四种容器采用哈希表实现，不同操作的时间复杂度为：</p><ul><li>插入: O(1)，最坏情况O(N)</li><li>查看: O(1)，最坏情况O(N)</li><li>删除: O(1)，最坏情况O(N)</li></ul><h3 id="搭配pair使用"><a href="#搭配pair使用" class="headerlink" title="搭配pair使用"></a>搭配<code>pair</code>使用</h3><p>很多时候，映射关系往往不止一个，但是，会关键的<code>key</code>又只有一个，因此我们可以利用<code>pair</code></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是<code>first second</code> 因为是使用<code>struct</code>不是<code>class</code>，所以可以直接使用pair的成员变量。<br />其标准库类型–pair类型定义在<code>#include &lt;utility&gt;</code>头文件中，定义如下：<br />类模板：<code>template&lt;class T1,class T2&gt; struct pair</code><br />参数：T1是第一个值的数据类型，T2是第二个值的数据类型。<br />功能：pair将一对值(T1和T2)组合成一个值，这一对值可以具有不同的数据类型（T1和T2），两个值可以分别用pair的两个公有函数<code>first</code>和<code>second</code>访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;            <span class="comment">//创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span></span><br><span class="line"><span class="function">pair&lt;T1, T2&gt; <span class="title">p1</span><span class="params">(v1, v2)</span></span>;    <span class="comment">//创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。</span></span><br><span class="line"><span class="built_in">make_pair</span>(v1, v2);          <span class="comment">// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span></span><br><span class="line">p1 &lt; p2;                    <span class="comment">// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span></span><br><span class="line">p1 == p2；                  <span class="comment">// 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span></span><br><span class="line">p1.first;                   <span class="comment">// 返回对象p1中名为first的公有数据成员</span></span><br><span class="line">p1.second;                 <span class="comment">// 返回对象p1中名为second的公有数据成员</span></span><br></pre></td></tr></table></figure><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;string,string&gt; Author;</span><br><span class="line"><span class="function">Author <span class="title">proust</span><span class="params">(<span class="string">&quot;March&quot;</span>,<span class="string">&quot;Proust&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Author <span class="title">Joy</span><span class="params">(<span class="string">&quot;James&quot;</span>,<span class="string">&quot;Joy&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// 创建一个空对象anon，两个元素类型都是string</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; word_count;     <span class="comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt; &gt; line;  <span class="comment">// 创建一个空对象line，两个元素类型分别是string和vector类型</span></span><br></pre></td></tr></table></figure><h4 id="接收pair"><a href="#接收pair" class="headerlink" title="接收pair"></a>接收<code>pair</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">getPreson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="string">&quot;Sven&quot;</span>, <span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> ages;</span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">tie</span>(name, ages) = <span class="built_in">getPreson</span>();</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, ages: &quot;</span> &lt;&lt; ages &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七课 动态内存</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/longyi1234/archive/2010/03/30/1700369.html#:~:text=%E5%9C%A8C%2FC%EF%BC%8B%EF%BC%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%AD%EF%BC%8C%E6%9C%89%E4%BA%BA%E7%BB%8F%E5%B8%B8%E6%90%9E%E4%B8%8D%E6%B8%85%E6%A5%9A%E2%80%9C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E2%80%9D%E5%92%8C%E2%80%9C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E2%80%9D%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%A6%82%E5%BF%B5%E3%80%82,%E5%85%B6%E5%AE%9E%E7%AE%80%E5%8D%95%E4%B8%80%E7%82%B9%E8%AE%B2%EF%BC%8C%E2%80%9C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E2%80%9D%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%B8%B8%E9%87%8F%EF%BC%8C%E8%80%8C%E2%80%9C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E2%80%9D%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%9C%B0%E5%9D%80%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%8F%98%E5%8C%96%E7%9A%84%E3%80%82">常量指针和指针常量</a><br>内存：</p><ol><li>堆</li><li>栈</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667284753197-c2837955-829a-4803-bc6e-e96514269d20.png" alt="image.png"></p><h2 id="动态对象"><a href="#动态对象" class="headerlink" title="动态对象"></a>动态对象</h2><ul><li>在堆中创建</li><li><code>new</code> <code>delete</code>既是操作符（可以修改默认语义），也是关键字</li><li><code>new``delete</code>可以重载：只能重载<strong>开辟内存 –</strong> 不一定从编译器管理的内存找，可以自定义在堆上、栈上管理</li></ul><h3 id="为什么需要-new-和-free"><a href="#为什么需要-new-和-free" class="headerlink" title="为什么需要 new 和 free"></a>为什么需要 new 和 free</h3><ul><li>用<code>malloc</code> 创建对象：<strong>不能</strong> 对象的创建必须调用构造函数，构造函数不是显式调用的。</li><li>需要一种新的机制：除了能分配内存，还能调用构造函数；除了能收回内存，还能调用析构函数</li><li><code>new</code>返回的是<code>A*</code>，而<code>malloc</code>返回的是<code>void*</code></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667285017101-ed9dc8a7-8371-461b-a7a5-e7ed38b12f0d.png" alt="image.png"></p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667285182323-e8caee0c-42c3-4528-9126-f861af35210c.png" alt="image.png"></p><ul><li><code>int *intPtr = new int</code>：在堆上创建了基本类型，是一种兼容</li><li>栈上的对象都有名称，<strong>堆上的对象都是无名对象，只能通过指针访问。</strong></li><li>指针本身也是一种数据类型，和字长一样大</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667285335535-599dfb93-d582-4a91-be35-5ff963b3fcee.png" alt="image.png"></p><h3 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h3><ol><li>创建对象时，实际上创建了两个内存块：</li><li><code>delete ptr</code> 删除的是<code>Object</code>，如果生命周期没有结束，仍然可以访问<code>ptr</code>。如果再次调用，会使用已经被删除的内存，出现了段错误</li><li>所以需要 <code>ptr = null</code></li><li>同时，可以避免<code>double free</code>。如果<code>ptr</code>置为<code>Null</code>了，<code>delete</code>是没有用的</li></ol><p>在使用<code>void*</code>时，使用<code>delete</code>，会根据指针类型，调用构造函数。但是，<strong>如果是</strong><code>**void***</code><strong>，直接</strong><code>**delete**</code><strong>，只会释放内存，不会调用构造函数，所以需要类型转换。类型决定了调用哪些函数！</strong></p><blockquote><p><strong>以编译为主的语言，类型十分重要</strong></p></blockquote><h3 id="动态对象数组"><a href="#动态对象数组" class="headerlink" title="动态对象数组"></a>动态对象数组</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667287273247-a93fa9cd-17fa-45d8-861c-591787c8a4d0.png" alt="image.png"></p><ul><li><strong>使用初始化列表，可以显式初始化，所以不一定需要默认构造函数了</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A *p;</span><br><span class="line"><span class="keyword">new</span> A</span><br><span class="line"><span class="keyword">new</span> A[<span class="number">100</span>]  <span class="comment">//返回的都是A*</span></span><br><span class="line">数组的首地址和<span class="number">0</span>号位置的地址一致</span><br><span class="line"><span class="keyword">delete</span>[]p </span><br></pre></td></tr></table></figure></li></ul><ol><li><code>[]</code>不能省略：从声明类型上看，<strong>不知道</strong><code>**p**</code><strong>指向的是存储</strong><code>**A**</code><strong>的数组还是</strong><code>**A**</code><strong>一个对象</strong></li><li><code>delete</code>调用析构函数，归还内存。</li><li>如何知道数组要调用多少次析构函数？</li></ol><p><code>new A[100]</code>会多分配4个字节，返回的地址之前有四个字节用来存储元素个数</p><ol start="4"><li>如果没有<code>[]</code>，<ol><li>则不会找4个字节，只会调用一次析构函数。会导致<strong>内存泄漏</strong></li><li><strong>起始地址是地址减去4个字节，会直接从中间释放，导致段错误</strong></li></ol></li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p </span><br><span class="line">p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]</span><br><span class="line"><span class="keyword">delete</span> p </span><br></pre></td></tr></table></figure><p>该写法是正确的。<strong>对于内置数据类型，不需要调用析构函数，所以不会添加4个字节，所以直接删去整块内存</strong></p><h4 id="动态2D数组"><a href="#动态2D数组" class="headerlink" title="动态2D数组"></a>动态2D数组</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667287517824-1c16de09-8834-4035-9bf7-b3a253ac6ee7.png" alt="image.png"></p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667287588030-9c4ef74c-9ea1-4ff2-b77d-4271e3d66089.png" alt="image.png"><br>缺点：红色的部分是额外的内存开销<br />所以：要用一维数组模拟二维数组<code>a[i][j] = a[i*4+j]</code> 进行操作符重载即可</p><h2 id="Const成员"><a href="#Const成员" class="headerlink" title="Const成员"></a>Const成员</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667287926876-e668fdf0-6f02-4a2b-9236-e8cd36dbca74.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num)&#123;</span><br><span class="line">        x = num;</span><br><span class="line">        <span class="comment">// 会报错</span></span><br><span class="line"><span class="comment">// Cannot assign to non-static data member &#x27;x&#x27; with const-qualified type &#x27;const int&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num):<span class="built_in">x</span>(num)&#123;</span><br><span class="line"><span class="comment">//        x = num;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>static</code>：所有的对象共享一份数据<br /><code>static const</code>：所有的对象共享一份常量。<strong>必须在定义的时候初始化，不能用初始化列表初始化</strong> 在列表中初始化，则说明不同对象可以修改了。作为<code>const</code>，必须在声明时初始化，作为<code>static</code>，不能在列表中初始化，所以只能定义时初始化了<br /><code>const 对象</code>：对象的成员变量不应该被改变<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667288480210-e82ad341-4ad4-4918-b03e-802a4e066723.png" alt="image.png"><br>编译器不知道哪些操作会改变<code>A</code>的值，哪些不会改变<br />所以需要使用：</p><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><ol><li><strong>非const对象可以访问所有的成员函数、变量；const对象除了不能访问非const成员函数外，其它都可以访问。</strong></li><li><strong>const对象中的成员变量也是可以修改的。通过引用修改即可。</strong><code>**indirect_int++**</code></li></ol><ul><li>函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如const char * getname()。</li><li>函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如char * getname() const。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667288621359-d8b8d7c3-9269-47e4-b44f-4d3fa6e16ecc.png" alt="image.png"></p><ol><li><code>f()</code>不是const函数，则不能调用</li><li><code>show</code>可以调用。</li></ol><p>对于<code>B.cpp</code>，只需要看<code>a</code>是否调用了非<code>const</code>成员函数<br />如果在<code>f</code>后面也加入<code>const</code>，可能会出错，则需要进行复杂的检查，因为有可能会不断嵌套其他函数。<br />如果<code>A a2（0,0）</code>，所以需要<strong>对象中的变量和对象同步</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667288632395-81d8de30-232e-4ae3-bda5-2a11ab5c8624.png" alt="image.png"><br>每一个函数，都自带一个指针 <br /><code>void f(A* const this)</code> 该<code>const</code>表明指针中的内容不可变<br /><code>void show(const A* const this);</code><br />const A<em>和A</em>不是同一种类型，涉及到const类型转换<br /><strong>const靠近谁，就是谁不可变</strong>，所以第一个<code>const</code>A*不可变，即A中的内容不可变<br /><strong>调用常量对象，就只能调用该对象中this指向的const的成员函数</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667889646421-3452a6b3-561b-402a-834b-6b779a113e04.png" alt="image.png"><br><code>f</code>中<code>a</code>不可以++，但是引用<code>indirect_int</code>可以加加，因为语法上，<code>**indirect_int**</code><strong>是引用，引用是不变量 ，后面对引用的操作和引用本身无关</strong></p><ul><li><strong>对象外的内存和对象本身无关，不受到</strong><code>**const**</code><strong>的限制</strong></li><li><strong>如果</strong><code>**indirect_int**</code><strong>指向</strong><code>**a**</code><strong>，因为编译器无法区分该变量的内存是在类内还是在类外，所以编译器可以通过。</strong></li><li><strong>所以即使声明常量对象，也无法保证类内的变量不可改变（至少编译器无能为力）</strong></li><li><strong>所以，退一步：如果在变量前加入</strong><code>**mutable**</code><strong>，则该变量就是可以在</strong><code>**const**</code><strong>成员函数中被修改：通过</strong><code>**const cast &lt;A*&gt; this **</code><strong>强制类型转换，来实现</strong><code>**mutable**</code></li></ul><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667891099089-4c5fa2b1-a0ea-47b0-af69-83fa84fd8afd.png" alt="image.png"></p><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ol><li>一个类中可以有一个或多个静态成员变量，<strong>所有的对象都共享这些静态成员变量</strong>，都可以引用它。</li><li>static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，<strong>static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。</strong>而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</li><li>静态成员变量<strong>必须初始化，而且只能在类体外进行</strong>。例如：</li></ol><p><code>int Student::m_total = 10;</code><br /><strong>初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0</strong>，而<strong>动态数据区</strong>（堆区、栈区）变量的<strong>默认值是不确定的，一般认为是垃圾值。</strong></p><ol start="4"><li>静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。</li><li>在 C++ 中，static 静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667891271922-930973d6-d869-4051-9c99-184c7631e62d.png" alt="image.png"><br>什么时候定义：、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;    <span class="type">int</span>   x,y;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::shared=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 放在类外的.cpp文件中</span></span><br></pre></td></tr></table></figure><p><code>static const</code>什么时候定义：</p><ul><li><code>const</code>要在成员初始化表中初始化，是在对象创建的时候调用的</li><li>共享+不可变：<strong>在类内声明的时候定义</strong> <code>const static int x = 0</code></li></ul><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667891609721-8e8a5090-69d1-433e-b8f7-147334599d5b.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667891743612-078096d0-b329-41a5-a8c3-e74426adc649.png" alt="image.png"></p><ul><li>兼容了对象和名空间的语法</li><li>既是对象的函数也可解释为类的函数</li><li>区分静态、动态：<ul><li><strong>控制对象的创建</strong></li><li>实现共享</li></ul></li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>控制对象的创建<br />特殊：构造函数和拷贝构造函数声明为<code>private</code> – 类外不能<code>new</code>一个<code>singleton</code>，因为是在<code>new</code>中调用构造函数，但是是私有的，所以禁止在类外<code>new</code>一个对象，所以<strong>对象的创建是可控的</strong><br />懒初始化：用到了再去创建，规定了创建过程是动态的，由<code>new</code>来创建，而不是由<code>static</code>控制。<br />但类外不能创建，所以只能在类内创建 – 如何调用里面的方法？<br />所以：<strong>需要一个静态的入口</strong>，</p><ul><li><strong>静态区</strong>：专门负责动态区的对象的创建和消亡：</li><li><code>_static singleton * instance() _``_static void destroy()  _</code></li><li><strong>只能通过静态成员方法来控制</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667892193353-c847d134-54d2-4147-abb7-d91c301eb9e0.png" alt="image.png"></p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p><a href="http://c.biancheng.net/view/2233.html">C++友元函数和友元类（C++ friend关键字）</a><br>借助友元（friend），可以使得<strong>其他类</strong>中的成员函数以及全局范围内的函数<strong>访问当前类的 private 成员。</strong></p><ul><li>不是类的成员</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667892692130-70164f8a-6256-4ce3-89ca-cb3c56e82d6f.png" alt="image.png"><br>① 程序第 4 行对 Address 类进行了提前声明，是因为在 Address 类定义之前、在 Student 类中使用到了它，如果不提前声明，编译器会报错，提示’Address’ has not been declared。<strong>类的提前声明和函数的提前声明是一个道理。<br />② 程序将 Student 类的声明和实现分开了，而将 Address 类的声明放在了中间，这是因为编译器从上到下编译代码，show() 函数体中用到了 Address 的成员 province、city、district，</strong>如果提前不知道 Address 的具体声明内容，就不能确定 Address 是否拥有该成员（类的声明中指明了类有哪些成员）**。</p><p>这里简单介绍一下类的提前声明。一般情况下，类必须在正式声明之后才能使用；但是<strong>某些情况下（如上例所示），只要做好提前声明，也可以先使用。<br />但是应当注意，</strong>类的提前声明的使用范围是有限的<strong>，</strong>只有在正式声明一个类以后才能用它去创建对象<strong>。如果在上面程序的第4行之后增加如下所示的一条语句，编译器就会报错：<br /><code>Address addr;</code>&#x2F;&#x2F;<strong>企图使用不完整的类来创建对象</strong><br />因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），才能确定应该为对象预留多大的内存。</strong>在对一个类作了提前声明<strong>后，可以用该类的名字去</strong>定义指向该类型对象的指针变量<strong>（本例就定义了 Address 类的指针变量）或</strong>引用变量<strong>（后续会介绍引用），因为</strong>指针变量和引用变量本身的大小是固定的，与它所指向的数据的大小无关。<br />③ <strong>一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。</strong></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667893058472-fe4566bd-9ad8-46b3-b4b4-ec0d137414f6.png" alt="image.png"></p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li>两次声明：可以把friend看做继承</li><li>遵循<strong>先声明后使用的原则</strong>，没有声明则不能确定类型的内存大小</li><li>可以没有<code>class B</code>，但不可以没有<code>class C</code>。因为没有像C使用<code>C::f</code>。没有<code>class B</code>，可以当做一种前向声明，<strong>但是作为一个友元，需要写成</strong><code>**friend B**</code><strong>，因为肯定是引用已有的的</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667893108982-3d504155-5ecf-4abf-b6eb-c28062867ad3.png" alt="image.png"></p><h3 id="不完整声明"><a href="#不完整声明" class="headerlink" title="不完整声明"></a>不完整声明</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667893531250-3e7bf232-0bfb-4083-8f61-581e6572f675.png" alt="image.png"></p><ul><li><strong>因为vector &amp;v 是一个引用，内存大小是确认的，所以可以进行不完整的声明。</strong></li></ul><p>如果A B类互相引用对方，则头文件不能互相引用，所以要在A的头文件中进行前向声明。但是因为没有完整声明，所以A的show和B的show都要写在B的cpp文件中 &#x3D;&gt;设计有点问题 &#x3D;&gt;引入都要同时引用两个类的头文件。</p><ul><li>友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。</li><li>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。</li></ul><h3 id="友元和继承"><a href="#友元和继承" class="headerlink" title="友元和继承"></a>友元和继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    <span class="type">int</span> prot_mem; </span><br><span class="line"><span class="comment">// 该基类中没用友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;)</span></span>; <span class="comment">// clobber 是Sneaky的友元函数，可以访问Sneaky中的private和protected变量</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;)</span></span>; <span class="comment">//clobber 并不是Base的友元函数</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过继承，相当于派生类本身有prom_mem变量，所以可以当作普通的私有、保护变量处理</span></span><br><span class="line">    s.j = s.prot_mem = <span class="number">0</span>; <span class="comment">// 因此可以被友元函数访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobberUnfriend</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; <span class="comment">// 普通函数，没有声明为友元函数时，只能访问对象的公有变量</span></span><br><span class="line"><span class="comment">//    s.j = 0; // error 需要public</span></span><br><span class="line"><span class="comment">//    s.prot_mem = 0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125; <span class="comment">// 该函数需要在Base中定义为友元函数才可以使用</span></span><br></pre></td></tr></table></figure><h2 id="封装原则"><a href="#封装原则" class="headerlink" title="封装原则"></a>封装原则</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668493109613-88d9a76f-af08-42cd-a449-0f68d5ccb046.png" alt="image.png"><br>迪米特法则：信息流在模块之间流动应该是最小的，对象之间的依赖是最小的。</p><h3 id="static和const辨析"><a href="#static和const辨析" class="headerlink" title="static和const辨析"></a>static和const辨析</h3><ol><li><code>static</code>变量在类内声明，且<strong>只能在类外初始化 在类外初始化是保证static成员变量只被定义一次的好方法。</strong></li><li><code>const</code>变量只能类内初始化，不能类外初始化</li><li><code>static const</code>既可以在类内初始化，也可以做类外初始化，但是不能重复初始化</li><li><code>static</code>定义了类内变量后，不可以<code>static int A::num2 = 50;``static</code>关键字如果用了类的名空间，就只能在类内使用</li><li>非静态变量只能在类内初始化，不能在类外初始化</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm库</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/algorithm%E5%BA%93/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/algorithm%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-查找最大最小值"><a href="#1-查找最大最小值" class="headerlink" title="1. 查找最大最小值"></a>1. 查找最大最小值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// min_element/max_element example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::min_element, std::max_element</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myfn</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i&lt;j; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i&lt;j; &#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> myints[] = &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using default comparison:</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The smallest element is &quot;</span> &lt;&lt; *std::<span class="built_in">min_element</span>(myints,myints+<span class="number">7</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The largest element is &quot;</span>  &lt;&lt; *std::<span class="built_in">max_element</span>(myints,myints+<span class="number">7</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using function myfn as comp:</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The smallest element is &quot;</span> &lt;&lt; *std::<span class="built_in">min_element</span>(myints,myints+<span class="number">7</span>,myfn) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The largest element is &quot;</span>  &lt;&lt; *std::<span class="built_in">max_element</span>(myints,myints+<span class="number">7</span>,myfn) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using object myobj as comp:</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The smallest element is &quot;</span> &lt;&lt; *std::<span class="built_in">min_element</span>(myints,myints+<span class="number">7</span>,myobj) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The largest element is &quot;</span>  &lt;&lt; *std::<span class="built_in">max_element</span>(myints,myints+<span class="number">7</span>,myobj) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><code>lower_bound(起始地址, 末尾地址, target)</code>：查找第一个大于等于target目标值的位置<br /><code>upper_bound(起始地址, 末尾地址, target)</code>：查找第一个大于target目标值的位置<br /><code>binary_search(起始地址, 末尾地址, target)</code>：查找target是否存在于数组或vector中，找到返回true，否则返回false<br />这三种方法都是采用的二分查找实现的函数，用于有序数组或vector等，查找效率较高，实际写题时，直接用能较少很多代码量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lower_bound/upper_bound example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::lower_bound, std::upper_bound, std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(myints,myints+<span class="number">8</span>)</span></span>;           <span class="comment">// 10 20 30 30 20 10 10 20</span></span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span> (v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());                <span class="comment">// 10 10 10 20 20 20 30 30</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt;::iterator low,up;</span><br><span class="line">  low=std::<span class="built_in">lower_bound</span> (v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>); <span class="comment">//          ^</span></span><br><span class="line">  up= std::<span class="built_in">upper_bound</span> (v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>); <span class="comment">//                   ^</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;lower_bound at position &quot;</span> &lt;&lt; (low- v.<span class="built_in">begin</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;upper_bound at position &quot;</span> &lt;&lt; (up - v.<span class="built_in">begin</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="find查找"><a href="#find查找" class="headerlink" title="find查找"></a>find查找</h4><p><code>set.find(a)</code>：查找a是否在set中，如果找不到，返回<code>set.end()</code><br /><code>set.count(a)</code>：本来是计算a出现的次数，但是由于集合中是没有重复元素的，于是count函数也就被作为查找函数了，因为a只能出现1次或者0次，查找成功，返回1；查找失败返回0.<br /><code>map.find()</code>：主要用于查找key是否存在map中，不存在返回<code>map.end()</code>，用法和set一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(), v.end())</span></span>;</span><br><span class="line">    <span class="comment">//查找2</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="number">2</span>) != s.<span class="built_in">end</span>()) cout &lt;&lt; <span class="string">&quot;查找成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="swap（）交换"><a href="#swap（）交换" class="headerlink" title="swap（）交换"></a>swap（）交换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">( T&amp; a, T&amp; b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">c</span><span class="params">(a)</span></span>; a=b; b=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reverse（）倒转"><a href="#reverse（）倒转" class="headerlink" title="reverse（）倒转"></a>reverse（）倒转</h3><p>reverse函数反转[first, last)区间的数据，first和last都是迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reverse</span> <span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ((first!=last)&amp;&amp;(first!=--last)) &#123;</span><br><span class="line">    std::<span class="built_in">iter_swap</span> (first,last);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七课 继承</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/qlwy/archive/2011/08/25/2153584.html">C++继承：公有，私有，保护 - csqlwy - 博客园</a></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668493594435-d4b604a2-126b-4d80-811e-04f69bfa1aa0.png" alt="image.png"></p><ul><li>继承了抽象类型，保证代码不会因为子类的修改而变动，有利于今后的维护</li><li>增量开发：可以直接在<code>List</code>类下直接增加<code>LinkedList</code>，而不影响类库</li><li>继承：父类中的所有部分都必须在子类中有</li><li>继承主要是为了继承类型，而不是继承父类的代码</li><li><code>**class**</code><strong>的默认访问权限是</strong><code>**private**</code><strong>，</strong><code>**struct**</code><strong>的默认访问权限是</strong><code>**public**</code></li><li>类中的函数编译时和其他普通函数一样 <code>classname::function(classname *const this)</code></li><li>派生类调用基类的函数，向基类传入自己的指针 – 允许派生类隐式转换为基类</li><li>可以理解为派生类中内嵌了一个基类对象：基类中的<code>private</code>成员代表<strong>派生类中存在基类的私有变量，但逻辑上不可见，只能通过基类的公开方法访问。</strong></li><li>派生类中可以访问基类中的<code>protected</code>成员：如果额外创建了一个对象student，此时不可以访问，只有自己继承父类student，才可以访问其中的变量。因为额外创建的对象不是自己的，继承的是自己的。<strong>如果额外创建了一个父类对象，则不可以访问其成员</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pro = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    using B::x;</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    B *outFather = <span class="keyword">new</span> B;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">proInFather</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; pro &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 此处不会发生编译错误，因为基类嵌入在派生类的内存块中</span></span><br><span class="line">    <span class="comment">// 继承时，不管是public继承还是private/protected继承，基类对于派生类来说，其public成员和</span></span><br><span class="line">    <span class="comment">// protected成员都是可见的</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">proOutFather</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; outFather-&gt;pro &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 此处会发生编译错误，因为是额外创建了一个基类，而pro是保护成员，无法被</span></span><br><span class="line">        <span class="comment">// 实例化的对象所访问，因此会发生编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基类和继承类的方法关系"><a href="#基类和继承类的方法关系" class="headerlink" title="基类和继承类的方法关系"></a>基类和继承类的方法关系</h3><ul><li><strong>根据实际对象执行 – 在编译时期无法确定实际的对象</strong></li><li>利用名空间匹配函数名，匹配函数名成功后，继续匹配参数：但是匹配名称的过程已经结，不会在退回到此步骤（性能上的考虑），所以会直接报错</li><li>不重新定义基类中的非虚函数</li><li>方法的继承：<strong>名空间的可见</strong></li><li>属性的继承：都有拷贝，但不一定可见</li><li>访问的时候会出现<strong>名空间隐藏</strong>的问题<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">10</span>;<span class="comment">//id在Undergraduated_Student中仍然是私有的，默认权限位private</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123; <span class="built_in">strcpy</span>(nickname, s); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> nickname[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_ID</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; id = x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; nickname &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;getId&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// 通过继承基类的公有方法访问到基类的私有变量</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> y = <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span> : <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="type">int</span> dept_no&#123;&#125;;<span class="comment">//学院编号</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; dept_no = x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    void showInfo()&#123;cout &lt;&lt; dept_no &lt;&lt; &quot;:&quot; &lt;&lt; nickname &lt;&lt; endl;&#125;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_ID</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;changed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// 对基类的函数进行覆盖，并修改了访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> Student::nickname;<span class="comment">//这样在才能修改可见性</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新定义了一个private方法，父类对应方法被隐藏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Undergraduated_Student *us = <span class="keyword">new</span> Undergraduated_Student;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; us-&gt;y;</span></span><br><span class="line">    us-&gt;<span class="built_in">SetNickName</span>();</span><br><span class="line">    us-&gt;<span class="built_in">getId</span>();</span><br><span class="line"><span class="comment">//    us-&gt;showInfo(); 无法访问，通过隐藏父类的方法，修改了访问权限</span></span><br><span class="line">    us-&gt;Student::<span class="built_in">showInfo</span>(<span class="number">10</span>); <span class="comment">// 被隐藏了，但是可以显式的使用对应的名空间进行访问</span></span><br><span class="line"><span class="comment">//    us-&gt;showInfo(10); //error ,因为被子类的同名方法所隐藏了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承访问权限：<br />默认：private<br />public<br />private：原来的<br /><strong>私有继承不能用在多态中</strong><br /><strong>私有继承不是类型继承，只是代码复用，所以私有继承使用较少</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668496437699-30d6f703-f199-434b-ad58-bd98998be2dd.png" alt="image.png"><br>前向声明：只是知道有这个东西，不在乎内存大小，所以<strong>前向声明的正确方式为第二种，完整声明的正确方式为第一种</strong></p><hr><p><strong>1）基类成员对派生类都是：共有和保护的成员是可见的，私有的的成员是不可见的。</strong><br /><strong>2）基类成员对派生类的对象来说：要看基类的成员在派生类中变成了什么类型的成员。如：私有继承时，基类的共有成员和私有成员都变成了派生类中的私有成员，因此对于派生类中的对象来说基类的共有成员和私有成员就是不可见的。</strong></p><h5 id="对于公有继承方式"><a href="#对于公有继承方式" class="headerlink" title="对于公有继承方式"></a>对于公有继承方式</h5><p>(1) 基类成员对其对象的可见性：<br />公有成员可见，其他不可见。这里保护成员同于私有成员。<br />(2) 基类成员对派生类的可见性：<br />公有成员和保护成员可见，而私有成员不可见。这里保护成员同于公有成员。<br />(3) 基类成员对派生类对象的可见性：<br />公有成员可见，其他成员不可见。<br />所以，在公有继承时，派生类的对象可以访问基类中的公有成员；派生类的成员函数可以访问基类中的公有成员和保护成员。这里，一定要区分清楚<strong>派生类的对象和派生类中的成员函数对基类的访问是不同的。</strong></p><h3 id="有元和protected"><a href="#有元和protected" class="headerlink" title="有元和protected"></a>有元和protected</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668497699369-13fbaa61-6e09-4c73-9306-78ebcbaeda1e.png" alt="image.png"><br>只有基类直接的派生类可以访问到基类的protected，不可以传入基类对象或者创建基类对象进行访问。<strong>保护 — 只能访问内嵌的基类，否则就可以如上述案例，绕过保护作用</strong><br /><strong>友元不具有传递性：不能通过成为派生类的友元来成为基类的友元</strong></p><h3 id="继承时构造函数的调用顺序"><a href="#继承时构造函数的调用顺序" class="headerlink" title="继承时构造函数的调用顺序"></a>继承时构造函数的调用顺序</h3><p>1、子类对象在创建时会首先调用父类的构造函数<br />2、父类构造函数执行完毕后，才会调用子类的构造函数<br />3、当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数<br />4、析构函数调用顺序和构造函数相反<br /><strong>派生类对象的初始化</strong>由基类和派生类共同完成<br /><strong>构造函数的执行次序</strong></p><ol><li>基类的构造函数</li><li>派生类<strong>对象成员类</strong>的构造函数</li><li>派生类的构造函数</li></ol><p>**析构函数的执行次序 **与构造函数相反<br /> 执行顺序：<br />1.构造基类（因为首先要通过继承，确认成员变量）<br />2.成员变量初始化<br />3.初始化列表初始化<br />4.该类的构造函数<br /> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base1 构造函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base1 析构函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son1 构造函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Son1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son1 析构函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里可以看到，先调用Base1的构造函数</span></span><br><span class="line"><span class="comment"> * 再调用Son1的构造函数，</span></span><br><span class="line"><span class="comment"> * 然后先析构Son1，</span></span><br><span class="line"><span class="comment"> * 最后析构Base1。</span></span><br><span class="line"><span class="comment"> * 注：1、这里的顺序和类作为成员变量很像，但是</span></span><br><span class="line"><span class="comment"> *     实质是不一样的。成员是直接创建一个新的对象，</span></span><br><span class="line"><span class="comment"> *     而继承是对父类的成员调用。</span></span><br><span class="line"><span class="comment"> *     2、子类在继承父类的属性的时候，可以继承成员</span></span><br><span class="line"><span class="comment"> *     属性，但是构造和析构函数是类本身的特有属性，</span></span><br><span class="line"><span class="comment"> *     是不可以被继承下来的。这里要特别注意！！！ </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son1 s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================华丽的分割线===============================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base2 构造函数！&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Base2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base2 析构函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base2&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注:当父类没有合适的默认构造函数的时候，</span></span><br><span class="line"><span class="comment">     *    子类在调用父类的时候，需要用列表的</span></span><br><span class="line"><span class="comment">     *    方式调用父类的构造函数，否则编译不过。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     Base1 base1;</span><br><span class="line">     Base2 base2;</span><br><span class="line">    <span class="built_in">Son2</span>(<span class="type">int</span> a):<span class="built_in">Base2</span>(a), <span class="built_in">base2</span>(<span class="number">99</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son2 构造函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Son2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son2 析构函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Son2 <span class="title">s</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n==========================华丽的分割线===============================\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Base1 构造函数！</span></span><br><span class="line"><span class="comment">// Son1 构造函数！</span></span><br><span class="line"><span class="comment">// Son1 析构函数！</span></span><br><span class="line"><span class="comment">// Base1 析构函数！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==========================华丽的分割线===============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Base2 构造函数！1</span></span><br><span class="line"><span class="comment">// Base1 构造函数！</span></span><br><span class="line"><span class="comment">// Base2 构造函数！99</span></span><br><span class="line"><span class="comment">// Son2 构造函数！</span></span><br><span class="line"><span class="comment">// Son2 析构函数！</span></span><br><span class="line"><span class="comment">// Base2 析构函数！</span></span><br><span class="line"><span class="comment">// Base1 析构函数！</span></span><br><span class="line"><span class="comment">// Base2 析构函数！</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668498234783-538be04d-aa92-42da-bcfc-a6cbeef904d8.png" alt="image.png"><br>如果自定义拷贝构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(<span class="number">10</span>,<span class="number">100</span>)</span></span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">B</span> <span class="params">(<span class="type">const</span> &amp;B b)</span>:A(b)</span></span><br><span class="line"><span class="function">// 显示的声明调用A的拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li>如果自定义了B的拷贝构造函数，则先调用A的<strong>默认构造函数</strong>和B的拷贝构造函数，不会进行默认拷贝构造函数。<strong>需要显示的声明调用A的拷贝构造函数</strong></li><li>如果没有自定义B的拷贝构造函数，会调用A B的<strong>默认拷贝构造函数</strong></li><li>程序员介入了资源管理，编译器会决定什么都不干</li></ul><p>语法糖<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668498664408-4128ab5f-fddc-4be3-9267-311a490fb013.png" alt="image.png"></p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="类型相容"><a href="#类型相容" class="headerlink" title="类型相容"></a>类型相容</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669097615644-8abfdef5-9142-4062-a4d9-a80fefed2f61.png" alt="image.png"><br>类型相容：<br /><code>A a;  B b; class B: public A</code><br /><code>a=b</code>都是栈上的两个对象，会将一个内存单元的内容赋值到另一个内存单元中。但<code>a</code>的内存块通常比<code>b</code>小。<strong>赋值相容不代表精度仍然保持一致，直接丢弃超出的内容，因为赋值后身份已经发送了变化，所以不会再使用独属于派生类的属性了。</strong><br /><code>b</code>所丢失的部分就是<strong>对象切片</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669098065167-7be38f9f-93a0-42ff-937c-93e517c2ad5b.png" alt="image.png"><br>引用和指针都不涉及到对象的赋值，对象身份没有改变，可以使用多态<br />C++会灵活使用栈和堆，而Java大部分都在堆上创建对象，C++效率更高</p><h3 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669098345401-a321406e-d37d-46e2-ad7f-1f5186252e98.png" alt="image.png"><br><code>func1</code>调用<code>A::f </code><br /><code>func2</code>调用<code>A::f </code><br /><strong>编译顺序很关键</strong>：</p><ol><li>先编译<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669098507783-9f529832-a853-44d8-84e0-6ec7c79c9640.png" alt="image.png">，<code>a</code>的地址已经定义好了，<code>**fun1**</code><strong>不知道实际对象是什么，只看声明的类型是什么，编译时刻已经确定地址是什么。</strong>当出现调用时，再传递参数。</li></ol><h3 id="绑定顺序"><a href="#绑定顺序" class="headerlink" title="绑定顺序"></a>绑定顺序</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669098609451-c9a15725-42bd-4437-a10a-86646f16b8dd.png" alt="image.png"></p><ul><li>前期绑定是通过声明的类型确定地址，效率更高😀</li><li>前期绑定也叫静态绑定，动态绑定也叫后期绑定</li><li>多态只能通过动态绑定实现，需要不断去寻找地址。</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669098751773-5d777830-2df2-486b-9006-79a3b3bcf468.png" alt="image.png"><br><strong>基类中被定义为虚成员函数，则派生类中对其重定义的成员函数均为虚函数</strong><br /><strong>在子类中重写函数，但是没显示写virtual，仍然会默认为虚函数</strong></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul><li>类的成员函数才可以是虚函数</li><li>静态成员函数不能是虚函数：在全局初始化时，静态编译时就已经确定，<strong>只和类有关，和对象无关，类是通过静态绑定的。</strong></li><li>内联成员函数不能是虚函数：在编译时进行代码替换，需要决定用哪一段代码进行替换，已经消除了函数调用，相当于复制了函数内容</li><li>构造函数不能是虚函数</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669270003568-cd301292-6551-438d-b907-229ce23d7ad5.png" alt="image.png"><br>不存在声明类型和实际类型不一致的情况</p><ul><li>析构函数可以（往往）是虚函数</li></ul><p><strong>当基类指针指向派生类的时候，若基类析构函数不声明为虚函数，在析构时，只会调用基类而不会调用派生类的析构函数，从而导致内存泄露。</strong></p><h3 id="动态绑定的实现"><a href="#动态绑定的实现" class="headerlink" title="动态绑定的实现"></a>动态绑定的实现</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669099413312-8d7304c5-0ac3-48af-9b6f-cc689a7e4fd1.png" alt="image.png"></p><ul><li>调用<code>p-&gt;f </code>因为是虚函数，所以指向a时，调用的是A中的f，指向b时，调用的是B中的f。每一次调用，都要<strong>寻找地址</strong></li><li>调用<code>p-&gt;h</code>，调用的都是A中的h，因为是<strong>静态绑定</strong>的，所以只和声明的类型有关，是为了提高效率</li></ul><p><code>_**(**((char *)p-4))(p)**_</code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669100693413-17a4d8f4-11a7-496d-a674-8802585aea97.png" alt="image.png"></p><ul><li>通过两次解引用找到函数，所以效率较低</li></ul><h3 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669101373514-aba3460d-e38f-422a-ab43-67a8fc090557.png" alt="image.png"></p><h3 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669101481670-7d0e9a68-3ea5-4df7-9a49-374348c6d6c8.png" alt="image.png"><br>非虚函数部分和当前对象保持一致，虚函数部分和实际对象保持一致</p><ul><li>非虚接口：非虚函数中调用虚函数</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669102171092-59924684-73b5-4643-8f98-c48c5f537f9d.png" alt="image.png"><br>override：参数一致，返回值也要一致<br />f2中override去掉是可以的，是新定义的静态函数。和虚函数同名的静态函数，也会名空间覆盖<br />const：不能去掉，有无const<strong>不能不能类型转换</strong></p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669270166264-92b934f8-9956-46b7-8f85-8547dd98b1b1.png" alt="image.png"></p><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669270197146-22a55467-bed9-4fb0-b158-a9581381ccbc.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669270225691-ebd0984d-221b-4cde-be0c-d076a4f8596e.png" alt="image.png"></p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669270374234-a17419e7-4a70-4785-a5b8-f2412a691ed0.png" alt="image.png"></p><ul><li>**析构函数是用来换额外的内存的，不是用来还自身对象的内存的，因为申请内存时是会记录内存大小的 **所以没有申请额外内存时，就不需要自定义析构函数</li></ul><p>因为D中不会自动<code>delete name</code>，所以需要在D中自定义析构函数，所以需要确保调用该析构函数，所以需要定义为虚函数。</p><ul><li><strong>派生类析构函数完成后，自动调用基类的析构函数</strong></li></ul><h3 id="绝对不要重新定义继承而来的缺省参数值"><a href="#绝对不要重新定义继承而来的缺省参数值" class="headerlink" title="绝对不要重新定义继承而来的缺省参数值"></a>绝对不要重新定义继承而来的缺省参数值</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669271262345-5b75d5cd-a582-4fa7-87d5-5f33d78fb5a5.png" alt="image.png"></p><ul><li>默认参数值：<strong>编译时确定的</strong><ul><li><code>f()</code>将默认参数绑定在上面</li><li><code>f(x)</code>将参数<code>x</code>绑定在函数上</li></ul></li><li>根据声明类型，找到默认参数值</li></ul><p>动态调用默认参数值，需<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669271533569-42e4d663-46e0-4d5f-87d2-7129058d1805.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669271556775-59e413bd-1df4-43e0-989f-9151876b47cd.png" alt="image.png">  <br /><strong>对象中只记录虚函数的入口地址，不记录相关的参数，为了提高效率，除了虚函数其他都是静态编译完成的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">110</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">1</span>)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; in B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">75</span>)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; in C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *p_a;</span><br><span class="line">    B b;</span><br><span class="line">    p_a = &amp;b;</span><br><span class="line">    p_a-&gt;<span class="built_in">f</span>(); <span class="comment">// 110 in B</span></span><br><span class="line">    A *p_a1;</span><br><span class="line">    C c;</span><br><span class="line">    p_a1 = &amp;c;</span><br><span class="line">    p_a1-&gt;<span class="built_in">f</span>(); <span class="comment">// 110 in C</span></span><br><span class="line">    c.<span class="built_in">f</span>(); <span class="comment">// 75 in C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好的公开继承"><a href="#好的公开继承" class="headerlink" title="好的公开继承"></a>好的公开继承</h3><ul><li>确定public inheritance,是真正意义的“is_a”关系</li><li>不要定义与继承而来的非虚成员函数同名的成员函数</li><li>最弱前置条件</li><li>最强后置条件</li><li>契约式设计</li><li>派生类不是代表“特殊”，因为特殊代表性质会改变</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669272346654-2de6294b-5fb8-45f9-87f5-a542aaaba2e6.png" alt="image.png"><br><code>**assert(s.width() == s.height());**</code>不变式<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669273538285-127f0faf-fd48-4132-9b8a-ddb4f9a5947a.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669273739637-a0853c6a-d974-4e46-a167-e11c6be7b7ae.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669273851180-58caa6d5-4347-4fb1-8001-cd0e26310f9d.png" alt="image.png"><br>同一个对象，呈现了不同行为 – 名空间不同，出现错误调用</p><h3 id="明智的私有继承"><a href="#明智的私有继承" class="headerlink" title="明智的私有继承"></a>明智的私有继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CHumanBeing</span> &#123; … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStudent</span>: <span class="keyword">private</span> CHumanBeing &#123; … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> CHumanBeing&amp; h)</span></span></span><br><span class="line"><span class="function"></span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line">CHumanBeing a;  CStudent b;</span><br><span class="line"><span class="built_in">eat</span>(a);</span><br><span class="line"><span class="built_in">eat</span>(b); <span class="comment">//Error </span></span><br></pre></td></tr></table></figure><ul><li><strong>私有继承，派生类无法隐式转换为基类。不能使用基类指向派生类的场景</strong></li><li>转换由编译器完成，要求派生类能够公开访问基类的构造函数。</li></ul><p><code>Implemented-in-term-of</code></p><ol><li>需要使用<code>Base Class</code>中的<code>protected</code>成员，或重载<code>virtual function</code></li><li>不希望一个<code>Base Class</code>被<code>client</code>使用</li><li>实际上是Has-A关系</li><li>如果两个类的继承是私有的，则不能在派生类外将派生类转换成基类对象。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669274553636-5752421b-8251-4145-9ab5-33b00a99f87f.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> string&amp; msg)</span></span>;   </span><br><span class="line"><span class="comment">// 一般虚函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 非虚函数：保持所有对象的行为一致，而且不能修改，防止违反契约，</span></span><br><span class="line"><span class="comment">// 不重新定义非虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>练习</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E7%BB%83%E4%B9%A0/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668497123984-785e0d99-2c2c-4975-89cc-7af23c3a0e60.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span></span>&#123;x = px;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getX</span><span class="params">()</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> B::x;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span></span>&#123;x = <span class="number">2</span>*px;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B * pb = <span class="keyword">new</span> D;</span><br><span class="line">    pb-&gt;<span class="built_in">setX</span>(<span class="number">15</span>);</span><br><span class="line">    pb-&gt;<span class="built_in">getX</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;x&#x27; is a private member of &#x27;B&#x27; i🎇🎇🎇</span></span><br></pre></td></tr></table></figure><ul><li>使用名空间调用B.x，是不可见的，因为<strong>默认为private，所以没有using的权限，无法改变其使用权限</strong></li><li><strong>如果删掉第11行代码也是错误的，因为此处的x依然是指B中的x，虽然内存中含有，但是不可见</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span> </span>&#123;</span><br><span class="line">        x = px;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;setX in B &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    using B::x;</span></span><br><span class="line">    <span class="type">int</span> x&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">2</span> * px;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;setX in D&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">methodInD</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;methodInD&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B *pb = <span class="keyword">new</span> D;</span><br><span class="line">    pb-&gt;<span class="built_in">setX</span>(<span class="number">15</span>); <span class="comment">//set X in B</span></span><br><span class="line">    pb-&gt;<span class="built_in">getX</span>();   <span class="comment">// 15</span></span><br><span class="line">    <span class="comment">// 因为没有加virtual，同时由于编译的缘故，所以pb只能通过声明的类型去使用方法，因此pb只能</span></span><br><span class="line">    <span class="comment">// 看到基类自己的方法，而无法看到派生类的方法</span></span><br><span class="line">    pb-&gt;<span class="built_in">methodInD</span>(); <span class="comment">// 会报错: No member named &#x27;methodInD&#x27; in &#x27;B&#x27; i 🔥🔥</span></span><br><span class="line">    D *pd = <span class="keyword">new</span> D;</span><br><span class="line">    pd-&gt;<span class="built_in">setX</span>(<span class="number">10</span>); <span class="comment">// set X in D</span></span><br><span class="line">    pd-&gt;<span class="built_in">getX</span>();  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>隐藏函数？<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668497335363-9d85365e-f299-4ae6-822a-978dc204e4b6.png" alt="image.png"><br>编译正确，输出为0<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span> </span>&#123;</span><br><span class="line">        x = px;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;setX in B &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    using B::x;</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;setX in D&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span> </span>&#123; B::<span class="built_in">setX</span>(<span class="number">2</span> * px); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B *pb = <span class="keyword">new</span> D;</span><br><span class="line">    pb-&gt;<span class="built_in">setX</span>(<span class="number">15</span>); <span class="comment">// setX in B 因为pb的类型是B类型，所以调用的B中的setX函数</span></span><br><span class="line"><span class="comment">//    pb-&gt;getX();</span></span><br><span class="line">    D *pd = <span class="keyword">new</span> D;</span><br><span class="line">    pd-&gt;<span class="built_in">setX</span>(<span class="number">5</span>); <span class="comment">// setX in B 因为pd中的setX内部调用了B空间下的setX，所以改变的是B空间中的x</span></span><br><span class="line">    pd-&gt;<span class="built_in">getX</span>();  <span class="comment">// 10</span></span><br><span class="line">    pd-&gt;<span class="built_in">setX</span>(); <span class="comment">// setX in D  </span></span><br><span class="line">    pd-&gt;<span class="built_in">getX</span>(); <span class="comment">// 10 调用的依然是B空间中的getX方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七课 多继承</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%A4%9A%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%A4%9A%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669274986730-feb36fb8-60a1-489b-8fe3-5d484ecd5490.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275090314-9b2959bf-fe08-4159-85cf-823b45b922a6.png" alt="image.png"><br>名冲突：<code>weight</code>指向不确定。</p><h3 id="基类分解、菱形设计"><a href="#基类分解、菱形设计" class="headerlink" title="基类分解、菱形设计"></a>基类分解、菱形设计</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275198145-278052dd-2c68-46d7-965b-fd58e64f6e34.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275244282-a443735a-327d-4fe0-893c-debfec756664.png" alt="image.png"><br>形成了<strong>格</strong>，但仍然有名冲突问题</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275435051-efa3038c-b17d-4cde-b084-c0b225dc00b5.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275657042-7a99f6cd-e0ff-4c3d-bd09-97bca26370a8.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275603149-bcb3c6b9-2008-4ffc-b4a4-212a1255c95f.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669276213041-4342840c-4495-4bec-8aec-6dada2097bc7.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>左值和右值</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<ul><li><p>左值：赋值操作符左边的值，是可以被赋值的，通常是一个变量</p></li><li><p>右值：<strong>赋值操作符右边的值</strong>，是一个常数、表达式、函数调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp; y = x; <span class="comment">// 可以把左值绑定在非const的引用上</span></span><br><span class="line"><span class="type">int</span> &amp; z = <span class="number">5</span>; </span><br><span class="line"><span class="comment">// 不可以把右值绑定在非const的引用上，因为右值通常是临时变量，不能</span></span><br><span class="line"><span class="comment">// 修改临时变量的值，很可能已经被销毁了</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;u = <span class="number">5</span>; <span class="comment">// 可以把右值绑定在常量引用上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;u = x;</span><br></pre></td></tr></table></figure><p>右值引用可以绑定在右值上，不可以绑定在左值上。拷贝的代价很高</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">string S = <span class="built_in">generate</span>(); <span class="comment">// 返回的是右值，无法进行拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>移动构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string::<span class="built_in">string</span>(string &amp;&amp; s):<span class="built_in">p</span>(s.p)&#123;</span><br><span class="line">s.p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接将s的指针赋值给当前对象的指针，在将原来s的指针置为空指针。因为不是</span></span><br><span class="line"><span class="comment">// 多个s指向同一个指针，所以避免了二次释放的问题</span></span><br><span class="line"><span class="comment">// 移动完后，指针要置为nullptr，不需要重新创建对象，也不需要进行</span></span><br><span class="line"><span class="comment">// 拷贝，提高了效率</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string &amp;&amp; s = <span class="built_in">generate</span>();</span><br><span class="line"><span class="comment">// 右值可以直接绑定到右值引用上</span></span><br><span class="line"><span class="comment">// 引用就是变量的别名，持有了对这块内存的访问权限，可以对右值进行修改</span></span><br><span class="line"><span class="comment">// 编译器保证持有该引用时，变量不会消亡</span></span><br></pre></td></tr></table></figure></li><li><p>没有自定义拷贝构造函数、拷贝赋值和析构函数时，会提供默认移动构造函数、移动赋值函数</p></li><li><p>移动构造函数是为了降低拷贝的代价，一旦自定义了拷贝构造，就认为有些拷贝行为需要特殊处理，不能默认。</p></li><li><p>定义了析构函数，意味着申请了额外的资源，需要如何拷贝、如何移动，编译器不知道，是不会提供默认的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第八课 多态</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%85%AB%E8%AF%BE%20%E5%A4%9A%E6%80%81/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%85%AB%E8%AF%BE%20%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669701732876-dce5c5f5-842c-46a7-a14e-e62d73da4ac5.png" alt="image.png"></p><h2 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h2><ol><li>OO程序设计 - 虚函数：是运行时的多态，是动态绑定的，具体引用只能在运行时确定</li><li>函数重载：一名多用，是静态的多态，在编译时就能确定</li><li>类属多态：通过泛型编程<code>template</code>，传入不同类型，复用同一段代码</li></ol><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669701998839-14770e03-ab97-4923-b316-2b0614d74dfd.png" alt="image.png"></p><ol><li>首先进行名空间的匹配</li><li>再进程参数匹配</li><li>所以不会进行返回值的匹配</li><li>由<code>Compiler</code>和<code>Linker</code>共同决定</li></ol><h4 id="歧义控制"><a href="#歧义控制" class="headerlink" title="歧义控制"></a>歧义控制</h4><ul><li>顺序</li><li>更好匹配</li><li>窄转换</li></ul><ol><li>参数的个数和被调函数相等</li><li>参数类型可以匹配、隐式转换</li><li>如果没有一模一样的函数签名：找到最佳匹配函数。<ol><li>参数double、float，传入的是int</li></ol></li></ol><p>有一个实参的匹配比其他参数更好，其他实参不比其他参数差</p><ul><li>完全匹配</li><li>整形提升：bool转化为int，是更好的</li><li>标准转化之前没有优劣比较，char 到unsigned char 和char 到double的匹配，一视同仁</li></ul><p>窄转换：</p><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669702437333-0f13555b-3495-4bdf-9add-be514e2db853.png" alt="image.png"><br>操作符重载就是函数重载<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669702718765-9df7c9d2-389a-4f5b-8d52-86991ca130a3.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669703230947-f32bb687-674c-4204-b949-35543af0bd52.png" alt="image.png"><br>在成员函数中，不需要强调自定义类型，因为<code>this</code>代表的就是自定义的类型<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669703911201-c8d8e5a1-e56c-40b9-98dd-513e7fb950d8.png" alt="image.png"></p><h4 id="不可重载"><a href="#不可重载" class="headerlink" title="不可重载"></a>不可重载</h4><p><code>.</code>成员访问操作符<br /><code>.*</code>成员指针访问运算符<br />防止访问成员的功能被改变<br /><code>::</code>域操作符<br /><code>?:</code>条件操作符<br />存在跳转的功能，本身是控制流程的作用，操作符重载是函数调用，进行函数调用的过程中，所有的代码都要被执行，无法实现跳转。如果重载后，和语义有偏差，因此不能重载<br /><code>sizeof</code>参数是类型，不是变量或表达式，因此不能重载</p><h3 id="双目操作符"><a href="#双目操作符" class="headerlink" title="双目操作符"></a>双目操作符</h3><h4 id="类成员函数重载"><a href="#类成员函数重载" class="headerlink" title="类成员函数重载"></a>类成员函数重载</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669705399777-0c00bc6b-e929-464b-ad5e-9340a24dc27c.png" alt="image.png"><br>第一个参数默认为<code>this</code>，必须为自定义类型</p><h4 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669705364265-8398f5ea-0c20-4bcc-ab8c-e0fd4726cabf.png" alt="image.png"><br><code>=</code>赋值运算符<code>()</code>函数调用运算符</p><ul><li><code>[]</code>下标运算符<code>-&gt;</code>间接访问操作符：有特定的顺序，先对对象进行操作，再根据对象操作参数。但是全局函数重载无法保证顺序，所以不能全局函数重载</li><li>操作符的第一个参数不是自定义类型本身</li><li>遵守交换律</li><li>单目操作符没有意义使用全局函数，单目操作符都可以作为类的成员函数进行重置</li></ul><h4 id="全局函数-x2F-成员函数的选择"><a href="#全局函数-x2F-成员函数的选择" class="headerlink" title="全局函数&#x2F;成员函数的选择"></a>全局函数&#x2F;成员函数的选择</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669706144754-84e6af3f-bd44-40b0-9972-5c1cc9157d3b.png" alt="image.png"></p><ul><li>第一个参数是自定义对象：使用成员函数</li><li>需要支持交换律：使用全局函数进行补充</li></ul><ol><li>单目运算符+只能声明为成员函数的（其他的都用全局函数）：作为类的成员函数</li><li>双目运算符：作为类的友元函数</li><li>类型转换函数、操作符修改状态时：定义为成员函数</li><li>第一个参数有隐式类型转换：定义为友元函数，因为成员函数需要精准匹配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CL</span>&#123;</span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CL</span>(<span class="type">int</span> i)&#123;...&#125;<span class="comment">//可以进行隐式类型转换</span></span><br><span class="line"><span class="keyword">friend</span> CL <span class="keyword">operator</span>+(<span class="type">int</span> i,CL&amp;a);</span><br><span class="line"><span class="keyword">friend</span> CL <span class="keyword">operator</span>+(CL&amp;a,<span class="type">int</span> i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="永远不要重载-amp-amp-和"><a href="#永远不要重载-amp-amp-和" class="headerlink" title="永远不要重载 &amp;&amp; 和 ||"></a>永远不要重载 &amp;&amp; 和 ||</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669706610099-ec843e63-a3bf-4908-8c03-bed79575b34d.png" alt="image.png"><br>第一行<code>if</code>借用了短路，如果重载，就是函数调用，如第3行和第4行<code>if</code>，两个参数都会运算，改变了短路行为，会出错</p><h4 id="不要过度追求效率？？"><a href="#不要过度追求效率？？" class="headerlink" title="不要过度追求效率？？"></a>不要过度追求效率？？</h4><p>直接返回对象的拷贝。</p><ul><li><ul><li><ul><li><ul><li>&#x2F; 直接返回对象的拷贝，效率不是很高，可以对于需要拷贝的进行<strong>返回值优化。不要一开始创建tmp对象，最后在</strong><code>**return**</code><strong>时创建tmp对象，直接返回，避免拷贝，优化代码</strong></li></ul></li></ul></li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669707418198-37aa04ec-6489-4f4f-905c-faf57fabe122.png" alt="image.png"></p><h3 id="单目操作符"><a href="#单目操作符" class="headerlink" title="单目操作符"></a>单目操作符</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669707675609-437d7c38-1a54-434f-b7ff-dffcf7ffd7fd.png" alt="image.png"><br><code>a++</code>返回的是左值a &#x3D; a + 1 <br /><code>++a</code>返回的是右值 a+1<br />如何确定重载的是a++还是++a<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669707876149-4560a6e5-31c9-4d1f-ab99-579613dbcbad.png" alt="image.png"><br><code>int</code>作用</p><ol><li>区分函数：签名不同，函数名相同才可以重载</li><li><code>int</code>是哑元，不在函数中参与运行</li></ol><p><code>return``*this</code>返回当前对象</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669705624351-75232bdc-ce71-42f7-936c-4f97f2652e20.png" alt="image.png"><br><code>&lt;&lt;</code>两个参数：双目操作符的重载<br />为什么要return <code>ostream</code>的对象？支持链式调用<code>cout &lt;&lt;d1&lt;&lt;</code></p><h2 id="特殊操作符的重载"><a href="#特殊操作符的重载" class="headerlink" title="特殊操作符的重载"></a>特殊操作符的重载</h2><h3 id="操作符-x3D-的重载"><a href="#操作符-x3D-的重载" class="headerlink" title="操作符 &#x3D; 的重载"></a>操作符 &#x3D; 的重载</h3><ol><li>默认赋值操作符重载函数</li><li>逐个成员赋值</li><li>对含有对象成员的类，该定义是递归的</li><li>赋值操作符的重载不可以被继承：因为拷贝构造，派生出来的类有一些新的部分</li><li>返回引用类型:<strong>返回*this的引用，支持链式赋值</strong></li><li>this引用应该是<strong>非常量引用</strong>，返回出来的是作为右值进行计算<ol><li>a &#x3D; b &#x3D; c:不要求非常量引用</li><li>(a &#x3D; b).f():要求非常量引用</li></ol></li><li>例一:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line">A b;</span><br><span class="line">A a = b;<span class="comment">//对a调用拷贝构造函数(更重要的是构造，在构造对象时候调用，再进行赋值)</span></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">// 第2 3 行代码等价</span></span><br><span class="line"><span class="comment">// 先调用构造函数再调用赋值操作符函数，效率比直接调用拷贝构造函数低</span></span><br><span class="line"></span><br><span class="line">A a,b; <span class="comment">// 对a调用构造函数，因为调用过构造函数了，所以不能再调用拷贝构造函数了</span></span><br><span class="line">a = b;<span class="comment">// 对a调用赋值操作符重载函数</span></span><br></pre></td></tr></table></figure>区分：<strong>判断被赋值的对象a有没有被构造过</strong></li></ol><ul><li>已经被构造过，调用赋值操作符重载函数</li><li>未被构造过，调用拷贝构造函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">operator</span> = (<span class="type">const</span> A&amp;)&#123;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 方便链式调用等号</span></span><br><span class="line">    <span class="comment">// 返回值可以做左值，也可以做右值。通过小括号改变优先级。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x,y ;</span><br><span class="line">    <span class="type">char</span> *p ; <span class="comment">// 额外申请的内存块，赋值的时候需要先释放</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">char</span> *s):<span class="built_in">x</span>(i),<span class="built_in">y</span>(j)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s)+ <span class="number">1</span> ];</span><br><span class="line">            <span class="built_in">strcpy</span>(p,s);<span class="comment">//进行拷贝，最后留一个\0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] p;</span><br><span class="line">        &#125;</span><br><span class="line">        A&amp; <span class="keyword">operator</span> = (A&amp; a) &#123;</span><br><span class="line">            <span class="comment">//赋值</span></span><br><span class="line">            x = a.x;</span><br><span class="line">            y = a.y;</span><br><span class="line">            <span class="keyword">delete</span> []p; <span class="comment">// 防止内存泄漏</span></span><br><span class="line">            <span class="comment">// 1.如果自我赋值，会出错</span></span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a.p)+<span class="number">1</span>]; <span class="comment">// 重新开辟新的内存</span></span><br><span class="line">            <span class="comment">// 2.如果资源没有了 new char 会抛出异常，对象构造失败了，但是p已经被</span></span><br><span class="line">            <span class="comment">// 删掉了，对象本身存在，但是p被delete调了。</span></span><br><span class="line">            <span class="comment">// 指针还在，指针的内存已经没了，出现指针悬垂问题</span></span><br><span class="line">            <span class="built_in">strcpy</span>(p,a.p);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//也会出现悬垂</span></span><br><span class="line">        &#125;<span class="comment">//还有问题，就是赋值自身会出现问题</span></span><br><span class="line">&#125;;</span><br><span class="line">A a, b;</span><br><span class="line">a = b;<span class="comment">//调用自己的复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//idle pointer，B被析构的时候会将p释放掉，导致p指向已经被释放掉的指针</span></span><br><span class="line"><span class="comment">//Memory leak,A申请的区域可能没有办法被释放</span></span><br></pre></td></tr></table></figure>资源拷贝：<strong>先申请，再删除</strong><br /><strong>解决方法：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更安全的拷贝，先new再delete</span></span><br><span class="line"><span class="type">char</span> *pOrig = p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">char</span> ...</span><br><span class="line"><span class="built_in">strcpy</span>();</span><br><span class="line"><span class="keyword">delete</span> pOrig;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//自我赋值可以吗？可以，换了一块内存空间，没有内存泄露</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>注意:避免自我赋值(因为是相同的内存地址)<ol><li>Sample: class string</li><li>s &#x3D; s<ol><li><code>class &#123;... A void f(A&amp; a);...&#125;</code></li><li><code>void f (A&amp; a1, A&amp; a2)</code></li><li><code>int f2(Derived &amp;rd,Base&amp; rb);</code></li></ol></li></ol></li></ol><p>额外检测：<strong>证同测试</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;a)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 不需要赋值了</span></span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//48min - 50min</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Object identity<ol><li>Content</li><li>Same memory location</li><li>Object identifier<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ObjectID <span class="title">identity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;; </span><br><span class="line">A *p1,*p2; </span><br><span class="line">p1-&gt; <span class="built_in">identity</span>() == p2-&gt; <span class="built_in">identity</span>()</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="操作符-的重载"><a href="#操作符-的重载" class="headerlink" title="操作符[]的重载"></a>操作符[]的重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">string</span>(<span class="type">char</span> *p1)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span> [<span class="built_in">strlen</span>(p1)+ <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(p,p1);<span class="comment">//#pragma warning(disable:4996)来屏蔽问题</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 参数是this、i</span></span><br><span class="line">        <span class="type">char</span>&amp; <span class="keyword">operator</span>[] (<span class="type">int</span> i)&#123; <span class="comment">// 可以声明为常成员函数：兼容常量类型string</span></span><br><span class="line">            <span class="keyword">return</span> p[i];  <span class="comment">//p[i] = *(p+i)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 精确匹配高于类型转化</span></span><br><span class="line"><span class="comment">// 参数是 const this、i</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以用两个重载函数吗?是可以的</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">string</span>() &#123; <span class="keyword">delete</span>[] p ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;aacd&quot;</span>)</span></span>;</span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span> ; <span class="comment">// 是可以的，只会调用第一个，因为是精确匹配的</span></span><br><span class="line"><span class="comment">//第一个重载加上const可以使得const或者非const对象都可以调用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">cs</span><span class="params">(<span class="string">&#x27;const&#x27;</span>)</span></span>; <span class="comment">//只能调用常成员函数</span></span><br><span class="line">cout &lt;&lt; cs[<span class="number">0</span>];</span><br><span class="line">cs[<span class="number">0</span>] = <span class="string">&#x27;D&#x27;</span>; <span class="comment">// 如果没有第二个重载，则无法阻止这一行为</span></span><br><span class="line"><span class="comment">//const 版本不想被赋值(返回const的)，</span></span><br><span class="line"><span class="comment">// 非const版本想要被赋值，之后再进行重载的时候就需要同时重载两个</span></span><br></pre></td></tr></table></figure><h4 id="多维数组-class-Array2D"><a href="#多维数组-class-Array2D" class="headerlink" title="多维数组 class Array2D"></a>多维数组 class Array2D</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array2D</span>(<span class="type">int</span> l, <span class="type">int</span> c):<span class="built_in">n1</span>(l),<span class="built_in">n2</span>(c)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">int</span>[n1*n2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123; <span class="keyword">delete</span>[] p; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp; <span class="title">Array2D::getElem</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">//上面是实现高维数组</span></span><br><span class="line"><span class="function">Array2D <span class="title">data</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">data.<span class="built_in">getElem</span>(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//target -&gt; data[1][2]</span></span><br><span class="line"><span class="comment">//想法:化解为两次调用</span></span><br><span class="line">data.<span class="keyword">operator</span>[](<span class="number">1</span>)[<span class="number">2</span>];<span class="comment">//int *operator[](int i) 一次偏移一行，转化成Array1D</span></span><br><span class="line">data.<span class="keyword">operator</span>[](<span class="number">1</span>).<span class="keyword">operator</span>[](<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">//问题:三维数组重载问题:重载一次降维一次，3D-&gt;2D等等，多个依次进行重载，重载之后返回对象</span></span><br><span class="line"><span class="comment">//代理对象:Array1D</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Array1D</span>&#123;</span><br><span class="line">    <span class="type">int</span> *q;<span class="comment">//一维降低到int *就行</span></span><br><span class="line">    <span class="built_in">Array1D</span>(<span class="type">int</span> *p)&#123; q = p; &#125;</span><br><span class="line">    <span class="type">int</span>&amp;  <span class="keyword">operator</span>[](j)&#123;</span><br><span class="line">        <span class="keyword">return</span> q[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data[1][3]</code></p><ul><li>使用二级指针：浪费空间，多次寻址</li><li>先解析第一个<code>[]</code>：告诉量的偏移应该是如何的。再解析第二个<code>[]</code></li></ul><p><code>int *operator[](int i)</code>是有默认定义的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Array1D</span>&#123;<span class="comment">//Surrogate 多维，proxy class 访问代理类，对于其他外部类没有作用</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="built_in">Array1D</span>(<span class="type">int</span> *p) &#123; <span class="keyword">this</span>-&gt;p = p; &#125; </span><br><span class="line"><span class="comment">// 构造函数中只有一个参数，可以允许该参数类型转化到该类</span></span><br><span class="line">                <span class="type">int</span>&amp; <span class="keyword">operator</span>[] (<span class="type">int</span> index) &#123; <span class="keyword">return</span> p[index]; &#125;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> <span class="keyword">operator</span>[ ] (<span class="type">int</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> p[index]; &#125;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">Array2D</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">int</span>[n1 * n2];</span><br><span class="line">            num1 = n1;</span><br><span class="line">            num2 = n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] p;</span><br><span class="line">        &#125;</span><br><span class="line">        Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">return</span> p + index * num2; <span class="comment">//通过偏移量寻找</span></span><br><span class="line">            <span class="comment">//return的值和int*相同，构造函数不能声明成显式构造函数。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里为什么是array1D?通过构造函数进行类型转换</span></span><br><span class="line">        <span class="type">const</span> Array1D <span class="keyword">operator</span>[] (<span class="type">int</span> index) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p+index*num2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>explicit</code>不能执行隐式类型转化，只能显式调用</li></ul><h3 id="操作符（）的重载"><a href="#操作符（）的重载" class="headerlink" title="操作符（）的重载"></a>操作符（）的重载</h3><ul><li><p>函数调用</p></li><li><p>类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    <span class="type">double</span> para;</span><br><span class="line">    <span class="type">int</span> lowerBound , upperBound ;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Func f; <span class="comment">// 函数对象：可以作为参数传递到其他函数</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2.4</span>, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array2D</span>(<span class="type">int</span> l, <span class="type">int</span> c):<span class="built_in">n1</span>(l),<span class="built_in">n2</span>(c)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">int</span>[n1*n2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (p+i*n2)[j];<span class="comment">//优化getElement</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>函数指针：在没有全局变量下，给定一个参数，返回值是确定的</p></li><li><p>函数对象：对象是有状态的，可以作为泛型算法的实参</p></li></ul><h3 id="类型转换运算符-重载"><a href="#类型转换运算符-重载" class="headerlink" title="类型转换运算符()重载"></a>类型转换运算符()重载</h3><ol><li>基本数据类型</li><li>自定义类</li></ol><p>减少自定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="built_in">Rational</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) &#123;</span><br><span class="line">        n = n1;</span><br><span class="line">        d = n2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 由类型名称决定返回值类型，从而区分函数调用操作符</span></span><br><span class="line"><span class="comment">// 类型转化不能作为全局函数 -- 主体是本类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123;  <span class="comment">//类型转换操作符，语法特殊。</span></span><br><span class="line">        <span class="comment">// 不能使用哑元，因为函数调用的参数个数是不确定的</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)n/d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> n, d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减少混合计算中需要定义的操作符重载函数的数量</span></span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> x = r;</span><br><span class="line">x = x + r;<span class="comment">//避免的double 和 rational 的全局函数重载，会自动全部转换为double</span></span><br></pre></td></tr></table></figure><ul><li><code>=</code>不能全局重载，<strong>由于优先在类内匹配，首先匹配到的是编译器提供的默认版本</strong></li><li><code>[]</code>不能全局重载</li><li>类型转化不能全局重载<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//48min</span></span><br><span class="line"><span class="function">ostream <span class="title">f</span><span class="params">(<span class="string">&quot;abc.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="comment">//重载  数值型：如 int</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="gt-指针间接引用操作符重载"><a href="#gt-指针间接引用操作符重载" class="headerlink" title="-&gt; 指针间接引用操作符重载"></a>-&gt; 指针间接引用操作符重载</h3><p>箭头操作符一般声明为const成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.<span class="built_in">f</span>();</span><br><span class="line">a-&gt;<span class="built_in">f</span>();</span><br><span class="line">a.<span class="keyword">operator</span>-&gt;(f)</span><br><span class="line">a.<span class="keyword">operator</span>-&gt;()-&gt;<span class="built_in">f</span>() </span><br><span class="line">    <span class="comment">//重载时按一元操作符重载描述,这时，</span></span><br><span class="line">    <span class="comment">// a.operator-&gt;() 返回一个指针(或者是已经重定义过-&gt;的对象)</span></span><br><span class="line">    <span class="comment">// 返回支持箭头操作符的值</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPen</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_color;</span><br><span class="line">    <span class="type">int</span> m_width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">int</span> c)</span></span>&#123; m_color = c;&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m_width; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPanel</span> &#123;</span><br><span class="line">    CPen m_pen;</span><br><span class="line">    <span class="type">int</span> m_bkColor;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">CPen* <span class="title">getPen</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> &amp;m_pen;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setBkColor</span><span class="params">(<span class="type">int</span> c)</span></span>&#123; m_bkColor =c;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">CPanel c;</span><br><span class="line">c.<span class="built_in">getPen</span>()-&gt;<span class="built_in">setColor</span>(<span class="number">16</span>); <span class="comment">// 按照名称获得成员变量</span></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//简单修改，可以返回一个对象内部对象的指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPen</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_color;</span><br><span class="line">    <span class="type">int</span> m_width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">int</span> c)</span></span>&#123; m_color = c;&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_width; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPanel</span> &#123;</span><br><span class="line">    CPen m_pen;</span><br><span class="line">    <span class="type">int</span> m_bkColor;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CPen* <span class="keyword">operator</span> -&gt;()&#123; <span class="keyword">return</span> &amp;m_pen;&#125;</span><br><span class="line">        <span class="function">CPen* <span class="title">getPen</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> &amp;m_pen;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setBkColor</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123; m_bkColor =c;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">CPanel c;</span><br><span class="line">c-&gt;<span class="built_in">setColor</span>(<span class="number">16</span>); <span class="comment">// 可以当成CPen指针使用</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//c.operator-&gt;()-&gt;setColor(16);</span></span><br><span class="line"><span class="comment">//c.m_pen.setColor(16)</span></span><br><span class="line">c-&gt;<span class="built_in">getWidth</span>();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//c.operator-&gt;()-&gt;getWidth();</span></span><br><span class="line"><span class="comment">//c.m_pen.getWidth()</span></span><br><span class="line">CPanel *p=&amp;c;</span><br><span class="line">p-&gt;<span class="built_in">setBkColor</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>名称是不能重载的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">if</span>(...)&#123;<span class="keyword">return</span> ...&#125;</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();<span class="comment">//如果出错可能会导致问题</span></span><br><span class="line">    p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);<span class="comment">//返回值</span></span><br><span class="line">    p-&gt;<span class="built_in">h</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 不一定会执行到该处，是多出口函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//更好的管理A对象，不用在任何退出的地方写delete p</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">AWrapper <span class="title">p</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();<span class="comment">//如果出错可能会导致问题</span></span><br><span class="line">    p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);<span class="comment">//返回值</span></span><br><span class="line">    p-&gt;<span class="built_in">h</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="comment">// 对象的消亡就是资源的释放，资源和栈上的对象同声明周期了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//须符合compiler控制的生命周期</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AWrapper</span>&#123;<span class="comment">//不包含逻辑</span></span><br><span class="line">    A* p;<span class="comment">// ? T p; 支持多个类型</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AWrapper</span>(A *p) &#123; <span class="keyword">this</span>-&gt;p = p;&#125;</span><br><span class="line">        ~<span class="built_in">AWrapper</span>() &#123; <span class="keyword">delete</span> p;&#125;</span><br><span class="line">        A*<span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> p;&#125; <span class="comment">// 不需要管是对象还是指针了</span></span><br><span class="line">&#125;;<span class="comment">//RAII 资源获取及初始化</span></span><br><span class="line"><span class="comment">//函数返回，销毁局部指针的时候会直接删除</span></span><br></pre></td></tr></table></figure>RAII：资源和对象绑定</li></ul><ol><li>是可控的管理：申请资源和释放资源的时间点都是确定的</li><li>让资源和栈上的对象同生命周期，确保资源释放且只被释放一次</li></ol><p>重载指针可以让对象p看起来和裸指针一样，不需要管是对象还是指针了<br />局限性：封装的资源必须和函数同生命周期了</p><h3 id="new-x2F-delete-的重载"><a href="#new-x2F-delete-的重载" class="headerlink" title="new&#x2F;delete 的重载"></a>new&#x2F;delete 的重载<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670482300611-eb3bf5ed-0e63-4197-b3dd-c700e0a9fffd.png" alt="image.png"></h3><h4 id="重载-new"><a href="#重载-new" class="headerlink" title="重载 new"></a>重载 new</h4><ol><li><code>void *operator new (size_t size, s...)</code></li><li>名:<code>operator new</code></li><li>返回类型:void *</li><li>第一个参数:<code>size_t(unsigned int)</code><ul><li>系统自动计算对象的大小，并传值给size</li></ul></li><li>其他参数:可有可无<ul><li><code>A *p = new (...) A</code>，表示传给new的</li></ul></li><li>new的重载可以有多种</li><li>如果重载一个new，那么通过new动态创建该类的对象时将不再调用内置的(预定义的)new</li><li>允许进行全局重载，但是不推荐使用全局重载</li></ol><p>![F)5I%]Q@IEKC~F%{M_KG12A.png](<a href="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670483573949-3fd16832-b4ce-4941-b674-d9abe3ab2a36.png">https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670483573949-3fd16832-b4ce-4941-b674-d9abe3ab2a36.png</a>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(base))</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span> (size);</span><br><span class="line"><span class="comment">//调用全局标准库的new进行size的分配，标准库的new永远是可以使用的</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> [];</span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size, <span class="type">void</span>*)</span><span class="comment">//是不可以被重载的，标准库版本，指定了对象创建的位置</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size, ostream &amp; log)</span></span>;<span class="comment">//可以同时写入到日志</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size, <span class="type">void</span> * pointer)</span></span>;</span><br><span class="line"><span class="comment">//定位new，placement new，被调用的时候，在指针给定的地方的进行new(可能预先已经分配好的)，</span></span><br><span class="line">分配比较快，长时间运行不被打断(不会导致内存不足)</span><br></pre></td></tr></table></figure><p>定位new <code>placement new</code>：控制了内存的分配<code>malloc</code></p><h4 id="重载-delete"><a href="#重载-delete" class="headerlink" title="重载 delete"></a>重载 delete</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670483765273-27d85d17-0cbe-41f1-864c-f68fcf6cd2ef.png" alt="image.png"></p><h3 id="返回值总结"><a href="#返回值总结" class="headerlink" title="返回值总结"></a>返回值总结</h3><ul><li>返回值是右值的按值传递</li><li>返回值是左值的按引用传递</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vector的使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Vector%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Vector%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>erase(pos)</td><td><strong>删除 vector 容器中 pos 迭代器指定位置处的元素</strong>，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>swap(beg)、pop_back()</td><td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。</td></tr><tr><td>erase(beg,end)</td><td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向<br /><strong>被删除区域下一个位置元素的迭代器</strong>。该容器的大小（size）会减小，但容量（capacity）不会发生改变。</td></tr><tr><td>remove()</td><td>删除容器中<strong>所有和指定元素值相等的元素</strong>，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</td></tr><tr><td>clear()</td><td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</td></tr></tbody></table><ul><li>通过 <strong>remove() 函数</strong>删除掉 demo 容器中的多个指定元素，该容器的大小和容量都没有改变，其剩余位置还保留了之前存储的元素。我们可以<strong>使用 erase() 成员函数删掉这些 “无用” 的元素</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">demo.<span class="built_in">erase</span>(iter, demo.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><ul><li>vector():创建一个空vector</li><li>vector(int nSize):创建一个vector,元素个数为nSize</li><li>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</li><li>vector(const vector&amp;):复制构造函数</li><li>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</li></ul><h3 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h3><ul><li>void push_back(const T&amp; x):向量尾部增加一个元素X</li><li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li><li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li><li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li></ul><h3 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h3><ul><li>iterator erase(iterator it):删除向量中迭代器指向元素</li><li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li><li>void pop_back():删除向量中最后一个元素</li><li>void clear():清空向量中所有元素</li></ul><h3 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h3><ul><li>reference at(int pos):返回pos位置元素的引用</li><li>reference front():返回首元素的引用</li><li>reference back():返回尾元素的引用</li><li>iterator begin():返回向量头指针，指向第一个元素</li><li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li><li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li><li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li></ul><h3 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h3><ul><li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li></ul><h3 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h3><ul><li>int size() const:返回向量中元素的个数</li><li>int capacity() const:返回当前向量所能容纳的最大元素值</li><li>int max_size() const:返回最大可允许的vector元素数量值</li></ul><h3 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h3><ul><li>void swap(vector&amp;):交换两个同类型向量的数据</li><li>void assign(int n,const T&amp; x):设置向量中前n个元素的值为x</li><li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li></ul><h3 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h3><p><em>1.push_back 在数组的最后添加一个数据</em><br /><em>2.pop_back 去掉数组的最后一个数据</em><br /><em>3.at 得到编号位置的数据</em><br /><em>4.begin 得到数组头的指针</em><br /><em>5.end 得到数组的最后一个单元+1的指针</em><br /><em>6．front 得到数组头的引用</em><br /><em>7.back 得到数组的最后一个单元的引用</em><br /><em>8.max_size 得到vector最大可以是多大</em><br /><em>9.capacity 当前vector分配的大小</em><br /><em>10.size 当前使用数据的大小</em><br /><em>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</em><br /><em>12.reserve 改变当前vecotr所分配空间的大小</em><br /><em>13.erase 删除指针指向的数据项</em><br /><em>14.clear 清空当前的vector</em><br /><em>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</em><br /><em>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</em><br /><em>17.empty 判断vector是否为空</em><br /><em>18.swap 与另一个vector交换数据</em></p><ul><li>sort(obj.begin(),obj.end());&#x2F;&#x2F;从小到大</li><li>reverse(obj.begin(),obj.end());&#x2F;&#x2F;从大到小</li></ul><p>1.注意 sort 需要头文件 <strong>#include <algorithm></strong><br />2.如果想 sort 来降序，可重写 sort<br />bool compare(int a,int b)  {      return a&lt; b; &#x2F;&#x2F;升序排列，如果改为return a&gt;b，则为降序  }  int a[20]&#x3D;{2,4,1,23,5,76,0,43,24,65},i;  for(i&#x3D;0;i&lt;20;i++)      cout&lt;&lt; a[i]&lt;&lt; endl;  sort(a,a+20,compare);</p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Set的使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Set%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Set%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span> &gt; seta; <span class="comment">//默认是小于比较器less&lt;int&gt;的set</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; setb; <span class="comment">//创建一个带大于比较器的set，需包含头文件functional</span></span><br><span class="line"></span><br><span class="line">set&lt;Food*,compare&gt; foodList; <span class="comment">//创建一个自定义排序方式的set</span></span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>set 是一个内部<strong>自动有序</strong>且不含重复元素的容器。</li><li>set 最主要的作用就是<strong>自动去重并按升序排序</strong>，适用于需要去重但是又不方便直接开数组的情况。</li><li>set 中的元素是唯一的，其内部采用“红黑树”实现。</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669900802886-60956efd-949a-48e1-b9b1-9a4c3680abf4.png" alt="image.png"></p><h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><ol><li><p>当<code>set</code>中存储的是对象指针时，不能使用重载<code>operator &lt;</code> 的方式实现，因为重载时需要使用的参数是引用，而不是指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Food&amp; ptr1,<span class="type">const</span> Food&amp; ptr2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr1.rating == ptr2.rating)&#123;</span><br><span class="line">            <span class="keyword">return</span> ptr1.foodName &lt; ptr2.foodName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1.rating &gt; ptr2.rating;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 无法对装入指针的容器起效</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重载运算符</strong><code>**()**</code><strong>，利用结构体</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">compare</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Food* ptr1,Food* ptr2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr1-&gt;rating == ptr2-&gt;rating)&#123;</span><br><span class="line">            <span class="keyword">return</span> ptr1-&gt;foodName &lt; ptr2-&gt;foodName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1-&gt;rating &gt; ptr2-&gt;rating;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">highestRated</span><span class="params">(string cuisine)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化set时，需要把比较运算符也作为参数</span></span><br><span class="line">    set&lt;Food*,compare&gt; foodList = cuisineToFood[cuisine];</span><br><span class="line">    <span class="keyword">return</span> (*foodList.<span class="built_in">begin</span>())-&gt;foodName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="返回最值"><a href="#返回最值" class="headerlink" title="返回最值"></a>返回最值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s的最小值:&quot;</span>&lt;&lt;*s.<span class="built_in">begin</span>()&lt;&lt;endl;<span class="comment">//第一个数值（最小值）的函数为*s.begin();</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s的最大值为:&quot;</span>&lt;&lt;*s.<span class="built_in">rbegin</span>()&lt;&lt;endl;<span class="comment">//最后一个数值（最大值）的函数为*s.rbegin();</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>注：*s.end()返回的是set容器的最后一个元素(应该是s的长度)，而不是s队列中的最后一个元素，就是说返回的不是最大值。</li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><code>s.lower_bound()</code> 返回第一个<strong>大于或等于</strong>给定关键值的元素<br /><code>s.upper_bound()</code> 返回第一个<strong>大于</strong>给定关键值的元素<br /><code>s.equal_range() </code>返回一对定位器，分别表示 第一个大于或等于给定关键值的元素 和 第一个大于给定关键值的元素，这个返回值是一个pair类型，如果这一对定位器中哪个返回失败，就会等于s.end()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower_bound &amp; upper_bound test:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于或等于3的元素: &quot;</span> &lt;&lt; *s.<span class="built_in">lower_bound</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于或等于2的元素: &quot;</span> &lt;&lt;*s.<span class="built_in">lower_bound</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于2的元素: &quot;</span> &lt;&lt;*s.<span class="built_in">upper_bound</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;equal_range test:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于或等于2的元素: &quot;</span> &lt;&lt;  *s.<span class="built_in">equal_range</span>(<span class="number">2</span>).first &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于2的元素: &quot;</span> &lt;&lt; *s.<span class="built_in">equal_range</span>(<span class="number">2</span>).second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Priority_queue的使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>排序思路不同<code>&lt;</code>代表的是大顶堆，<strong>因为如果小于为true，则代表小的元素会下浮</strong>，那么大的就会在堆顶，而<code>&gt;</code>代表的是小顶堆，是因为<strong>大的元素下浮了</strong> </li><li>C++中，使用优先级队列需要包含头文件<queue></li><li>不会自动排序。如果修改了优先级队列中某元素的值，则需要重新排序。因此，需要删除特定元素时，使用<code>set</code>更好</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>priority_queue&lt;typename, container, functional&gt;</code></p><ul><li>typename是数据的类型；</li><li>container是容器类型，可以是vector,queue等用数组实现的容器，不能是list，默认可以用vector；</li><li>functional是比较的方式，默认是大顶堆（就是元素值越大，优先级越高）；如果使用C++基本数据类型，可以直接使用自带的less和greater这两个仿函数（默认使用的是less，就是构造大顶堆，元素小于当前节点时下沉）。使用自定义的数据类型的时候，可以重写比较函数，也可以进行运算符重载（less重载小于“&lt;”运算符，构造大顶堆；greater重载大于“&gt;”运算符，构造小顶堆）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个大顶堆，堆中小于当前节点的元素需要下沉，因此使用less</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; priQueMaxFirst;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造一个小顶堆，堆中大于当前节点的元素需要下沉，因此使用greater</span></span><br><span class="line">priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt; priQueMinFirst;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><ol><li><p>重载运算符<code>()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义数据类型，Data类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>(<span class="type">int</span> i, <span class="type">int</span> d) :<span class="built_in">id</span>(i), <span class="built_in">data</span>(d) &#123;&#125;</span><br><span class="line">~<span class="built_in">Data</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重写仿函数，完成less的功能，也可以用class定义类，此时需要将运算符重载函数设为public</span></span><br><span class="line"><span class="comment">//结构体struct中默认是访问类型是public</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>    </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( Data &amp;a, Data &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.<span class="built_in">getId</span>() &lt; b.<span class="built_in">getId</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;Data, vector&lt;Data&gt;, cmp &gt; priQueMaxFirst;<span class="comment">//该优先级队列维护一个大顶堆，因此最大的元素最先出队</span></span><br><span class="line">    ...<span class="comment">//一系列操作</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>重载运算符<code>&lt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载“&lt;”运算符，仿函数less中需要使用</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Data &amp;a, <span class="type">const</span> Data &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;Data, vector&lt;Data&gt;, less&lt;Data&gt; &gt; priQueMaxFirst;<span class="comment">//该优先级队列维护一个大顶堆，因此最大的元素最先出队</span></span><br><span class="line">    ...<span class="comment">//一系列操作</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><p>优先级队列的基本操作与普通队列类似，不同的是每次获得队内的元素是优先级最高的元素（要从堆的顶部开始），因此使用的是top()方法，而不是front()方法。如下：</p><ul><li>push() ：入队。向队列添加一个元素，无返回值；</li><li>pop() ：将队列中优先级最高的元素出队。将队列中优先级最高的元素删除（出队），<strong>无返回值</strong>；</li><li>top() ：获得队列优先级最高的元素。此函数返回值为队列中优先级最高的元素，常与pop()函数一起，先通过top()获得队列中优先级最高的元素，然后将其从队列中删除；</li><li>size() ：获得队列大小。此函数返回队列的大小，返回值是“size_t”类型的数据，“size_t”是“unsigned int”的别名。</li><li>empty() ：判断队列是否为空。此函数返回队列是否为空，返回值是bool类型。队列空：返回true；不空：返回false</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第九课 模板</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B9%9D%E8%AF%BE%20%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B9%9D%E8%AF%BE%20%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="类属函数-templat-function"><a href="#类属函数-templat-function" class="headerlink" title="类属函数 templat function"></a>类属函数 templat function</h2><ol><li>同一函数对不同类型的数据完成相同的操作</li><li>宏实现:<ol><li>#define max(a,b) ((a)&gt;(b)?(a):(b))</li><li>缺陷:<ol><li>只能实现简单的功能</li><li>没有类型检查</li></ol></li></ol></li></ol><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">max</span><span class="params">(A,A)</span> </span>;</span><br></pre></td></tr></table></figure><ol><li>缺陷:<ol><li>需要定义的重载函数太多</li><li>定义不全</li></ol></li><li>不可以只有返回值不同</li></ol><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">void</span> * , <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">int</span> (* cmp) (<span class="type">void</span> *, <span class="type">void</span> *) )</span></span></span><br></pre></td></tr></table></figure><ol><li>缺陷:<ol><li>需要定义额外参数</li><li>大量指针运算</li><li>实现起来复杂</li><li>可读性差</li></ol></li><li>template更加结构清晰，实现简单</li></ol><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int和double都可以使用，编译器编译的并不是之下的代码，而是T转化成具体代码，然后分别编译</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> A[], <span class="type">unsigned</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt; num - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>  (A[j] &gt; A[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                T t = A[j];</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;...&#125;</span><br><span class="line">C a[<span class="number">300</span>];</span><br><span class="line"><span class="built_in">sort</span>(a, <span class="number">300</span>);<span class="comment">//没有重载&gt;</span></span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>必须重载操作符 &gt;</li><li>函数模板定义了一类重载的函数</li><li>函数模板的实例化:<ol><li><strong>隐式实现</strong></li><li>根据具体模板函数调用</li></ol></li><li>函数模板的参数<ol><li>可有多个类型参数，用逗号分隔</li><li>可带普通参数<ul><li><strong>必须列在类型参数之后</strong></li><li>调用时需显式实例化，使用默认参数值可以不显式实例化</li><li>可以有默认值</li></ul></li></ol></li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670912436040-4e4ba3c9-1c05-474b-a92d-8c4f2a23ee23.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T1 a, T2 b)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a)</span> </span>&#123;T temp[size];&#125;</span><br><span class="line"><span class="built_in">f</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol><li>函数模板与函数重载配合使用(编译器优先使用没有使用模板的函数)</li><li>优先匹配重载函数，再继续调用函数的显式、具体化的版本、再调用函数模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"><span class="type">double</span> l, m, n;</span><br><span class="line">z = <span class="built_in">max</span>(x,y);</span><br><span class="line">l = <span class="built_in">max</span>(m,n);</span><br><span class="line"><span class="comment">//为了解决max(x,m)我们使用函数重载更新，优先调用</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="类属类"><a href="#类属类" class="headerlink" title="类属类"></a>类属类</h2><p><code>min</code></p><ol><li><p>类定义带有类型参数，类属类需要显式实例化</p></li><li><p>类模板中的静态成员属于实例化后的类</p></li><li><p>类模板的实例化:创建对象时显式指定，指明类型参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="type">int</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span>  x)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::pop</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">Stack st1;</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    T buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( T x)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明T是类型参数 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">// &lt;T&gt; 用一个具体类型去实例化的stack，&lt;&gt;是用来区分不同类型的</span></span><br><span class="line"><span class="type">void</span> Stack &lt;T&gt; ::<span class="built_in">push</span>(T x) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装double的push和装int的push不是同一个push</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Stack &lt;T&gt; ::<span class="built_in">pop</span>() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如下是显式实例化</span></span><br><span class="line">Stack &lt;<span class="type">int</span>&gt; st1;</span><br><span class="line">Stack &lt;<span class="type">double</span>&gt; st2;</span><br></pre></td></tr></table></figure><p>类模板中的静态成员属于实例化后的类，不是属于模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    T buffer[size];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T x)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="type">void</span> Stack &lt;T, size&gt;::<span class="built_in">push</span>(T x) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line">T Stack &lt;T, size&gt;::<span class="built_in">pop</span>() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">Stack &lt;<span class="type">int</span>, <span class="number">100</span> &gt; st1 ;</span><br><span class="line"><span class="comment">//上面改为template&lt;class T = int,int size = 100&gt;</span></span><br><span class="line"><span class="comment">// 这里可以改成stack&lt;&gt; st1用来显示实例化</span></span><br><span class="line">Stack &lt;<span class="type">double</span>, <span class="number">200</span> &gt; st2 ;</span><br></pre></td></tr></table></figure></li><li><p>类型参数也可以给出初始值，模板类如果不按照从右往左指定默认值参数，会导致编译错误</p></li><li><p>函数模板的默认值不一定是从右向左的，C++11之后函数模板才接受默认值参数。</p></li><li><p>总而言之从右向左给出默认值总是没有问题的</p></li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670913607590-d14aeb1e-9ee2-4089-8cc9-7ef73da0e621.png" alt="image.png"></p><ol><li>如果在模块A中要使用模块B中定义的某模板的实例，而在B中未使用这个实例，则模板无法使用这个实例</li><li>为什么<strong>C++中模板的完整定义常常出现在头文件中</strong>?<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    T a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file1.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> S&lt;T&gt;::<span class="built_in">f</span>()&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, T y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">max</span>(a,b);<span class="comment">//实例化函数模板</span></span><br><span class="line">    S&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">    x.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file1.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">max</span>(<span class="number">1.1</span>,<span class="number">2.2</span>);<span class="comment">//error</span></span><br><span class="line">    S&lt;<span class="type">float</span>&gt; x;</span><br><span class="line">    x.<span class="built_in">f</span>();<span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不能通过编译，为什么？file2.cpp找不到max定义，也找不到完整的S代码</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>因为编译器使用模板时，没有分配存储空间。只有实例化时，才会分配模板空间。所以，因为file1中没有实例化<code>float</code>的模板，因此<code>file2</code>中找不到。尝试自己实例化模板代码</li><li>但是，<code>file1</code>中只有声明，没有实现，因此无法实例化代码</li><li>所以<strong>C++中模板的完整定义常常出现在头文件中</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670914119949-75729499-ed11-49fd-b264-ff21204a92e7.png" alt="image.png"></p><h2 id="Template-MetaProgramming-元编程"><a href="#Template-MetaProgramming-元编程" class="headerlink" title="Template MetaProgramming 元编程"></a>Template MetaProgramming 元编程</h2><ol><li>元程序就是编写一些直接可以生成或者操作其他程序的程序，要在更高层次上。</li><li>编写元程序就是元编程(两级编程)，在编译的时候就已经完成编程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> &#123; value = Fib&lt;N - <span class="number">1</span>&gt;::value + Fib&lt;N - <span class="number">2</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板显式实例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;  <span class="comment">// 需要一个template&lt;&gt; 标明是特殊实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>&lt;<span class="number">1</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Fib&lt;<span class="number">8</span>&gt;::value &lt;&lt; endl;<span class="comment">// calculated at compile time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="易错"><a href="#易错" class="headerlink" title="易错"></a>易错</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i </span>= <span class="number">0</span>, <span class="keyword">typename</span> T = <span class="type">double</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">DefFunc2</span>(T a) &#123;</span><br><span class="line">    cout &lt;&lt; a + i &lt;&lt; endl;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DefFunc2</span>&lt;<span class="number">10</span>,<span class="type">double</span>&gt;(<span class="number">5.555</span>); <span class="comment">// 15.555</span></span><br><span class="line">    <span class="built_in">DefFunc2</span>(<span class="number">5</span>); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">DefFunc2</span>&lt;<span class="number">10</span>&gt;(<span class="number">5.6</span>); <span class="comment">// 5.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尖括号中的代表的是<strong>模板参数</strong>，圆括号中代表的是<strong>函数参数</strong></li><li>模板参数中，可以提供类型参数<code>typename T</code>，对类型<code>T</code>进行默认类型的指定<code>T = double</code>，也可以提供实际的参数<code>i</code>，提供默认值<code>i = 0</code></li></ul><hr><p>类模板：通用的类描述（使用泛型来定义类），进行实例化时，其中的泛型再用具体的类型替换。<br />函数模板：通用的函数描述（使用泛型来定义函数），进行实例化时，其中的泛型再用具体的类型替换。<br /><strong>如果能够从函数实参中推导出类型的话，那么默认模板参数就不会被使用，反之，默认模板参数则可能会被使用。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span> = <span class="type">double</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">f</span>(T t = <span class="number">0</span>, U u = <span class="number">0</span>) &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>); <span class="comment">// f&lt;int, char&gt;(1, &#x27;c&#x27;) 根据实参类型推出模板参数中T U分别代表了什么类型</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>);      <span class="comment">// f&lt;int, double&gt;(1, 0), 使用了默认模板参数double</span></span><br><span class="line">    <span class="built_in">f</span>();       <span class="comment">// 错误: T无法被推导出来</span></span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;();  <span class="comment">// f&lt;int, double&gt;(0, 0), 使用了默认模板参数double</span></span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;(); <span class="comment">// f&lt;int, char&gt;(0, 0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个函数模板<code>f</code>，<code>f</code>同时使用了默认模板参数和默认函数参数。<br />可以看到，由于<strong>函数的模板参数可以由函数的实参推导而出</strong>:<br />在f(1)这个函数调用中，实例化出了模板函数的调用应该为f&lt;int, double&gt;(1, 0)，其中，第二个类型参数U使用了默认的模板类型参数double，而函数实参则为默认值0。<br />类似地，f<int>()实例化出的模板函数第二参数类型为double，值为0。<br />而表达式f()由于第一类型参数T的无法推导，从而导致了编译的失败。<br />而通过这个例子也可以看到，默认模板参数通常是需要跟默认函数参数一起使用的。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="type">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R <span class="built_in">func</span>(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><code>func(97)</code>是根据函数的实参得出，val &#x3D; 97，因此<code>U</code>就是<code>int</code>，所以<code>R</code>就是默认值<code>int</code></li><li>此处同理可得<code>U</code>是<code>int</code>，但<code>&lt;&gt;</code>中有显式地指明了<code>char</code>，所以<code>R</code>就是<code>char</code>而不是默认值<code>int</code></li></ol><h3 id="报错1"><a href="#报错1" class="headerlink" title="报错1"></a>报错1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefFunc2</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a + i &lt;&lt; endl;</span><br><span class="line">&#125;;  <span class="comment">// OK 函数模板不用遵循“由右往左”的规则</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DefFunc2</span>&lt;<span class="number">10</span>,<span class="type">double</span>&gt;(<span class="number">5.555</span>); <span class="comment">// 15.555</span></span><br><span class="line">    <span class="built_in">DefFunc2</span>(<span class="number">5</span>); <span class="comment">// 报错了</span></span><br><span class="line">    <span class="built_in">DefFunc2</span>&lt;<span class="number">10</span>&gt;(<span class="number">5.6</span>); <span class="comment">// 5.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处第8行会报错，因为模板参数中<code>i</code>没有提供默认值了，所以需要显式的给出<code>i</code>的值</p><h3 id="报错2"><a href="#报错2" class="headerlink" title="报错2"></a>报错2</h3><p>类模板在为多个默认模板参数声明指定默认值时，必须遵照<strong>“从右往左”</strong>的规则进行指定。<br />而这个规则对函数模板来说并不是必须的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> DefClass1 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1 = <span class="type">int</span>, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> DefClass2 &#123;&#125;;  <span class="comment">// ERROR: 无法通过编译：因为模板参数的默认值没有遵循“由右往左”的规则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> i = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> DefClass3 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> i = <span class="number">0</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> DefClass4 &#123;&#125;;  <span class="comment">// ERROR: 无法通过编译：因为模板参数的默认值没有遵循“由右往左”的规则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1 = <span class="type">int</span>, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">DefFunc1</span>(T1 a, T2 b) &#123;&#125;; <span class="comment">// OK 函数模板不用遵循“由右往左”的规则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> i = <span class="number">0</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">DefFunc2</span>(T a) &#123;&#125;;  <span class="comment">// OK 函数模板不用遵循“由右往左”的规则</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1 </span>= <span class="type">int</span>, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefFunc3</span><span class="params">(T1 a = <span class="number">10</span>, T2 b)</span> </span>&#123;&#125;; <span class="comment">// ERROR: 函数参数需要遵循“由右往左”的规则</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="报错3"><a href="#报错3" class="headerlink" title="报错3"></a>报错3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="type">int</span> size = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line">T buffer[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> point;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Stack</span>() : <span class="built_in">point</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> size = <span class="number">0</span>&gt; <span class="comment">// 报错了</span></span><br><span class="line"><span class="type">void</span> Stack&lt;T, size&gt;::<span class="built_in">push</span>(T val) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="type">int</span> size&gt; <span class="comment">// 报错了</span></span><br><span class="line"><span class="type">void</span> Stack&lt;T, size&gt;::<span class="built_in">push</span>(T val) &#123;...&#125;</span><br></pre></td></tr></table></figure><ol><li>在类模板的<strong>外部定义</strong>类中的成员时template 后的形参表应**省略默认的形参类型 **<code>template&lt;typename T = int, int size&gt;</code></li><li>在类模板的<strong>外部定义</strong>类中的成员时template 后的形参表应<strong>省略默认的参数值</strong><code>template&lt;typename T, int size = 0&gt;</code></li></ol><p>正确的是<code>template&lt;typename T,int size&gt;</code></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>函数自身的默认参数需要遵循<strong>从右往左</strong>的原则</li><li>模板类中提供的默认参数需要遵循<strong>从右往左</strong>的原则</li><li>模板参数中提供的默认参数<strong>不需要</strong>遵循从右往左的原则</li><li>在类模板的<strong>外部定义</strong>类中的成员时template 后的形参表应<strong>省略默认的形参类型</strong></li><li>在类模板的<strong>外部定义</strong>类中的成员时template 后的形参表应<strong>省略默认的参数值</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十课 异常</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%8D%81%E8%AF%BE%20%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%8D%81%E8%AF%BE%20%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<ol><li>错误<ol><li>语法错误:编译系统</li><li>逻辑错误:测试</li></ol></li><li>异常 Exception<ol><li>运行环境造成:内存不足、文件操作失败等</li><li>异常处理:错误提示信息等</li></ol></li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li><p>特征：</p><ol><li>可以预见</li><li>无法避免</li></ol></li><li><p>作用:提高程序鲁棒性(Bobustness)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;<span class="comment">//str可能是用户的一个输入</span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    file &gt;&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>问题:发现异常之处与处理异常之处不一致，怎么处理?函数中的异常要告知调用者</p></li><li><p>常见处理方式:</p><ol><li>函数参数:<ul><li>返回值(特殊的，0或者1)</li><li>引用参数(存放一些特定的信息)</li></ul></li><li>逐层返回</li></ol></li><li><p>缺陷:</p><ol><li><strong>程序结构不清楚 什么时候是异常的返回值、什么时候是正常的返回值</strong></li><li>相同的异常，不同的地方，需要编写相同的处理了逻辑是不合理的</li><li>希望对异常进行集中的处理</li></ol></li><li><p>传统异常处理方式不能处理<strong>构造函数出现的异常   需要创建资源，会出现异常，但是没有返回值</strong></p></li></ol><br /><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><ol><li>C++异常处理机制是，一种专门、清晰描述异常处理过程的机制</li><li>try：监控</li><li>throw：抛掷异常对象，不处理</li><li>catch：捕获并处理</li></ol><p>关键点：<br />（1）throw是将抛出的表达式的值拷贝到“异常对象”中，catch则是根据异常对象进行参数匹配并处理异常；<br />（2）throw可<strong>一次性跳出多层函数调用</strong>，直到最近一层的try语句，称为<strong>“栈展开”</strong>；<br />（3）catch捕获时是将异常对象与catch参数的进行** 类型比较<strong>，而</strong>不是值比较**，所以只要类型相同，就可以进入catch中处理。（例如throw抛出一个int类型的值，catch(int &amp;i)就可以对其进行处理；或者throw抛出一个类对象，catch(Base&amp; b)也可成功匹配）<br />所谓 “try”，就是 “尝试着执行一下”，如果有异常，则通过throw向外抛出，随后在外部通过catch捕获并处理异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//&lt;语句序列&gt;</span></span><br><span class="line">    <span class="comment">//监控</span></span><br><span class="line">&#125;<span class="keyword">throw</span> &lt;表达式&gt;</span><br><span class="line">    <span class="comment">// 异常可以是基本类型，有表达式计算得到</span></span><br><span class="line">    <span class="comment">// throw 一个异常对象，会调用拷贝构造函数。所以需要能看到该对象的完成调用</span></span><br><span class="line">    <span class="comment">// 可以是基本类型，拷贝构造函数用来拷贝类</span></span><br><span class="line"><span class="built_in">catch</span>(&lt;类型&gt;[&lt;变量&gt;])&#123;</span><br><span class="line">    <span class="comment">//变量不重要可以省略</span></span><br><span class="line">    <span class="comment">//&lt;语句序列&gt; 捕获并处理</span></span><br><span class="line">    <span class="comment">//依次退出，不要抛出指向局部变量的指针，解决:直接抛出对象，自动进行拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要抛出指出局部对象的引用或者指针，直接抛出一个对象</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670916158841-7a0d5595-de36-442c-82f2-5126fb36eb2f.png" alt="image.png"></p><ul><li><code>catch</code>试图精确匹配，允许从<strong>非常量到常量的转换、从派生类到基类的转换、从数组和函数到指针的转换，但不能匹配到</strong><code>**int**</code><strong>转</strong><code>**double**</code><strong>。</strong></li></ul><h4 id="throw的处理过程：（栈展开）"><a href="#throw的处理过程：（栈展开）" class="headerlink" title="throw的处理过程：（栈展开）"></a>throw的处理过程：（栈展开）</h4><p>throw语句一般位于try语句块内，当throw抛出一个异常时，程序暂停当前函数的执行过程，并寻找与try语句块关联的catch语句（类似 switch…case…），<br />如果这一步没找到匹配的catch，且这一层的try语句外部又包含着另一层try，则在外层try中继续寻找匹配的catch，如果找不到，则退出当前函数，在当前函数的外层函数中继续寻找匹配的try与catch。<br />上述过程被称为“栈展开”（stack unwinding）过程。<br />栈展开 过程沿着嵌套函数的调用链不断查找，直到找到匹配的catch 子句为止；<br />或者一直没有找到匹配的catch，则退出主函数终止查找过程（调用标准库函数terminate）。<br />如果找到了一个匹配的catch子句，则程序进入该子句并执行其中的代码，执行完成后回到到这个 try…catch… 的最后一个catch之后的位置继续向下执行。</p><h4 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h4><p>在编译器的管理空间中，会维护一种“异常对象”，专门用于抛出异常时使用。<br />当发生异常时，编译器会用throw 抛出的表达式的值 对 “异常对象” 进行拷贝初始化，当异常处理完毕后，编译器会将“异常对象”销毁。<br />所以，基于 异常对象 的这种处理机制，对抛出异常的处理有几点限制：<br />① 如果throw抛出的表达式是类类型，则此类必须要有<strong>可访问的拷贝构造函数和析构函数</strong>；（因为对 异常对象 进行拷贝初始化 以及 释放 异常对象的时候需要调用）<br />② throw抛出的异常对象<strong>不能是指向局部对象的指针</strong>；<strong>（因为throw退出作用域后，局部对象随之被释放掉，抛出指针到外层后将无法访问所指向的局部对象）</strong><br />③ throw抛出的表达式为此表达式的静态编译类型，<strong>如果抛出的是一个指向类对象的基类指针，则派生类部分将被截断，只有基类部分被抛出。</strong></p><h4 id="析构函数与异常："><a href="#析构函数与异常：" class="headerlink" title="析构函数与异常："></a>析构函数与异常：</h4><p>当异常发生调用throw，后面的语句将不会被执行，退出作用域时，作用域的局部对象都将会被释放，对于类对象，退出作用域时将自动调用它的析构函数。<br />因此，如果析构函数中有抛出异常的流程，应该要在析构函数内部try捕获，并在析构函数内部得到处理。</p><h4 id="初始化列表与异常"><a href="#初始化列表与异常" class="headerlink" title="初始化列表与异常"></a>初始化列表与异常</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob::<span class="built_in">Bob</span>(string i1) <span class="keyword">try</span> : <span class="built_in">data</span>(i1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">catch</span>(<span class="type">const</span> bad_alloc &amp;e) &#123; <span class="built_in">handle_out_of_memory</span>(e); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="函数参数与异常"><a href="#函数参数与异常" class="headerlink" title="函数参数与异常"></a>函数参数与异常</h4><p>通过对函数调用进行处理</p><h4 id="构造函数与异常"><a href="#构造函数与异常" class="headerlink" title="构造函数与异常"></a>构造函数与异常</h4><p>参数部分：通过对<code>new</code>进行处理</p><h3 id="异常处理嵌套"><a href="#异常处理嵌套" class="headerlink" title="异常处理嵌套"></a>异常处理嵌套</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">g</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">     &#123; … &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">char</span> *) <span class="comment">//捕获char*的对象</span></span><br><span class="line">    &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">g</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">h</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">int</span>) <span class="comment">// 不能捕获char*类型的对象</span></span><br><span class="line">    &#123; …  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">h</span>()&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">1</span>;   <span class="comment">//由g捕获并处理</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;abcd&quot;</span>; <span class="comment">//由f捕获并处理</span></span><br><span class="line">&#125; <span class="comment">// 最终被终止程序所捕获</span></span><br><span class="line"><span class="comment">// 如所抛掷的异常对象在调用链上未被捕获，则由系统的abort处理</span></span><br></pre></td></tr></table></figure><h3 id="catch块排列顺序"><a href="#catch块排列顺序" class="headerlink" title="catch块排列顺序"></a>catch块排列顺序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileErrors</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonExist</span>:<span class="keyword">public</span> FileErrors &#123; &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WrongFormat</span>:<span class="keyword">public</span> FileErrors &#123; &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiskSeekError</span>:<span class="keyword">public</span> FileErrors &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        WrongFormat wf;</span><br><span class="line">        <span class="keyword">throw</span> wf;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(NonExists&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(DiskSeekError&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(FileErrors)&#123;...&#125;<span class="comment">//最后一个可以接住，派生类像基类转换是允许的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        WrongFormat wf;</span><br><span class="line">        <span class="keyword">throw</span> wf;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(FileErrors)&#123;...&#125;<span class="comment">//这样子底下都捕获不到</span></span><br><span class="line">    <span class="built_in">catch</span>(NonExists&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(DiskSeekError&amp;)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Catch exceptions by reference</span></span><br><span class="line"><span class="comment">//尝试多继承，而不是拷贝，避免冗余</span></span><br></pre></td></tr></table></figure><ul><li><code>Catch exceptions by reference</code>不使用引用，会发生对象的拷贝。使用引用，也可以直接对该对象处理，而不用对临时对象进行操作</li></ul><h4 id="例题？？"><a href="#例题？？" class="headerlink" title="例题？？"></a>例题？？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionBase</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionDerived</span>: <span class="keyword">public</span> MyExceptionBase &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(MyExceptionBase&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;<span class="comment">//调用拷贝构造函数。 由静态编译的类型确定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyExceptionDerived e;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">f</span>(e);</span><br><span class="line">    &#125;<span class="built_in">catch</span>(MyExceptionDerived&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionDerived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(MyExceptionBase&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionBase&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:MyExceptionBase，为什么?调用了拷贝构造函数，拷贝构造的结果是MyExceptionBase类型的对象</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670917155781-81d74cba-9468-4aed-ae89-5c53567ab922.png" alt="image.png"><br><code>catch(...)</code>：捕获所有异常</p><h3 id="多出口引发的处理碎片"><a href="#多出口引发的处理碎片" class="headerlink" title="多出口引发的处理碎片"></a>多出口引发的处理碎片</h3><p>一个语句块，可以以<code>throw</code>、<code>return</code>作为出口，因此会导致有多个出口</p><ul><li><code>Java：finally</code>：用来处理多出口，最后都会执行，用来释放资源。</li><li><code>c++</code>中没有<code>finally</code><ul><li>异常处理器</li><li>析构函数<code>raii</code>：将资源初始化为对象，由析构函数进行资源清理。即使是多出口，也可以通过析构函数进行处理。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十一课 IO处理</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20IO%E5%A4%84%E7%90%86/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20IO%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671516582458-6e78ee6b-cee6-4d79-aac8-2b1cff8ce4bc.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671516710451-02c3cf96-313f-477b-8b50-e70b2f00b191.png" alt="image.png"></p><ul><li><code>cout</code>是带缓冲的，可以进行重定向</li><li><code>cerr</code>不带缓冲的，用来打印错误信息</li><li><code>clog</code>是带缓冲的</li></ul><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span> <span class="params">(<span class="string">&quot;in. txt&quot;</span>)</span></span>;</span><br><span class="line">streambuf * cinbuf = cin. <span class="built_in">rdbuf</span> ();<span class="comment">//save old buf</span></span><br><span class="line">cin. <span class="built_in">rdbuf</span> ( in. <span class="built_in">rdbuf</span> ());<span class="comment">//redirect cin to in. txt !</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span> <span class="params">(<span class="string">&quot; out. txt &quot;</span>)</span></span>;</span><br><span class="line">streambuf * coutbuf = cout. <span class="built_in">rdbuf</span> (); <span class="comment">//save old buf</span></span><br><span class="line">cout. <span class="built_in">rdbuf</span> ( out. <span class="built_in">rdbuf</span> ()); <span class="comment">//redirect cout to out. txt !</span></span><br><span class="line">string word;</span><br><span class="line">cin &gt;&gt; word; <span class="comment">//input from the file in. txt </span></span><br><span class="line">cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//output to the file out. txt</span></span><br><span class="line">cin. <span class="built_in">rdbuf</span> ( cinbuf );<span class="comment">//reset to standard input again</span></span><br><span class="line">cout. <span class="built_in">rdbuf</span> ( coutbuf ); <span class="comment">//reset to standard output again</span></span><br><span class="line">cin &gt;&gt; word; <span class="comment">//input from the standard input</span></span><br><span class="line">cout &lt;&lt; word; <span class="comment">//output to the standard input</span></span><br></pre></td></tr></table></figure><h2 id="I-x2F-O处理"><a href="#I-x2F-O处理" class="headerlink" title="I&#x2F;O处理"></a>I&#x2F;O处理</h2><p>对输出操作符&lt;&lt;进行重载，只能采用友元函数的形式进行，而不能将operator&lt;&lt;()申明为ostream类的成员函数。这是因为<strong>ostream是在C++标准中定义的类，不允许用户随便修改。</strong>所以，要将类someClass的对象输出到标准输出对象，只能采用将operator&lt;&lt;()重载为全局函数，申明为someClass类的友元的形式进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp;, CPoint2D &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数：传入一个ostream对象和一个自定义对象</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint2D&amp; a)&#123;<span class="comment">//引用类型保证能连续输出</span></span><br><span class="line">    out &lt;&lt; a.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.y &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">CPoint2D a;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;   <span class="type">double</span> z;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">CPoint3D b;</span><br><span class="line">cout &lt;&lt; b;<span class="comment">//只显示b.x和b.y，而没显示b.z</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;   <span class="type">double</span> z;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;, CPoint3D &amp;);</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint3D &amp; b)&#123;</span><br><span class="line">    out &lt;&lt; b.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b.y &lt;&lt;<span class="string">&quot;,&quot;</span>  &lt;&lt; b.z &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题:3D对象被2D指针指向，cout调用了2D的版本，解决:虚化</span></span><br></pre></td></tr></table></figure><p>虚化：<strong>虚化非成员函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span></span><br><span class="line">&#123;       <span class="type">double</span>  x,  y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">         …</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span></span><br><span class="line"><span class="function">  </span>&#123;   out &lt;&lt; x &lt;&lt; ‘,’ &lt;&lt; y &lt;&lt; endl;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 针对基类进行操作符重载</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint2D &amp;a)</span><br><span class="line">&#123; </span><br><span class="line">    a.<span class="built_in">display</span>(out); <span class="comment">// 调用方法，虚函数，调用实际类型</span></span><br><span class="line"> <span class="keyword">return</span> out;  </span><br><span class="line">    <span class="comment">// 和虚函数的作用一样 -- 让一个全局函数针对不同派生类型，进行不同处理，定义一个</span></span><br><span class="line">    <span class="comment">// 虚函数，直接调用对象的虚函数，全局函数是一个非虚接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;      <span class="type">double</span>  z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       …</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span></span><br><span class="line"><span class="function">       </span>&#123;    CPoint2D::<span class="built_in">display</span>();   out &lt;&lt; ‘,’&lt;&lt; z &lt;&lt; endl;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="虚拟化构造器"><a href="#虚拟化构造器" class="headerlink" title="虚拟化构造器"></a>虚拟化构造器</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671518786205-45aafc9c-58fe-4857-81b2-efe92d6759ff.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671518008925-3dcf432c-0365-4c46-90d5-af4df1deef5a.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> :<span class="keyword">public</span> NLComponent &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span> :<span class="keyword">public</span> NLComponent &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsLetter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NewsLetter</span>(istream&amp; str)&#123;</span><br><span class="line">            <span class="keyword">while</span> (str)</span><br><span class="line">                components.<span class="built_in">push_back</span>(<span class="built_in">readComponent</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> NLComponent * <span class="title">readComponent</span><span class="params">(istream&amp; str)</span></span>;</span><br><span class="line">        <span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">            <span class="keyword">for</span> (list&lt;NLComponent *&gt;::iterator it=rhs.component.<span class="built_in">begin</span>();it != rhs.component.<span class="built_in">end</span>(); ++it )</span><br><span class="line">                <span class="comment">//期望有一个虚函数可以拷贝自己，不希望进行的是浅拷贝</span></span><br><span class="line">                component.<span class="built_in">push_back</span>();<span class="comment">//new TextBlock? Graphic?</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    list&lt;NLComponent *&gt; components;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚化构造器，因为构造函数不能是虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> NLComponent *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，代表一个接口</span></span><br><span class="line"><span class="comment">//原型模式:添加clone，使得构造也具有多态的行为</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> TextBlock *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="comment">// 构造器本身是一个成员函数，不需要全局</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Graphic  *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>( <span class="type">const</span> NewsLetter&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">for</span> ( list&lt;NLComponent *&gt;::iterator it=rhs.component.<span class="built_in">begin</span>();</span><br><span class="line">it != rhs.component.<span class="built_in">end</span>(); ++it )</span><br><span class="line">        component.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//typeid(*it)==typeid(TextBlock)判断对象的类型，必须带有虚函数。</span></span><br><span class="line"><span class="comment">// 如果不带有虚函数，只会得到参数的类型。所以可以创建一个虚的构造器RTTI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Question</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BalancedBST</span>: <span class="keyword">public</span> BST &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s, <span class="type">const</span> BST array[], <span class="type">int</span> numElements)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; numElements; i++)</span><br><span class="line">        s &lt;&lt; array[i];</span><br><span class="line">&#125;</span><br><span class="line">BalancedBST bBSTArray[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, bBSTArray, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//问题是?array[i]是指针算法的缩写，数组每次偏移地址是sizeof(BST)，而不是sizeof(BalancedBST)，会出现问题。</span></span><br></pre></td></tr></table></figure><h2 id="C11新特性"><a href="#C11新特性" class="headerlink" title="C11新特性"></a>C11新特性</h2><h3 id="右值引用-R-value-Reference"><a href="#右值引用-R-value-Reference" class="headerlink" title="右值引用 R-value Reference"></a>右值引用 R-value Reference</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671519743559-e08d485b-3a47-4c56-8c84-55f393bfeebf.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671519795433-41c05e6d-f488-402f-bb9d-197fea72ce58.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671519968056-838be8bd-a365-4e98-8e75-766b2c047593.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> *arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyArray</span>():<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">arr</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">int</span> sz):</span><br><span class="line">        <span class="built_in">size</span>(sz),<span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[sz]) &#123;</span><br><span class="line">        <span class="comment">//init array here…</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp;other):</span><br><span class="line">        <span class="built_in">size</span>(other.size), </span><br><span class="line">        <span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = other.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//main函数中第三种声明方式的移动构造</span></span><br><span class="line">    <span class="built_in">MyArray</span> (MyArray &amp;&amp;other):</span><br><span class="line">        <span class="built_in">size</span>(other.size), <span class="built_in">arr</span>(other.arr) &#123;</span><br><span class="line">        other.arr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ <span class="built_in">MyArray</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MyArray <span class="title">change_aw</span><span class="params">(<span class="type">const</span> MyArray &amp;other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">aw</span><span class="params">(other.get_size())</span></span>;</span><br><span class="line">    <span class="comment">//Do some change to aw.</span></span><br><span class="line">    <span class="comment">//….</span></span><br><span class="line">    <span class="keyword">return</span> aw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">myArr</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    MyArray myArr2 = <span class="built_in">change_aw</span>(myArr);<span class="comment">//调用了两次拷贝，先将myArr传入的时候进行一次拷贝，返回之后再次进行拷贝，比较大的开销</span></span><br><span class="line">    MyArray &amp;&amp;myArr2 = <span class="built_in">change_aw</span>(myArr);<span class="comment">//右值函数，直接用移动构造函数，右值引用造成的维护困难</span></span><br><span class="line">    MyArray myArr2 = <span class="built_in">change_aw</span>(myArr);<span class="comment">//有了新的移动构造函数,自动适配，15min，提高拷贝速度在C++中使用移动构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    MyArray &amp;<span class="keyword">operator</span>=(<span class="type">const</span></span><br><span class="line">        MyArray &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr) &#123;<span class="keyword">delete</span>[] arr;arr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = other.size;</span><br><span class="line">        <span class="built_in">memcpy</span>(arr, other.arr, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyArray &amp;<span class="keyword">operator</span>=(ArrayWrapper &amp;&amp;other) &#123; <span class="comment">// 匹配移动赋值操作符的重载</span></span><br><span class="line">        size = other.size;</span><br><span class="line">        arr = other.arr;</span><br><span class="line">        other.arr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">// 赋值操作符重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyArray myArr;</span><br><span class="line">    myArr = <span class="built_in">MyArr</span>(<span class="number">5</span>);<span class="comment">//MyArr是临时对象，无法直接进行使用，可以直接移动过去。19min的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝构造、拷贝赋值、移动构造、移动赋值、析构函数<br />重定义其中一个，另外四个都不再默认生成</p><h3 id="外部模板-Extern-Templates"><a href="#外部模板-Extern-Templates" class="headerlink" title="外部模板 Extern Templates"></a>外部模板 Extern Templates</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myfunc.h</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">myfunc</span><span class="params">(T t)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfunc.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">myfunc</span>(<span class="number">1</span>); <span class="comment">// 在链接的过程中，会进行实例化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfunc.h&quot;</span></span></span><br><span class="line"><span class="comment">//如果没有以下的模板，那么编译器会先去实例化模板，新的方式外部模板可以避免多次实例化的问题</span></span><br><span class="line"><span class="comment">/*Tell compiler: this instance has been</span></span><br><span class="line"><span class="comment">instantiated in another module!*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">myfunc</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>); <span class="comment">// 已经被实例化了且会被链接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myfunc</span>(<span class="number">1</span>); <span class="comment">// 就不会重复实例化了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量表达式-Constant-Expression"><a href="#常量表达式-Constant-Expression" class="headerlink" title="常量表达式 Constant Expression"></a>常量表达式 Constant Expression</h3><ol><li><p>提供了更一般的常量表达式</p></li><li><p>允许常量表达式使用用户自定义类型</p></li><li><p>提供一种方法来确保在编译时完成初始化</p></li><li><p><strong>必须在编译的时候可以确定常量表达式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Flags</span> &#123; GOOD=<span class="number">0</span>, FAIL=<span class="number">1</span>, BAD=<span class="number">2</span>, EOF=<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="keyword">operator</span>| (Flags f1, Flags f2)  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Flags</span>(<span class="built_in">int</span>(f1)|<span class="built_in">int</span>(f2));</span><br><span class="line">&#125;<span class="comment">//如果不加constexpr则结果被认为是变量不能使用在case中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Flags x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> BAD: <span class="comment">/* ... */</span><span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EOF: <span class="comment">/* ... */</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BAD|EOF: <span class="comment">/* ... */</span> <span class="keyword">break</span>;<span class="comment">//OK，必须是简单的确认的值</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* ... */</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Flags x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">bad_c</span><span class="params">()</span>: /* ... */break;</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">eof_c</span><span class="params">()</span>: /* ... */ break;</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">be_c</span><span class="params">()</span>: /* ... */ break;</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* ... */</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">bad_c</span><span class="params">()</span></span>; <span class="comment">// 只要函数的返回值永远是一个常量</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">eof_c</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">be_c</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">int</span> xx, <span class="type">int</span> yy)</span> : x(xx), y(yy) &#123;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// const对象 -- 对象是不能通过接口修改的</span></span><br><span class="line">    <span class="comment">// constexpr -- 对象的值是可以在编译时确定的，同时也是一个const</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Point <span class="title">origo</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="comment">//完全常量，在常量表上</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> z = origo.x;</span><br><span class="line"><span class="comment">// 相当于对象都是一组值，不需要重复开辟空间</span></span><br><span class="line">    <span class="keyword">constexpr</span> Point a[] = &#123;<span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">Point</span>(<span class="number">1</span>,<span class="number">1</span>), <span class="built_in">Point</span>(<span class="number">2</span>,<span class="number">2</span>) &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> x = a[<span class="number">1</span>].x; <span class="comment">// x becomes 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所有评估都可以在编译时完成，所有对象都可以看做一组值。 因此，提高了运行时间效率。</p></li><li><p>编译时确定的</p></li></ol><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpInt</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CmpInt</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125; <span class="comment">// 函数调用操作符重载</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; items &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), cmpInt); <span class="comment">//Function Pointer 函数指针</span></span><br><span class="line">    std::<span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), <span class="built_in">CmpInt</span>()); <span class="comment">//Function Object (Functor) 函数对象</span></span><br><span class="line">    std::<span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), <span class="comment">// [] 代表 lambda函数</span></span><br><span class="line">        [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125; <span class="comment">//Lambda Function</span></span><br><span class="line">    );  <span class="comment">// 实例化成std::function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">comp</span>(*it1, *it2) )</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::function 是C++对所有可调用的函数的封装：使用函数、函数对象、lambda函数</span></span><br><span class="line"><span class="function">std::function&lt;<span class="title">bool</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">f1</span><span class="params">(cmpInt)</span></span>;</span><br><span class="line"><span class="function">std::function&lt;<span class="title">bool</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">f2</span><span class="params">(CmpInt)</span></span>;</span><br><span class="line"><span class="function">std::function&lt;<span class="title">bool</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">f3</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b;&#125; )</span></span>;</span><br><span class="line"><span class="comment">// 1.不需要特别实例化   2.lambda表达式可以统一实例化为std::function对象</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">str_filter</span><span class="params">(vector&lt;string&gt; &amp;vec, function&lt;<span class="type">bool</span>(string &amp;)&gt; matched)</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (string tmp : vec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">matched</span>(tmp))</span><br><span class="line">            result.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以会用局部变量，40min</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec = &#123;<span class="string">&quot;www.baidu.com&quot;</span>, <span class="string">&quot;www.kernel.org&quot;</span>, <span class="string">&quot;www.google.com&quot;</span>&#125;;</span><br><span class="line">    string pattern = <span class="string">&quot;.com&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; filterd = <span class="built_in">str_filter</span>(vec,</span><br><span class="line">        [&amp;](string &amp;str) &#123;  <span class="comment">// [&amp;]:以引用的方式，捕获有效变量，不需要传入新的参数</span></span><br><span class="line">            <span class="keyword">if</span> (str.<span class="built_in">find</span>(pattern) != string::npos) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>符号</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>[]</td><td>Capture nothing</td></tr><tr><td>[&amp;]</td><td>Capture any referenced variable by reference</td></tr><tr><td>[&#x3D;]</td><td>Capture any referenced variable by making a copy 以值拷贝的方式传入，不会产生副作用</td></tr><tr><td>[&#x3D;, &amp;foo]</td><td>Capture any referenced variable by making a copy, but capture variable foo by reference</td></tr><tr><td>[bar]</td><td>Capture bar by making a copy; don’t copy anything else</td></tr></tbody></table><h3 id="Delegating-Constructor-委托构造函数"><a href="#Delegating-Constructor-委托构造函数" class="headerlink" title="Delegating Constructor 委托构造函数"></a>Delegating Constructor 委托构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 256</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">validate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">if</span> (<span class="number">0</span>&lt;x &amp;&amp; x&lt;=MAX) a=x; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">bad_X</span>(x); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> x) &#123; <span class="built_in">validate</span>(x); &#125;</span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">validate</span>(<span class="number">42</span>); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> x) &#123; <span class="keyword">if</span> (<span class="number">0</span>&lt;x &amp;&amp; x&lt;=max) a=x; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">bad_X</span>(x); &#125;</span><br><span class="line">    <span class="built_in">X</span>() :<span class="built_in">X</span>(<span class="number">42</span>) &#123; &#125; <span class="comment">// 在一个构造函数中，委托另外一个构造函数。默认构造函数可以委托另外一个构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">X</span>(<span class="type">int</span> x = <span class="number">42</span>) ? <span class="comment">// 默认参数是有参数的，和无参默认构造函数是不同的</span></span><br></pre></td></tr></table></figure><h3 id="Uniform-Initialization-统一初始化"><a href="#Uniform-Initialization-统一初始化" class="headerlink" title="Uniform Initialization 统一初始化"></a>Uniform Initialization 统一初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Old style initialization</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//…</span></span><br><span class="line"><span class="comment">//New style initialization</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//Compiler will translate &#123;&#125; as initializer_list&lt;int&gt; 新的初始化表</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">vector</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="built_in">vector</span>(initializer_list&lt;T&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            <span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//OK</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line">A a= &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="comment">//Default generated by compiler</span></span><br><span class="line">    <span class="built_in">A</span>(initializer_list&lt;<span class="type">int</span>&gt; list) &#123; <span class="comment">// 接受初始化列表参数</span></span><br><span class="line">        <span class="keyword">auto</span> it = list.<span class="built_in">begin</span>();</span><br><span class="line">        x = *it++;</span><br><span class="line">        y = *it++;</span><br><span class="line">        z = *it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Uniform Initialization achieved!</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">A  a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 都可以通过初始化列表的方式进行初始化</span></span><br></pre></td></tr></table></figure><h3 id="nullptr-空指针"><a href="#nullptr-空指针" class="headerlink" title="nullptr 空指针"></a>nullptr 空指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//f(0) 两者都可以解释</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版本</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);         <span class="comment">// call f(int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);   <span class="comment">// call f(char*)</span></span><br><span class="line"><span class="comment">// 原来的NULL就是0</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">// call f(int)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常量指针和指针常量</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在C++学习使用过程中，每个人都不可避免地使用指针，而且都或多或少的接触过常量指针或指针常量，但是对这两个概念还是很容易搞糊涂的。<br />本文即是简单描述指针常量和常量指针的区别。</p><h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><p>定义：<br /><del>又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。</del><br />通俗理解：<strong>指向常量</strong>（定语）的指针（主语）。</p><ol><li>指向常量：代表不能通过该指针来修改对应对象的值</li><li>但是可以通过原来的声明修改相应的值</li><li><strong>指针是一个变量</strong></li></ol><p>关键点：</p><ol><li>常量指针指向的对象不能通过这个指针来修改，可是<strong>仍然可以通过原来的声明修改</strong>；</li><li>常量指针可以被赋值为变量的地址，之所以叫常量指针，是<strong>限制了通过这个指针修改变量的值</strong>；</li><li>指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；</li></ol><p>代码形式：<br /><code>int const* p;  const int* p;</code></p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>** <strong>定义：<br />~~本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。 ~~<br />通俗理解：是一个指针（定语）的常量（主语）。根据定语表示性质可知，该常量是一个指针，而常量代表着值无法改变，也就是说</strong>指针的值无法改变<strong>，也就是</strong>指针指向的地址不能变化<strong>。但是</strong>指向的地址所对应的内容可以变化。**<br />关键点：</p><ol><li>它是个常量</li><li>指针本身是常量，指向的地址不可以变化,但是<strong>指向的地址所对应的内容可以变化</strong>；</li></ol><p>代码形式：<br /> <code>int* const p;</code></p><h2 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a>指向常量的常指针</h2><p>定义：<br />指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。<br />关键点：<br />1.一个指针常量，指向的是一个指针对象；<br />2.它指向的指针对象且是一个常量，即它指向的对象不能变化；<br />代码形式：<br /><code>const int* const p;</code></p><h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><p>那如何区分这几类呢? 带两个const的肯定是指向常量的常指针，很容易理解，主要是如何区分常量指针和指针常量:<br />一种方式是看** * 和 const 的排列顺序<em><em>，比如<br />     int const</em> p; &#x2F;&#x2F;const * 即常量指针<br />     const int</em> p; &#x2F;&#x2F;const * 即常量指针<br />     int* const p; &#x2F;&#x2F;* const 即指针常量<br />还一种方式是<strong>看const离谁近，即从右往左看</strong>，比如<br />     int const* p; &#x2F;&#x2F;const修饰的是<em>p，即</em>p的内容不可通过p改变，但p不是const，p可以修改，<em>p不可修改；<br />     const int</em> p; &#x2F;&#x2F;同上<br />     int* const p; &#x2F;&#x2F;const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------常量指针-------</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;a;</span><br><span class="line">a = <span class="number">300</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="comment">//*p1 = 56;  //Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针常量-------//</span></span><br><span class="line"><span class="type">int</span>*  <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line"><span class="comment">//p2 = &amp;b;     //Error,因为p2是const 指针，因此不能改变p2指向的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指向常量的常量指针-------//</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//*p3 = 1;    //Error</span></span><br><span class="line"><span class="comment">//p3 = &amp;b;    //Error</span></span><br><span class="line">a = <span class="number">5000</span>;    <span class="comment">//OK,仍然可以通过原来的声明修改值</span></span><br></pre></td></tr></table></figure><p><strong>常量指针中的值不可以通过指针修改，但是可以通过原来的声明修改</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">const</span> <span class="type">int</span>  x = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//    int * p1 = &amp;x;</span></span><br><span class="line"><span class="comment">// Cannot initialize a variable of type &#x27;int *&#x27; with an rvalue of type &#x27;const int *&#x27;</span></span><br></pre></td></tr></table></figure><p><code>**const**</code><strong>本身也是一个类型，因此必须要用</strong><code>**const int ***</code><strong>常量指针来指向，而不能用普通的指针</strong><br />在实际应用中，常量指针要比指针常量用的多，比如常量指针经常用在函数传参中，以避免函数内部修改内容。<br />size_t strlen(const char* src); &#x2F;&#x2F;常量指针，src的值不可改变；<br />char a[] &#x3D; “hello”;<br />char b[] &#x3D; “world”;<br />size_t a1 &#x3D; strlen(a);<br />size_t b1 &#x3D; strlen(b);<br />虽然a、b是可以修改的，但是可以保证在strlen函数内部不会修改a、b的内容。</p><h2 id="指针问题"><a href="#指针问题" class="headerlink" title="指针问题"></a>指针问题</h2><p>既然讲到了指针，那顺便说一下空指针、野指针的问题。<br />空指针就是保存地址为空的指针，使用指针时必须先判断是否空指针，很多问题都是这一步导致的。<br />野指针是在delete掉指针之后，没有置0，导致指针随意指向了一个内存地址，如果继续使用，会造成不可预知的内存错误。<br />另外指针的误用很容易造成BUG或者内存泄漏。<br />看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------空指针-------//</span></span><br><span class="line"><span class="type">int</span> *p4 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;,*p4); //运行Error，使用指针时必须先判断是否空指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------野指针（悬浮、迷途指针）-------//</span></span><br><span class="line"><span class="type">int</span> *p5 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">delete</span> p5;</span><br><span class="line">p5 = <span class="literal">NULL</span>; <span class="comment">//一定要有这一步</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p5);  <span class="comment">//隐藏bug，delete掉指针后一定要置0，不然指针指向位置不可控，运行中可导致系统挂掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针的内存泄漏-------//</span></span><br><span class="line"><span class="type">int</span> *p6 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">6</span>);</span><br><span class="line">p6 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">7</span>); <span class="comment">//p6原本指向的那块内存尚未释放，结果p6又指向了别处，原来new的内存无法访问，也无法delete了，造成memory leak</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拷贝构造函数和操作符=的重载</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6=%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6=%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>首先要说明的是，若用户没有定义，C++隐式声明一个拷贝构造函数和一个赋值运算符（完成按数据成员复制的动作）。二者很像，但是在下边这点上有很大的不同：<br />拷贝构造函数是只在<strong>对象实例化时</strong>才会被调用，也就是说，在拷贝构造函数调用期间，这个对象处于一个未决状态（直到拷贝构造函数被成功调用），另外拷贝构造函数不返回任何值，void都没有。<br /><a href="https://so.csdn.net/so/search?q=%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">拷贝构造函数</a>应用的场合由以下几个方面：<br />1 函数的参数是一个对象，并且是值传递方式<br />2 函数的返回值是一个对象，并且是值传递方式<br />3 用一个对象初始化另外一个对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>()</span><br><span class="line">        &#123;   </span><br><span class="line">            ctor_count++;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;ctor &quot;</span>&lt;&lt;ctor_count&lt;&lt;endl;</span><br><span class="line">        &#125;   </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">const</span> Test &amp; r)</span><br><span class="line">        &#123;   </span><br><span class="line">            ctor_count++;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;copy ctor &quot;</span>&lt;&lt;ctor_count&lt;&lt;endl;</span><br><span class="line">        &#125;   </span><br><span class="line"> </span><br><span class="line">        Test &amp; <span class="keyword">operator</span>= (<span class="type">const</span> Test&amp; r)</span><br><span class="line">        &#123;   </span><br><span class="line">            ctor_count++;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;assignment op &quot;</span>&lt;&lt;ctor_count&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> ctor_count; <span class="comment">//only a declaration</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> Test::ctor_count=<span class="number">0</span>; <span class="comment">// definition + initialization</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    Test test1=test;</span><br><span class="line">    <span class="function">Test <span class="title">test2</span><span class="params">(test)</span></span>;</span><br><span class="line">    Test test3=test2=test1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <br />输出结果<br />[root@xxx]$ .&#x2F;a.out<br />ctor 1<br />copy ctor 2<br />copy ctor 3<br />assignment op 4<br />copy ctor 5</p><p>我们看到：<br />Test test; &#x2F;&#x2F;实例化test对象时调用了默认构造函数<br />Test test1&#x3D;test;&#x2F;&#x2F; test1使用了拷贝构造函数（因为这是一个新的对象产生）<br />Test test2(test);&#x2F;&#x2F;test2时也是用了拷贝构造函数，<br />Test test3&#x3D;<strong>test2&#x3D;test1;</strong>&#x2F;&#x2F;而test2&#x3D;test1则使用了<strong>操作符重载</strong>（没有新的对象产生），<br />Test <strong>test3&#x3D;test2</strong>&#x3D;test1;&#x2F;&#x2F;test3&#x3D;test2则使用了<strong>拷贝构造函数</strong>，原因同上。</p><p>所以要看<strong>是不是有新的对象产生，才能决定到底是调用了拷贝构造函数，还是赋值运算符。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>继承时的名空间隐藏、重载、覆盖</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%BB%A7%E6%89%BF%E6%97%B6%E7%9A%84%E5%90%8D%E7%A9%BA%E9%97%B4%E9%9A%90%E8%97%8F%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%BB%A7%E6%89%BF%E6%97%B6%E7%9A%84%E5%90%8D%E7%A9%BA%E9%97%B4%E9%9A%90%E8%97%8F%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<h3 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h3><p>隐藏：子类对象优先考虑子类域自身成员（成员变量和成员函数）<br /> 　　隐藏发生的主要原因，就是当子类有父类的<strong>同名成员</strong>时，子类对象访问该成员时，会发生冲突。所以编译器的处理方式是，<strong>优先考虑子类域中的自身成员。</strong><br />即，子类对象访问某成员时，如ch.m_m 或者ch.f(),成员变量和成员函数都一样。编译器首先在子类域中检索，如果在子类域中找到该成员，则检索结束，返回该成员进行访问。如果在子类域中找不到该成员，则去父类域中检索。如果父类域中存在，则返回该成员进行访问，如果父类域中也不存在，则编译错误，该成员无效。<br />　**　当父子类域都存在同一成员时，编译器优先在子类中检索<strong>，就算父类域中也存在该同名成员，也不会被检索到。因此，</strong>父类域中的该成员被子类域中的该同名成员隐藏，即访问时完全以为该成员不存在，如果想访问父类域中的该成员，只能通过显示调用的方式，即：ch.Father::m_m;**</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> f_a;</span><br><span class="line">    <span class="type">int</span> f_b;</span><br><span class="line">string f_c;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ff1</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;father ff1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Childer</span>:<span class="keyword">public</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> c_a;</span><br><span class="line">    <span class="type">int</span> f_b;</span><br><span class="line"><span class="type">int</span> f_c;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cf1</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;childer cf1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ff1</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;childer ff1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Childer ch;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ch.c_a&lt;&lt;endl; <span class="comment">//只在子类域中的成员变量</span></span><br><span class="line">    cout&lt;&lt;ch.f_b&lt;&lt;endl; <span class="comment">//子类域和父类域都存在，优先访问子类域中的</span></span><br><span class="line">    cout&lt;&lt;ch.Father::f_b&lt;&lt;endl; <span class="comment">//显示访问被隐藏的成员变量</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;====================\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ch.<span class="built_in">cf1</span>();</span><br><span class="line">    ch.<span class="built_in">ff1</span>();</span><br><span class="line">    ch.Father::<span class="built_in">ff1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>ch</code>无法访问父类的<code>f_b</code>和<code>f_c</code>。说明：名空间的隐藏只在乎<strong>名字是否相同，而不在乎类型是否相同</strong></li><li><code>ch.Father::ff1();</code>必须通过显式调用才能访问到。说明：只是<strong>隐藏了，看不到了，而不代表没有</strong></li></ol><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载：<strong>相同域的同名不同参函数</strong><br />　　重载必须是发生在<strong>同一个域</strong>中的两个<strong>同名不同形参</strong>之间的。如果一个在父类域一个在子类域，是不会存在重载的，属于隐藏的情况。调用时，只会在子类域中搜索，如果形参不符合，会认为没有该函数，而不会去父类域中搜索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">double</span> i)</span></span>;<span class="comment">//overload</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> j)</span></span>;<span class="comment">//overload</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">double</span> i, <span class="type">int</span> j)</span></span>;<span class="comment">//overload</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span></span>;         <span class="comment">//错误，非重载。注意重载不关心函数返回类型。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">10</span>;<span class="comment">//id在Undergraduated_Student中仍然是私有的，默认权限位private</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123; <span class="built_in">strcpy</span>(nickname, s); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> nickname[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_ID</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; id = x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; nickname &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;getId&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// 通过继承基类的公有方法访问到基类的私有变量</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> y = <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span> : <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="type">int</span> dept_no&#123;&#125;;<span class="comment">//学院编号</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; dept_no = x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    void showInfo()&#123;cout &lt;&lt; dept_no &lt;&lt; &quot;:&quot; &lt;&lt; nickname &lt;&lt; endl;&#125;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_ID</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;changed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// 对基类的函数进行覆盖，并修改了访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> Student::nickname;<span class="comment">//这样在才能修改可见性</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新定义了一个private方法，父类对应方法被隐藏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Undergraduated_Student *us = <span class="keyword">new</span> Undergraduated_Student;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; us-&gt;y;</span></span><br><span class="line">    us-&gt;<span class="built_in">SetNickName</span>();</span><br><span class="line">    us-&gt;<span class="built_in">getId</span>();</span><br><span class="line"><span class="comment">//    us-&gt;showInfo(); 无法访问，通过隐藏父类的方法，修改了访问权限</span></span><br><span class="line">    us-&gt;Student::<span class="built_in">showInfo</span>(<span class="number">10</span>); <span class="comment">// 被隐藏了，但是可以显式的使用对应的名空间进行访问</span></span><br><span class="line"><span class="comment">//    us-&gt;showInfo(10); //error ,因为被子类的同名方法所隐藏了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">110</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;base in A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">1</span>)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; in B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;override in B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;overload_int&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;overload_double&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">C</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">75</span>)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; in C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot; in C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">f1</span>();</span><br><span class="line">    b.<span class="built_in">f1</span>(<span class="number">10</span>);</span><br><span class="line">    b.<span class="built_in">f1</span>(<span class="number">100.5</span>);</span><br><span class="line">    b.A::<span class="built_in">f1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// override in B</span></span><br><span class="line"><span class="comment">// overload_int</span></span><br><span class="line"><span class="comment">// overload_double</span></span><br><span class="line"><span class="comment">// base in A</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>练习</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%BB%83%E4%B9%A0/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<ul><li><code>friend complex operator+(const complex &amp;A, const complex &amp;B) const;</code> 非成员函数不能是const，会报错<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;基类函数 fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    void fun1() &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; &quot;派生类函数 fun1&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">fun1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>10<br>基类函数 fun1</p></blockquote></li></ul><p>输出的<code>a</code>是基类名空间下的<code>a</code>，而不是派生类名空间下的<code>a</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;基类函数 fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;派生类函数 fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">fun1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>20<br>派生类函数 fun1</p></blockquote><p>因为在派生类中定义了相同名字的函数和变量，所以基类名空间下的被隐藏了</p><h3 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2023/2/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">complex</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line">    complex <span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;A) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="type">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>() : <span class="built_in">m_real</span>(<span class="number">0.0</span>), <span class="built_in">m_imag</span>(<span class="number">0.0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag) : <span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex complex::<span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;A) <span class="type">const</span> &#123;</span><br><span class="line">    complex B;</span><br><span class="line">    B.m_imag = <span class="keyword">this</span>-&gt;m_imag + A.m_imag;</span><br><span class="line">    B.m_real = <span class="keyword">this</span>-&gt;m_real + A.m_real;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; m_real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; m_imag &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function">complex <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    complex c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// construct</span></span><br><span class="line"><span class="comment">// construct</span></span><br><span class="line"><span class="comment">// deconstruct</span></span><br><span class="line"><span class="comment">// 6.7 + 9.5i</span></span><br><span class="line"><span class="comment">// deconstruct</span></span><br><span class="line"><span class="comment">// deconstruct</span></span><br><span class="line"><span class="comment">// deconstruct</span></span><br></pre></td></tr></table></figure><p>为什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2023/2/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">complex</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line"><span class="comment">//    complex operator+(const complex &amp;A) const;</span></span><br><span class="line">    <span class="keyword">friend</span> complex <span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;A, <span class="type">const</span> complex &amp;B);</span><br><span class="line"></span><br><span class="line">    complex <span class="keyword">operator</span> *(<span class="type">const</span> complex &amp;other)<span class="type">const</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="type">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>() : <span class="built_in">m_real</span>(<span class="number">0.0</span>), <span class="built_in">m_imag</span>(<span class="number">0.0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag) : <span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//complex complex::operator+(const complex &amp;A) const &#123;</span></span><br><span class="line"><span class="comment">//    complex B;</span></span><br><span class="line"><span class="comment">//    B.m_imag = this-&gt;m_imag + A.m_imag;</span></span><br><span class="line"><span class="comment">//    B.m_real = this-&gt;m_real + A.m_real;</span></span><br><span class="line"><span class="comment">//    return B;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>*(<span class="type">const</span> complex &amp;A) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="keyword">this</span>-&gt;m_real * A.m_real, <span class="keyword">this</span>-&gt;m_imag * A.m_imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;A, <span class="type">const</span> complex &amp;B) &#123;</span><br><span class="line">    complex C;</span><br><span class="line">    C.m_real = A.m_real + B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag + B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; m_real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; m_imag &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function">complex <span class="title">c2</span><span class="params">(<span class="number">1.0</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    complex c3;</span><br><span class="line">    c3 = c1 + c2 * c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">construct</span><br><span class="line">construct</span><br><span class="line">construct</span><br><span class="line">deconstruct</span><br><span class="line">deconstruct</span><br><span class="line"><span class="number">5.3</span> + <span class="number">19.49</span>i</span><br><span class="line">deconstruct</span><br><span class="line">deconstruct</span><br><span class="line">deconstruct</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Effective%20C++/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Effective%20C++/</url>
      
        <content type="html"><![CDATA[<ol start="33"><li><p><code>Avoid hiding inherited names</code>避免掩盖继承而来的名字</p></li><li><p><code>Never redefine an inherited non-virtual function</code>绝不重新定义继承而来的非虚函数</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    virtual </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C *pc = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">    B *pb = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">    A *pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">    pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">    C *pnull = <span class="literal">nullptr</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line">    pa-&gt;<span class="built_in">func</span>(); <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">    pc-&gt;<span class="built_in">func</span>(); <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">    pnull-&gt;<span class="built_in">func</span>(); <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="37"><li><code>Never redefine a function&#39;s inherited default parameter value</code>绝不重新定义继承而来的缺省参数值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;E::func()\t&quot;</span>&lt;&lt; i &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> : <span class="keyword">public</span> E</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;F::func()\t&quot;</span> &lt;&lt; i &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F* pf = <span class="keyword">new</span> <span class="built_in">F</span>();</span><br><span class="line">    E* pe = pf;</span><br><span class="line">    pf-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 1  正常，就该如此；</span></span><br><span class="line">    pe-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676269766535-c95849eb-027e-48bb-88da-7046516a74e2.png" alt="image.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态绑定和动态绑定</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<ol><li>静态绑定发生在编译期，动态绑定发生在运行期； </li><li>对象的动态类型可以更改，但是静态类型无法更改； </li><li>要想实现动态，必须使用动态绑定； </li><li>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</li></ol><p>建议：<br />绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用<strong>由对象声明时的静态类型确定</strong>了，而<strong>和对象本身脱离了关系</strong>，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    virtual </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C *pc = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">    B *pb = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">    A *pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">    pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">    C *pnull = <span class="literal">nullptr</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line">    pa-&gt;<span class="built_in">func</span>(); <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">    pc-&gt;<span class="built_in">func</span>(); <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">    pnull-&gt;<span class="built_in">func</span>(); <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">C *pc = <span class="keyword">new</span> <span class="built_in">C</span>(); </span><br><span class="line">B *pb = <span class="keyword">new</span> <span class="built_in">B</span>(); </span><br><span class="line">A *pa = pc;      </span><br><span class="line">pa = pb;         </span><br><span class="line">C *pnull = <span class="literal">nullptr</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>using 的使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/using%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/using%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-导入命名空间"><a href="#1-导入命名空间" class="headerlink" title="1. 导入命名空间"></a>1. 导入命名空间</h2><p>使用C++在写不同的功能模块时，为了防止命名冲突，建议对模块取命名空间，这样在使用时就需要指定是哪个命名空间。<br />使用 using 导入命名空间，即使一个命名空间中的所有名字都在该作用域中可见，常见的如下：<br />&#x2F;&#x2F; 导入整个命名空间到当前作用域 using namespace std; &#x2F;&#x2F; 只导入某个变量到当前作用域  using std::cout;  <br /><strong>在.h头文件中，一般不应该使用using声明。</strong><br />因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明，从而可能产生名字冲突。</p><h2 id="2-指定别名"><a href="#2-指定别名" class="headerlink" title="2. 指定别名"></a>2. 指定别名</h2><p>C++ 11 通过 using 指定别名，作用等同于 typedef，但相比 typedef，逻辑更直观，可读性更好。<br />typedef int T; &#x2F;&#x2F; 用 T 代替 int using T &#x3D; int; &#x2F;&#x2F; 用 T 代替 int </p><h2 id="3-在派生类中引用基类成员"><a href="#3-在派生类中引用基类成员" class="headerlink" title="3. 在派生类中引用基类成员"></a>3. 在派生类中引用基类成员</h2><p>但是：<br /><code>private</code>变量不能通过<code>using</code>获得<br /><code>using</code>的使用更像是配合<code>private</code>继承来使用，通过基类的<code>public</code>来暴露接口。<br />代码如下：<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676978836927-6bb01102-9146-4096-af88-b5a8cbadf1cb.webp"><br>如上图代码所示，尽管派生类 Derived 对 基类 Base 是私有继承，但通过 using 声明，派生类的对象就可以访问基类的 proteced 成员变量和 public 成员函数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;array&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;dis1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;dis2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>:<span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::dis1;<span class="comment">//需要在BaseA的public下释放才能对外使用，</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis2show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">dis2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    BaseA ba;</span><br><span class="line">    ba.<span class="built_in">dis1</span>();</span><br><span class="line">    ba.<span class="built_in">dis2show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：using只是引用，不参与形参的指定。</strong></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first name space</span></span><br><span class="line"><span class="keyword">namespace</span> first_space &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// second name space</span></span><br><span class="line">    <span class="keyword">namespace</span> second_space &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> first_space::second_space;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This calls function from second name space.</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by DELL on 2023/2/21.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A::<span class="built_in">f</span>();</span><br><span class="line">    B::<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1213</span></span><br><span class="line">-------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A::<span class="built_in">f</span>();</span><br><span class="line">    B::<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line">-------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A::<span class="built_in">f</span>();</span><br><span class="line">    B::<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> B::f;; <span class="comment">// no error</span></span><br><span class="line">    <span class="built_in">f</span>(); </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">//why 2?</span></span><br><span class="line">    <span class="comment">// 12122</span></span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> B::f;; <span class="comment">// no error</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">//</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="comment">// 222</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 如果是B::f，那就是特殊引用，所以就不会再次被覆盖了，如果是全部的，就会被特殊引用被覆盖<br /> <strong>一般引用可以被特殊引用覆盖，但是不能被另外的一般引用覆盖；特殊引用不可以被另外的特殊引用覆盖（会报错），不会被另外的一般引用覆盖（无报错），相当于重新引用了一般引用。但是还可以使用B::f</strong><br /> </p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数重载匹配顺序问题</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8C%B9%E9%85%8D%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8C%B9%E9%85%8D%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="最佳匹配原则"><a href="#最佳匹配原则" class="headerlink" title="最佳匹配原则"></a><strong>最佳匹配原则</strong></h2><p>一般来说，精确匹配肯定比需要类型转换的匹配要更好，但是当形参有多个，并且无法完全精确匹配的时候，要确定最佳匹配函数就有点困难了。<br />但是有下面的原则：</p><ul><li>函数的每个实参的匹配都不能比其他可行函数更差</li><li>函数至少有一个实参的匹配要比其他可行函数更好</li></ul><p>那么问题又来了，什么是更好，什么又是更差呢？编译器将实参类型到形参类型的转换划分了等级：</p><ul><li>精确匹配，包括实参类型和形参类型相同，实参从数组或函数转换成对应的指针类型，向实参添加顶层const或从实参删除顶层const</li><li>通过const转换实现的匹配</li><li>通过类型提升实现的匹配</li><li>通过算数类型转换实现的匹配</li><li>通过类类型转换实现的匹配</li></ul><h2 id="最佳匹配原则-1"><a href="#最佳匹配原则-1" class="headerlink" title="最佳匹配原则"></a><strong>最佳匹配原则</strong></h2><p>一般来说，精确匹配肯定比需要类型转换的匹配要更好，但是当形参有多个，并且无法完全精确匹配的时候，要确定最佳匹配函数就有点困难了。<br />但是有下面的原则：</p><ul><li>函数的<strong>每个实参</strong>的匹配都不能比其他可行函数更差</li><li>函数<strong>至少有一个实参</strong>的匹配要比其他可行函数更好</li></ul><p>那么问题又来了，什么是更好，什么又是更差呢？编译器将实参类型到形参类型的转换划分了等级：</p><ul><li><strong>精确匹配</strong>，包括实参类型和形参类型相同，实参从数组或函数转换成对应的指针类型，向实参添加顶层const或从实参删除顶层const</li><li>通过<strong>const转换</strong>实现的匹配</li><li>通过<strong>类型提升</strong>实现的匹配</li><li>通过<strong>算数类型转换</strong>实现的匹配</li><li>通过<strong>类类型转换</strong>实现的匹配</li></ul><p>等级越前，匹配也就越好</p><h2 id="通过const转换实现的匹配"><a href="#通过const转换实现的匹配" class="headerlink" title="通过const转换实现的匹配"></a><strong>通过const转换实现的匹配</strong></h2><p>所谓通过const转换实现的匹配，指的是通过加const限定词，能够与可行函数精确匹配。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int f(string &amp;a)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;call function 1&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">const</span> string &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call function 2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string test = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="built_in">f</span>(test);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，test可以通过const转换，从而匹配函数2，将能够找到最佳匹配函数2（当前情况它也只有一个可选了）。<br />运行结果如下：<br /><code>call function 2</code>                                    <br />如果把函数1的注释去掉再运行，就会发现，虽然第一个调用既能匹配函数1，也能匹配函数2，但是由于匹配函数2的时候，需要const转换，因此比精确匹配要差，最终，它会调用函数1。<br />去掉函数1的注释后，运行结果如下：<br /><code>call function 1</code>                                       </p><h2 id="通过类型提升实现的匹配"><a href="#通过类型提升实现的匹配" class="headerlink" title="通过类型提升实现的匹配"></a><strong>通过类型提升实现的匹配</strong></h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676996152512-8feeb0a4-f035-4300-b3a7-4ae320476f43.png" alt="image.png"><br>关于类型提升，这里不多做介绍。简单说明类型提升规则：</p><ul><li>float将提升到double</li><li>char、short和相应的signed、unsigned类型将提升到int</li></ul><p>我们来看一个示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int f(short a)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;call function 1&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call function 2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">short</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，我们暂时把函数1注释掉。由于a是short类型，但是通过类型提升，可以转换为int，因为它也能调用函数2。运行结果如下：<br /><code>call function 2</code> <br />但去掉函数1注释后，由于精确匹配优于通过类型提升的匹配，因此将会调用函数1，运行结果如下：<br /><code>call function 1</code></p><h2 id="通过算术类型转换实现的匹配"><a href="#通过算术类型转换实现的匹配" class="headerlink" title="通过算术类型转换实现的匹配"></a><strong>通过算术类型转换实现的匹配</strong></h2><p>short int和float，double等之间的转换，都是算术类型之间的转换。我们仍然来看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call function 1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call function 2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">short</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，short类型的a既可以通过<strong>类型提升转换为int</strong>，也可以通过<strong>算术类型转换成为double</strong>。这个时候，哪个才是最佳匹配呢？我们看运行结果：<br /><code>call function 1</code> <br />对于这个结果，并不意外，因为前面我们已经说到，<strong>通过类型提升的转换是优于算术转换的</strong>，因而函数1是它的最佳匹配函数。</p><h2 id="二义性示例"><a href="#二义性示例" class="headerlink" title="二义性示例"></a><strong>二义性示例</strong></h2><p>前面基本能够找到最佳匹配，我们来看一个有多个可行函数，最后却没有最佳匹配的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="comment">//函数1</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;function 1&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//函数2</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;function 2&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>函数1和函数2都是可行函数，但它们都没有在任意一个参数上比对方更好，因此将会产生二义性，编译时将会报错：<br /><code>error: call of overloaded ‘f(int, int)’ is ambiguous</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>调用重载函数时，应当避免强制类型转换。</li><li>设计重载函数时应<strong>避免可能产生的二义性。</strong></li><li>如果<strong>无法找到可行函数，编译器将报错。</strong></li><li>设计重载函数的时候，希望避免需要用到上面的知识，而在定位问题时能够利用上面的知识很快定位问题。</li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">short</span> w)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;function int&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">long</span> w)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;function long&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">23141592</span>;</span><br><span class="line">    <span class="built_in">func</span>(i); <span class="comment">// error Call to &#x27;func&#x27; is ambiguous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">short</span> w)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;function short&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">long</span> w)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;function int&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">7</span>; <span class="comment">// char-&gt;int 优于char-&gt;short</span></span><br><span class="line">    <span class="type">short</span> s = <span class="number">4</span>; <span class="comment">// short-&gt;int 优于 short-&gt;long</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">func</span>(i); <span class="comment">// int-&gt;long or int-&gt;short 有二义性</span></span><br><span class="line">    <span class="built_in">func</span>(s);</span><br><span class="line">    <span class="built_in">func</span>(c); <span class="comment">// char-&gt;short or char-&gt;long 有二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>inline</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/inline/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/inline/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u010150046/article/details/73823539">https://blog.csdn.net/u010150046/article/details/73823539</a></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>page0</title>
      <link href="/2023/02/27/page0/"/>
      <url>/2023/02/27/page0/</url>
      
        <content type="html"><![CDATA[<p>4444444</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2023/02/27/hello-world/"/>
      <url>/2023/02/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第七课 存储器</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>第七课 存储器.md<a name="Bj1VP"></a></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>存储器(Memory )由一定数量的单元【一个单元往往存储的是一个字节】构成，每个单元可以<strong>被唯一标识</strong>，每个单元都有<strong>存储一个数值</strong>的能力</p><ul><li><strong>址</strong>：单元的唯一标识符（采用二进制）</li><li><strong>地址空间</strong>：可唯一标识的单元总数</li><li><h1 id="寻址能力∶存储在每个单元中的信息的位数，即内存中能被单独识别并独立存放一个数据的最小内存空间-大多数存储器是字节-8bit-寻址的，32位计算机的最大寻址空间为4GB"><a href="#寻址能力∶存储在每个单元中的信息的位数，即内存中能被单独识别并独立存放一个数据的最小内存空间-大多数存储器是字节-8bit-寻址的，32位计算机的最大寻址空间为4GB" class="headerlink" title="寻址能力∶存储在每个单元中的信息的位数，即内存中能被单独识别并独立存放一个数据的最小内存空间 - 大多数存储器是字节(8bit )寻址的，32位计算机的最大寻址空间为4GB "></a><strong>寻址能力</strong>∶存储在每个单元中的信息的位数，即<strong>内存中能被单独识别并独立存放一个数据的最小内存空间</strong><br> - 大多数存储器是字节(8bit )寻址的，32位计算机的最大寻址空间为4GB<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/967952ba4e1b290af0e1170cb711f7f9.svg"> </h1><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/77bd38e6cb7126e96b7a68955b408bd0.svg">。<br><a name="taQ02"></a></li></ul><h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666253958970-418b3025-a214-4fa8-aa46-706fa6efa141.png" alt="image.png"></p><ol><li>层次结构的原因：在<strong>成本</strong>的限制下，达到容量和速度的兼容。<br><a name="XFbYN"></a></li></ol><h3 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h3><ul><li>双稳态：没有外部信号，会保持目前所处的状态</li><li>单稳态：只能处于一种状态，给予一种刺激由0变为1后，会慢慢变为0 – 类似弹簧</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666254345494-87a5d603-a811-4b9c-829f-ef154d153ff2.png" alt="image.png"><br><a name="pCACJ"></a></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>介质：半导体<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666254421485-b941dcbc-e923-474c-8211-dbf4d265860b.png" alt="image.png"></p><ul><li>U盘属于快闪存储器<code>flash</code>的一种</li><li><strong>易失性：断电后数据是否能够保存</strong><br><a name="n2oKf"></a></li></ul><h3 id="读写存储器"><a href="#读写存储器" class="headerlink" title="读写存储器"></a>读写存储器</h3><p><a name="oGcG1"></a></p><h4 id="随机存取存储器-RAM"><a href="#随机存取存储器-RAM" class="headerlink" title="随机存取存储器 RAM"></a>随机存取存储器 RAM</h4><ol><li>反面：顺序存储器-磁带。需要倒带到特定顺序才能播放</li><li>随机不是代表位置的存取是随机的，而是代表时间是相同的</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666254829463-6a3bbbcd-da16-4124-9c15-d8e0d4b3b188.png" alt="image.png"><br><a name="qy6gs"></a></p><h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668405615011-cf967293-5688-4e45-b96c-c6ffcd502f0b.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671717235240-4933daf0-c023-4cb9-9503-3ab3edb7fd28.png" alt="image.png"><br /><strong>写0操作</strong><br />写0的时候，首先将BL输入0电平，（～BL）输入1电平。<br />然后，相应的Word Line（WL）选通，则M5和M6将会被打开。<br />0电平（来自BL）输入到M1和M2的G极控制端<br />1电平（来自~BL）输入到M3和M4的G极控制端<br />因为M2是P型管，高电平截止，低电平导通。而M1则相反，高电平导通，低电平截止。<br />所以在0电平的作用下，M1将截止，M2将打开。（～Q)点将会稳定在高电平。<br />同样，M3和M4的控制端将会输入高电平，因NP管不同，M3将会导通，而M4将会截止。Q点将会稳定在低电平0。<br />最后，关闭M5和M6，内部M1,M2,M3和M4处在稳定状态，一个bit为0的数据就被锁存住了。<br />此时，在外部VDD不断电的情况下，这个内容将会一直保持。<br><a name="ZpF7B"></a></p><h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666256057739-fcc9773c-f2f1-4a7e-b79d-e1115e22688d.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671717878470-c9fb358e-d087-4340-ae21-caad67462b49.png" alt="image.png"><br />其<strong>写操作</strong>相对简单：（我们以写1为例）<br />当需要写1的时候，先将BL（Bit Line）输入高电平1，然后选中对应的Word Line（同一时间将只有一根WL被选中）, 打开相应的MOS管，如图中所示3号位。此时，外部驱动能力很强，通过一定的时间，4号位的电容将会被充满。此时，关闭3号位的MOS管。内容1将在一定时间内被保存在4号位的电容中。写0的操作与之相反，不同的是将4号位电容中的电荷通过Bit Line放光。然后关闭3号位的MOS管，锁存相应数据。<br />而<strong>读操作</strong>相对来说，较为复杂。我们可以观察到4号位电容非常小，只有pF级别，而Bit Line往往都很长，上面挂了非常多个存储单元（cell），我们可以通过5号位的电容来表示。所以当我们直接把3号位的MOS管打开，Bit Line上将基本看不到什么变化，所以需要<strong>刷新放大器</strong><br><a name="hjPYy"></a></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666256145999-760adee0-9ba5-4380-9fc9-5a158714a86d.png" alt="image.png"></p><ol><li>因为是双稳态触发器，所以不需要刷新</li><li>L3是共享的缓存</li><li>SRAM常用做CPU中的<strong>高速处理器</strong></li><li>图中黑色方块为DRAM中的芯片，存储阵列。能够拥有<strong>比较大的存储空间</strong><br><a name="mzURA"></a></li></ol><h4 id="SRAM和DRAM的区别"><a href="#SRAM和DRAM的区别" class="headerlink" title="SRAM和DRAM的区别"></a>SRAM和DRAM的区别</h4><ul><li>SRAM成本比较高（6 个场效应管组成一个存储单元）DRAM成本较低（1个场效应管加一个电容）</li><li>SRAM存取速度比较快 DRAM存取速度较慢（电容充放电时间）</li><li>SRAM一般用在高速缓存中 DRAM一般用在内存条里</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671718033563-5232ce07-47e9-4e42-94f8-95a1cac280c7.png" alt="image.png"><br />动态存储器的定期刷新：在不进行读写操作时，DRAM 存储器的各单元处于断电状态，由于漏电的存在，保存在电容CS 上的电荷会慢慢地漏掉，为此必须定时予以补充，称为刷新操作<br><a name="PWrZ3"></a></p><h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><p><a name="UFvGB"></a></p><h4 id="只读存储器-ROM"><a href="#只读存储器-ROM" class="headerlink" title="只读存储器 ROM"></a>只读存储器 ROM</h4><p>好处：批量生产，能够节约成本—能达到一定的销售量<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666256377069-26da4fa4-5e53-43f3-8206-423c79ffe76b.png" alt="image.png"><br><a name="U8LA9"></a></p><h4 id="可编程ROM-（PROM）"><a href="#可编程ROM-（PROM）" class="headerlink" title="可编程ROM （PROM）"></a>可编程ROM （PROM）</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666257357441-ce4c16cc-6afd-4f43-a39a-3d9599c20623.png" alt="image.png"><br><a name="h8zhH"></a></p><h3 id="主要读的存储器"><a href="#主要读的存储器" class="headerlink" title="主要读的存储器"></a>主要读的存储器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671709158151-5c2175ab-4cb3-451e-bf5f-a02f46a2e501.png" alt="image.png"><br><a name="qSigr"></a></p><h4 id="EPROM"><a href="#EPROM" class="headerlink" title="EPROM"></a>EPROM</h4><p>缺点：</p><ol><li>不精准。芯片级的擦除，一次照射，所有的位元都会清除。</li><li>擦除时间受玻璃材质影响大</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671709272746-8078e179-56b6-4508-b232-3b11039cd711.png" alt="image.png"><br><a name="ty89k"></a></p><h4 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667290556906-7e500d52-fe1b-4f87-ba5d-551781cbc4f2.png" alt="image.png"></p><ol><li>DRAM比SRAM需要更多的引脚，拥有的内存更大</li><li>存储阵列所使用的线更少 4<em>4 VS 2</em>8<br><a name="ozdnc"></a></li></ol><h4 id="快闪存储器"><a href="#快闪存储器" class="headerlink" title="快闪存储器"></a>快闪存储器</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671709396073-4cefab9d-b3d8-4846-bed4-086a8fa06292.png" alt="image.png"><br><a name="YCQx3"></a></p><h3 id="从位元到主存"><a href="#从位元到主存" class="headerlink" title="从位元到主存"></a>从位元到主存</h3><p><a name="B5a0Z"></a></p><h4 id="寻址单元"><a href="#寻址单元" class="headerlink" title="寻址单元"></a>寻址单元</h4><p>在寻址单元中放入多少个位元，称为寻址模式<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671709520566-2f9928de-8b40-4a24-b699-e7817ea04d70.png" alt="image.png"><br><a name="d2Ue4"></a></p><h4 id="存储阵列"><a href="#存储阵列" class="headerlink" title="存储阵列"></a>存储阵列</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671709638263-ed6adc43-9914-45ff-8d7f-25739968d4db.png" alt="image.png"></p><ul><li>对于100个寻址单元构成的存储阵列，1<em>100需要100根线；10</em>10只需要20根线</li><li>缓冲器：进行行地址和列地址的复用；在使用译码器进行解析</li><li>刷新计时器：内存主要由DRAM组成，由于电容的自然丢失，需要不断刷新</li></ul><p>DRAM本身很大，引脚的使用量大，需要行列的复用<br />SRAM容量较小，不需要行列的复用<br><a name="kLFYL"></a></p><h5 id="如何寻址：获得总线控制权"><a href="#如何寻址：获得总线控制权" class="headerlink" title="如何寻址：获得总线控制权"></a>如何寻址：获得总线控制权</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671710528848-98166ff8-0dc2-4316-a793-e6959d24fa54.png" alt="image.png"><br><a name="F5JwS"></a></p><h5 id="如何寻址：行访问"><a href="#如何寻址：行访问" class="headerlink" title="如何寻址：行访问"></a>如何寻址：行访问</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259209097-929a92c0-4753-4d8a-b8cb-f2601832a6ca.png" alt="image.png"></p><ol><li>CPU获得总线的控制权，进行行的访问（行地址和列地址都是32位，不进行区分）</li><li>CPU发送地址</li><li>控制器进行分解</li><li>发出行地址<br><a name="LwqZ5"></a></li></ol><h5 id="如何寻址：列访问"><a href="#如何寻址：列访问" class="headerlink" title="如何寻址：列访问"></a>如何寻址：列访问</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259229644-a2ab2965-7d3a-48b2-9068-09a40b35d5e7.png" alt="image.png"><br><a name="CWPKp"></a></p><h5 id="地址译码器"><a href="#地址译码器" class="headerlink" title="地址译码器"></a>地址译码器</h5><p>n位地址0101110……可以产生</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/055ce37910d06a8239ef5a1ee87765f5.svg">种输出，每一种输出就是一个电信号，代表选中，从而实现选择<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259306532-4e7dacf5-e19b-4d31-b1d9-ce1759c9066c.png" alt="image.png"><br><a name="Dbpcu"></a></p><h5 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h5><ul><li>集中式刷新：在具体的时间内，逐行刷新，但是停止CPU的读写操作了，内存一会工作一会不工作</li><li>分散式刷新：将集中分散到每一次读写操作中。刷新的时间和集中式刷新是差不多的，因为电容的流失不至于太快。不会出现不可访问的阶段</li><li>异步刷新：只要电容在一定时间内刷新即可，不被访问就刷新，一直被访问就强制刷新。读一行，刷另外一行</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259483211-26d40a9a-22d4-4248-a49f-97b249d4009d.png" alt="image.png"><br><a name="zz743"></a></p><h4 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h4><p>对存储阵列进行封装<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671712290026-d31348b2-b77c-46db-af2c-fc33f5c88c62.png" alt="image.png"><br><a name="f7itY"></a></p><h4 id="模块组织"><a href="#模块组织" class="headerlink" title="模块组织"></a>模块组织</h4><p>将芯片组织起来<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671712414530-dfadf9b4-2be0-4913-8852-136cefd3c093.png" alt="image.png"></p><ul><li>位扩展：寻址单元的个数没有变化，改变的是寻址单元内位元的个数&#x2F;改变的是寻址模式<ul><li>地址线决定的是有多少行、有多少列，此时不变</li><li>数据线的根数增加</li></ul></li><li>字扩展：改变的是寻址单元的个数，不改变寻址单元内的位数<ul><li>改变之前：如果<strong>行列复用</strong>，16k &#x3D; 2^14需要7根地址线；改变后：64k &#x3D; 2^16，需要8根地址线。<strong>地址线只多了一根，不复用的话多两根</strong></li></ul></li><li>字、位同时扩展：既增加寻址单元个数，也会增加寻址单元内的位数<ul><li>复用多1根，不复用多2根</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671714564708-e0fb072c-8729-47e5-b858-7cf597b9eecc.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671714679353-37b606d9-1271-479e-bee9-ac19b404163e.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671714594150-daf87b2f-5d14-4a5b-9a33-f781bd18e1ff.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671714644224-8603445c-d96f-4b74-b474-421ddc345aa6.png" alt="image.png"><br><a name="PD1bJ"></a></p><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671713522289-e9df3587-148a-48be-be4f-ec589a1135e9.png" alt="image.png"><br />红色、黄色：内存插槽，插入内存条<br />使用的是<strong>字扩展：可以访问的存储单元的个数增加了</strong><br><a name="xQdip"></a></p><h3 id="高级DRAM组织"><a href="#高级DRAM组织" class="headerlink" title="高级DRAM组织"></a>高级DRAM组织</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671716488949-7b4ba96f-542e-4eac-88e9-047846dccd3c.png" alt="image.png"><br><a name="wnwEQ"></a></p><h4 id="同步DRAM-SDARM"><a href="#同步DRAM-SDARM" class="headerlink" title="同步DRAM SDARM"></a>同步DRAM SDARM</h4><p>synchronous DRAM<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671716501948-49a3497e-e203-4d8d-badd-bced5faff0e6.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259936287-19390916-a4da-4b3e-9d75-4cd30a79e71b.png" alt="image.png"></p><ul><li>发出的是同一行数据，不需要行选</li><li>再读下一行时，需要预充电<br><a name="sapTA"></a></li></ul><h4 id="DDR-SDRAM"><a href="#DDR-SDRAM" class="headerlink" title="DDR SDRAM"></a>DDR SDRAM</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259978458-337b22e1-d15d-4714-b519-1bf3132f5096.png" alt="image.png"><br />增加数据带宽</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666260064153-ad903d08-4854-4535-8622-f574d5de09ef.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667291222104-2da8fbab-b5df-4519-9635-59b649075566.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671716590397-287de097-6087-40ce-8bef-7dacdc97093f.png" alt="image.png"><br><a name="jT70w"></a></p><h4 id="寄存器基本原理"><a href="#寄存器基本原理" class="headerlink" title="寄存器基本原理"></a>寄存器基本原理</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667292032655-b06040e3-6828-4dee-a1c2-54f97fd6e5aa.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667292100767-5786bfe8-2c9a-4330-b15a-8c72b7b0889a.png" alt="image.png"></p><ol><li>连接在同一个时钟周期上，32位的变化是同步的</li><li>寄存器很快：和CPU的时钟周期是同步的</li><li>存储数据：用到的是RS锁存器（是实现SRAM的基础）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二课 计算机的顶层视图</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E8%AF%BE%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E8%AF%BE%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>顶层设计：冯诺依曼结构&#x3D;&gt;计算机需要满足什么，具有一定的普适性。<br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662630204935-215bd08d-ddb1-4ea5-8005-be0a92cd10eb.png" alt="image.png"><br />第一台计算机：10进制<br />有反直觉的设计：2进制（最理想的进制是<code>e</code>）<br />早期：组件之间用<strong>分散方式</strong>相连，现在主要用<strong>总线方式</strong>相连<br />冯诺伊曼最重要的思想：**存储程序（Stored-program） **<br />ABC计算机是硬件编程，而不是软件编程，所以是专用计算机，而非通用计算机，不具有存储功能。<br />冯诺依曼结构将数据和程序存放在一起，而哈弗结构将两者分开。有一些ARM（Cortex-M系列）是哈佛结构，而另一些ARM（Cortex-A）是冯诺依曼结构<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663229517646-09a5e875-d19b-4aeb-bedb-644b56493d27.png" alt="image.png"><br />关键概念：</p><ul><li>指令和数据存储在单个读写存储器中</li><li>主存中的内容按位置访问，无需考虑其中包含的类型</li><li>CPU从一条指令到下一条指令以顺序方式执行（除非明确修改)</li><li>与CPU和内存交换从外部来源收集的数据</li><li>总线是连接两个或多个设备的通信通路</li></ul><p>不成比例扩展效应：计算机各个部分的发展是不同步的。目前CPU的发展速度远远快于存储，会出现速度匹配不一致的影响<br><a name="Wa1F4"></a></p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p><a name="tWsLM"></a></p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>中央处理单元&#x2F;中央处理器 定义：获取并执行指令的计算机组成部分。由一个ALU、一个控制单元和多个寄存器构成。<br />处理器 processor：含有一个或者多个内核的物理硅片。处理器是计算机组件，用于解释和执行指令。如果一个处理器包含多个内核，则称之为<strong>多核处理器 <strong>（此处定义并不精准）<br />随着时代的发展，CPU的大小几乎不变，晶体管的数量一直增加，但是有一个物理极限。每个晶体管都可以看成一个开关，传输和开关都需要时间<br />无限增大CPU的面积&#x3D;&gt;面积增大，代表着</strong>互连延迟</strong>增大。一个时钟周期需要大于最大互联延迟<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663231672408-6ffbaeb9-6d3f-4b82-ad36-986165c3946e.png"></p><ol><li>传递速度不能达到光速 </li><li>未考虑开关消耗的时间</li><li>随着面积的增加，性能相应的增加变弱了，成本显著增加了<br><a name="aWja5"></a></li></ol><h3 id="CPU相关问题"><a href="#CPU相关问题" class="headerlink" title="CPU相关问题"></a>CPU相关问题</h3><p><a name="kppA3"></a></p><h4 id="问题1：CPU的频率不能无限提高"><a href="#问题1：CPU的频率不能无限提高" class="headerlink" title="问题1：CPU的频率不能无限提高"></a>问题1：CPU的频率不能无限提高</h4><ul><li>理论限制</li></ul><ol><li>MOS管开关、脉冲通过门电路需要时间</li><li>为了信号同步，每个脉冲信号需要持续一定的时间</li></ol><ul><li>制造限制</li></ul><ol><li>芯片面积越来越大，导致连线延迟越来越大，需要保证信号在设计指定时钟周期内从芯片的一角到达另一角</li><li>频率越高（即MOS管的开关频率也越高）会导致开关（电能状态变化）损耗也越高，CPU耗电和散热会提高。Mac book air（无风扇，CPU频率低）&lt;Mac boor pro（有风扇）</li></ol><p>必须在其他条件限制下，才能说频率越高性能越好<br />解决方法：改进CPU芯片结构+领域定制，面向特定领域开发芯片<br />晶体管数量的增加为更先进、更复杂的体系结构提供了基础<br><a name="u2fXc"></a></p><h4 id="问题2：内存墙的存在"><a href="#问题2：内存墙的存在" class="headerlink" title="问题2：内存墙的存在"></a>问题2：内存墙的存在</h4><p>主存和CPU之间传输数据的速度跟不上CPU的速度<br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663233136175-44f94e9a-8ad6-40b5-bf04-43f4879b199f.png" alt="image.png"><br />对于CPU：希望速度变快<br />对于内存：希望存储空间变大<br />解决方法：采用高速缓存（Cache）— 和缓存进行交互，</p><ol><li>增加一级或多级缓存，以减少存储器访问频率并提高数据传输速率</li><li>增大总线的数据宽度，来增加每次所能取出的位数</li></ol><p>问题：怎么能保证数据总在缓存中呢？<br><a name="e7VEU"></a></p><h4 id="问题3：CPU等待I-x2F-O传输数据"><a href="#问题3：CPU等待I-x2F-O传输数据" class="headerlink" title="问题3：CPU等待I&#x2F;O传输数据"></a>问题3：CPU等待I&#x2F;O传输数据</h4><p>CPU在等待I&#x2F;O设备时保持空闲<br />解决方法：采用中断机制<br /><strong>中断：</strong><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663233507712-f20de60b-71dd-488d-8a2c-d132b63a509e.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663233744614-224f9322-ac72-4b87-8787-25b6c9997b39.png" alt="image.png"><br><br />多重中断：</p><ol><li>多个中断处理顺序排列（无优先级）</li><li>多个中断处理嵌套排列（有优先级）</li></ol><p>最大差异：优先级的概念<br><a name="OjeA4"></a></p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663234498573-a20e53dc-2b58-4023-918a-6d1fd0abd500.png" alt="image.png"><br><br />CPU中的存储器<br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663234475831-fd01e064-5c16-4604-b2c9-d4ce824a647c.png" alt="image.png"><br><a name="IlAAa"></a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><a name="kTOU0"></a></p><h4 id="兼容存储容量、速度和成本"><a href="#兼容存储容量、速度和成本" class="headerlink" title="兼容存储容量、速度和成本"></a>兼容存储容量、速度和成本</h4><p>约束：</p><ol><li>容量：越大越好</li><li>速度：跟上处理器</li><li>成本：相对于其他组件合理，难以做到又大又快</li></ol><p>约束之间的关系：更短的访问时间，更高的每比特成本<br />解决：层次式存储结构<br><br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663235019714-d824ab48-3b24-4793-a56e-183d384dd628.png" alt="image.png"><br><br />从上往下：</p><ul><li>数量越来越大</li><li>速度越来越慢</li><li>离CPU越来越远</li></ul><p>主板外存储器 -&gt; I&#x2F;O设备（外围设备，类似于鼠标、键盘）<br />CD：光驱读取<br />离线存储器：磁带（纪录片拍摄曾用）<br />需求</p><ul><li>大容量数据存储</li><li>高速性能</li></ul><p>解决方案：使用存储器层次结构而不是依赖单个存储器组件<br><a name="NjnIw"></a></p><h2 id="I-x2F-O模块"><a href="#I-x2F-O模块" class="headerlink" title="I&#x2F;O模块"></a>I&#x2F;O模块</h2><p>与CPU和内存交换从外部来源收集的数据<br /><strong>I&#x2F;O设备不是I&#x2F;O模块</strong><br><a name="sLu79"></a></p><h3 id="问题：I-x2F-O设备传输速率差异大"><a href="#问题：I-x2F-O设备传输速率差异大" class="headerlink" title="问题：I&#x2F;O设备传输速率差异大"></a>问题：I&#x2F;O设备传输速率差异大</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663235493942-615cb7d7-6fa4-4bb9-9d60-223203818b5a.png" alt="image.png"></p><ol><li>CPU和内存速度不匹配：Cache    -&gt; CPU必须直接和内存交换</li><li>CPU和I&#x2F;O设备：采用中断机制  -&gt; CPU可以和内存交换</li></ol><p>解决：</p><ol><li>设立缓冲区，实现不同设备上速度的统一</li><li>新的接口技术</li><li>不同的I&#x2F;O操作技术<br><a name="O135b"></a></li></ol><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>两大基本特征：</p><ol><li>共享：多个部件连接在同一组总线上</li><li>分时：同一时刻，总线上只能传输一个部件发送的信息</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663235900267-cc460503-e351-4eec-9398-0b9a5f3e8bc7.png" alt="image.png"><br><a name="L8rHD"></a></p><h3 id="问题：计算机部件互连复杂"><a href="#问题：计算机部件互连复杂" class="headerlink" title="问题：计算机部件互连复杂"></a>问题：计算机部件互连复杂</h3><p>解决：采用总线<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663235983699-93504203-6207-4af3-beee-38284226035c.png" alt="image.png"></p><p><a name="EQFk2"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663236054178-9d84a416-00bd-4419-b883-6107eb085de8.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第五课 浮点数运算</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%94%E8%AF%BE%20%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%94%E8%AF%BE%20%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p><a name="igMSi"></a></p><h2 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665650022766-f9e0c767-60a8-48d5-8b67-8d57ba152f3b.png" alt="image.png"></p><ol><li>尾数右移时，需要返回原来的隐藏位<code>1</code></li><li>尾数右移时，需要保持负号不变，在数值高位补<code>0</code>，但不改变符号位<br><a name="DeX3z"></a></li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665653840660-c16ae184-7d93-4e26-b060-50d96009fb3a.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665653694954-dc90dddc-91f1-4521-afd4-0a10467431a0.png" alt="image.png"><br><br /><strong>有进位要去掉进位</strong>，再进行左规<br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665826155336-ebc1c0bf-aa67-44ef-96de-2d7636217132.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665653514684-ee78ded2-8544-4e89-9a0c-0ae8290d58a0.png" alt="image.png"><br><a name="OfVdC"></a></p><h2 id="乘除"><a href="#乘除" class="headerlink" title="乘除"></a>乘除</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665650671642-12e369a6-b8eb-44cc-aa08-c06023ccb4cd.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665654392640-b83d1468-53f0-472b-a872-3113abdb4c03.png" alt="image.png"><br><a name="ww3nZ"></a></p><h2 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666086972475-e8ee49d0-503d-4407-ac4f-3fdd385db9e3.png" alt="image.png"><br><a name="fw9V3"></a></p><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665651221721-286719f7-7ebe-4a6d-b1d8-dccd815e8e4e.png" alt="image.png"><br />最大允许阶值 &#x3D; 127<br />最小允许阶值 &#x3D; -126<br /><strong>阶值 &#x3D; 阶码的二进制解释 - 偏置常数</strong><br /><strong>在浮点数的表示中，阶码全1和阶码全0都有特殊含义</strong><br><a name="DX7Bp"></a></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666086860494-e5bafb9f-2855-4c4d-be50-cac243daee47.png" alt="image.png"></p><p><br />双精度：阶下溢用0表示。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665654690567-f1ac72ae-b798-4777-a0ff-f2da8da37a85.png" alt="image.png"><br><a name="YWTY5"></a></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665655265428-f33b3675-8474-44a4-988f-45696f22da9a.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666080813814-89570370-a4e8-4b86-ae86-56e784b4442f.png" alt="image.png"><br><a name="yvgPc"></a></p><h4 id="D-F-F-x3D-x3D-F"><a href="#D-F-F-x3D-x3D-F" class="headerlink" title="D+F-F &#x3D;&#x3D; F"></a>D+F-F &#x3D;&#x3D; F</h4><p>什么时候不成立？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> y = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-100</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> w = <span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">        <span class="keyword">if</span> ((y + w) - w != y) &#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; y+w-w&lt;&lt;&quot;!!!&quot;;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; y &lt;&lt;endl;</span></span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>i &gt;=53</code>时，不成立。因为<strong>双精度浮点数的尾数长度为52，所以，</strong><code>**1.0**</code><strong>在对阶过程中，因为阶值变成了53，所以相当于1前面增加了53个0，而尾数最长只有52，所以1就被舍去了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第九课 外部存储器</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B9%9D%E8%AF%BE%20%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B9%9D%E8%AF%BE%20%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>圆形：更方便读取数据，可以存储更多的数据</li><li>黑胶唱片：存储的是模拟信号，而不是01信号</li><li>固态硬盘比机械硬盘的抗冲击能力更好<br><a name="SMi2Q"></a></li></ul><h2 id="硬盘存储器"><a href="#硬盘存储器" class="headerlink" title="硬盘存储器"></a>硬盘存储器</h2><p><a name="j5J83"></a></p><h3 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667974491917-af4225c2-cf15-4ecf-befc-bb40c005a734.png" alt="image.png"></p><ul><li>唱针直接接触唱片，磁头不是直接接触磁盘，而是以非常小的间隙悬空</li><li>飞行高度更低，读取的面积更小，电磁感应更强，更易于读取数据</li><li>直接接触：唱片要30分钟从最外圈到最里面。而磁盘旋转速度很快，如果直接接触，会毁坏磁盘</li><li>飞行高度：几微米。<strong>无尘环境</strong><br><a name="TNBUm"></a></li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>软盘：主流为1.44MB</li><li>硬盘：主流为TB级<br><a name="jLt0B"></a></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667975348681-32192075-8856-43ee-b858-c1e0aeeb45d7.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667975624407-778c818f-1d28-4a5a-b1f0-5137756fc057.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667975638599-4665970e-09c0-4c5b-b1b3-14d7eb67fb87.png" alt="image.png"></p><ul><li>飞行高度更低了，则磁头可以更窄，这样读取的数据密度更好，一次读取的面积更少</li><li>磁头更窄，则需要离磁片的距离更近</li><li>磁盘本身不选择，而是主轴旋转</li><li>主轴连接着各层磁盘，一起旋转</li><li>磁臂<br><a name="qsLmC"></a></li></ul><h3 id="读写机制"><a href="#读写机制" class="headerlink" title="读写机制"></a>读写机制</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667975839766-06d42956-1ce0-4785-82ce-6398a63b43e8.png" alt="image.png"><br><a name="g0j4g"></a></p><h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667976121627-ee3b12b4-183a-4bec-87e1-3665fa597fa8.png" alt="image.png"><br />单磁头读取速度较慢 – 感应电流稳定也需要时间</p><blockquote><p>传统的读机制利用了磁盘相对线圈运动时在线圈中产生电流这个效应。当磁盘表面在磁头下通过时，产生一个与数据记录电流极性相同的电流。这种方式的读磁头结构本质上与写磁头结构相同，因此，同一磁头既可用于读也可用于写。这种单磁头结构主要用于软盘系统和老式硬盘系统。</p></blockquote><p><a name="BGZd8"></a></p><h4 id="读取机制"><a href="#读取机制" class="headerlink" title="读取机制"></a>读取机制</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667976555818-3773dbb7-6835-4db3-8c16-6e914b33177f.png" alt="image.png"></p><p><a name="bTRg0"></a></p><h3 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667977309941-c0e168a8-139d-4848-a741-59d52e20afd8.png" alt="image.png"><br><br />磁道间隙：防止磁场之间互相干扰<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667977536693-af6242e4-fb76-4877-8015-5280b977bae5.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667977766417-1e9b666e-ca21-442b-b511-a2e31d070daa.png" alt="image.png"></p><ul><li>速度不是恒定的 -&gt; 同一个区域以相同的角速度，不同区域角速度不同<br><a name="NyJUk"></a></li></ul><h3 id="格式化类型"><a href="#格式化类型" class="headerlink" title="格式化类型"></a>格式化类型</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667978388155-08c93ebb-6f91-44a1-b3ab-e37f3b64745d.png" alt="image.png"></p><ul><li>工业生产不进行格式化 </li><li>道号：柱面号</li><li>头号：一个磁盘是两面的</li><li>同步字节：同步字节是一个特殊的位模式，用来定义区域的起始点。</li><li>间隙2：判断现在的扇区是不是目的扇区，因此会产生延迟。如果没有间隙，则可能判断后数据已经略过了。<strong>间隙不被磁化</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667978755789-11eecfac-150d-465c-94d4-14e43a8f963a.png" alt="image.png"><br><a name="X0tHx"></a></p><h3 id="IO访问时间"><a href="#IO访问时间" class="headerlink" title="IO访问时间"></a>IO访问时间</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979061166-1aba53d5-c831-4b94-88b1-822df961c736.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979071278-a3e97956-36e4-4d90-96a6-fd6d4bd5977a.png" alt="image.png"><br><a name="YNBtC"></a></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote><p> <strong>RPM的全称为“Revolutions Per Minute”，即转每分，表示设备每分钟的旋转次数。</strong></p></blockquote><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979209801-8427ca02-d840-48ae-9ceb-a9b41b354ec6.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979438342-a137ae18-a619-4f40-b05e-16f8f9a52521.png" alt="image.png"><br />硬盘的7200rpm的意思是7200（转&#x2F;每分钟）。每旋转一周所需时间为60×1000÷7200&#x3D;8.33毫秒，则平均旋转延迟时间为8.33÷2&#x3D;4.17毫秒(平均情况下，需要旋转半圈)。<br />一个5400(转&#x2F;每分钟)的硬盘，平均旋转延迟时间为60×1000÷5400÷2&#x3D;5.56毫秒。7200转理论上比5400转快15%。</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979406165-3376c66b-3856-4cae-8de5-f2dd086de6f3.png" alt="image.png"></p><p><a name="qxD1u"></a></p><h3 id="磁头寻道-x2F-磁盘调度"><a href="#磁头寻道-x2F-磁盘调度" class="headerlink" title="磁头寻道&#x2F;磁盘调度"></a>磁头寻道&#x2F;磁盘调度</h3><p><a name="KaEOY"></a></p><h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务 FCFS"></a>先来先服务 FCFS</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979729752-9414d879-7952-4960-bcb3-d00772920845.png" alt="image.png"><br><a name="LnQXn"></a></p><h4 id="最短寻道时间优先-SSTF"><a href="#最短寻道时间优先-SSTF" class="headerlink" title="最短寻道时间优先 SSTF"></a>最短寻道时间优先 SSTF</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979701347-5edf41e6-38c4-4ae4-b93c-6a740efe2a56.png" alt="image.png"><br />饥饿现象：如果一直要访问88 91 93 85，则只会在90号左右磁道进行，而忽略了两端的磁道请求<br><a name="Bp3r9"></a></p><h4 id="扫描-x2F-电梯-SCAN"><a href="#扫描-x2F-电梯-SCAN" class="headerlink" title="扫描&#x2F;电梯 SCAN"></a>扫描&#x2F;电梯 SCAN</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979835267-6fcba46f-329f-4fd0-b88c-884ec2f229e8.png" alt="image.png"><br><a name="bsNts"></a></p><h4 id="循环扫描-C-SCAN"><a href="#循环扫描-C-SCAN" class="headerlink" title="循环扫描 C-SCAN"></a>循环扫描 C-SCAN</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667980013055-dbe047d5-4f4a-42c6-8811-e9b5c0176dd2.png" alt="image.png"><br><a name="kQe6F"></a></p><h4 id="LOOK"><a href="#LOOK" class="headerlink" title="LOOK"></a>LOOK</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667980109452-f2004148-61a4-4a2b-a816-1e5daf3dcc61.png" alt="image.png"><br><a name="OTieV"></a></p><h4 id="C-LOOK"><a href="#C-LOOK" class="headerlink" title="C-LOOK"></a>C-LOOK</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667980125327-aeb9d22b-f96d-43ff-8f3c-1c69cbdf858f.png" alt="image.png"><br><a name="lDoSx"></a></p><h2 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668068497471-c0c8ee1d-976d-4c0e-bd26-35e610474bcd.png" alt="image.png"><br><a name="DDq0y"></a></p><h3 id="CD和CD-ROM"><a href="#CD和CD-ROM" class="headerlink" title="CD和CD-ROM"></a>CD和CD-ROM</h3><p> <img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668068916438-8895820d-4e36-429a-9a6e-0b66239c0cb1.png" alt="image.png"></p><ul><li>反射材料镀在凹坑上层</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070099129-25b37516-28c4-4967-8900-5002d8648d20.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070082295-b6295688-1184-4bd5-87fc-8f6cbec362de.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070266457-a94a372a-1c11-4132-a786-47902e37fc60.png" alt="image.png"><br><a name="Q5BMg"></a></p><h3 id="DVD-数字多功能光盘"><a href="#DVD-数字多功能光盘" class="headerlink" title="DVD 数字多功能光盘"></a>DVD 数字多功能光盘</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070319093-78de051e-b5a1-468f-b961-922700d82db8.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070488965-698e80ec-9258-4faa-ae7e-c1dac54677d6.png" alt="image.png"></p><blockquote><p>波长和分辨两点的最小距离是正相关的</p></blockquote><p><a name="OAJ80"></a></p><h2 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070613542-32dc61e3-43be-449f-8758-edc1dce4d1d1.png" alt="image.png"><br><a name="XktPM"></a></p><h2 id="U盘和固态硬盘"><a href="#U盘和固态硬盘" class="headerlink" title="U盘和固态硬盘"></a>U盘和固态硬盘</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668071962854-273edac4-ddc3-425c-a360-50138c4cefe0.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668071953942-579a9213-42b4-46dd-ba97-543fe6964224.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第六课 二进制编码的十进制数运算</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%85%AD%E8%AF%BE%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%85%AD%E8%AF%BE%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>使用原因</p><ul><li>精度限制</li><li>转换成本高</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666081387420-f366e86a-ff4f-4eeb-8311-fe2d76e27c1a.png" alt="image.png"><br><a name="fSLnM"></a></p><h3 id="加法溢出判定"><a href="#加法溢出判定" class="headerlink" title="加法溢出判定"></a>加法溢出判定</h3><p><a name="uY2xc"></a></p><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><ol><li>如果产生了进位1加0110</li><li>如果没产生进位，但是大于9了，产生进位</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666081877406-8d3e57a1-7d04-407c-bd20-78852572edcc.png" alt="image.png"><br /><strong>总是加上6</strong><br /><strong>0101+1001 &#x3D; 1110 【14】(BCD码中无法得到14) + 0110 &#x3D; 0100</strong><br />10进位和16进位刚好差一个6，所以补上6即可</p><blockquote><p>25 + 39 &#x3D; 64<br>需要额外增加 0110 原因是产生了进位。虽然表面上没有直接的1进位产生。但是，是<strong>用10进制的形式</strong>来进行计算，此时1110已经大于10了，所以产生了进位</p></blockquote><p><a name="d5pZC"></a></p><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666082710595-3a11b950-5693-4d5d-84c2-d5249e416b34.png" alt="image.png"><br><br /><code>0000</code> 直接反转 得到 <code>1111</code> &#x3D; 15 -$x$<br />但实际上需要得到$9-x$<br />所以</p><ol><li>按位反转，得到 $15-x$，添加<code>1010</code> 得到$25-x$，又因为最大值为<code>16</code>所以会自动减16 得到$9-x$</li><li>添加<code>0110</code>，得到 $x+6$,再按位反转，得到$15-(x+6) &#x3D; 9-x$<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666083071821-d2e8151f-cdcc-47ea-9961-1813f5ac9673.png" alt="image.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第八课 高速缓存器</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%85%AB%E8%AF%BE%20%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%99%A8/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%85%AB%E8%AF%BE%20%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>对于直接映射的块交换还无法形成完整的逻辑自洽<ul><li>如何求的块内地址、标记、cache行号</li><li><strong>如何根据主存地址去寻找</strong></li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667292334410-03283cfc-3b29-4262-9e22-71ef3dbb1bc2.png" alt="image.png"><br />寄存器和<code>Cache</code>就集成在CPU中了<br />内存墙：CPU的速度比内存（受限于电容）的速度快得多<br />解决：CPU和内存之间增加<code>Cache</code><br><a name="CaZuv"></a></p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p><a name="CSLN2"></a></p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667292567472-9d5959d8-a0e0-44c1-93c8-4196b1beaaac.png" alt="image.png"><br><a name="yX2VV"></a></p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667292699652-b0ed8ba5-ae22-433b-b333-890d38384200.png" alt="image.png"></p><ul><li>如何判断是命中还是未命中？</li><li>如果未命中，为什么不直接把所需要的字从内存传送到CPU？<ul><li>时间局部性</li></ul></li><li>如果未命中，为什么从内存中读入一个块而不只读入一个字？<ul><li>空间局部性</li></ul></li><li>使用<code>Cache</code>后需要更多的操作，为什么还可以节省时间？<ul><li><br /><a name="WvfYN"></a></li></ul></li></ul><h4 id="命中VS未命中"><a href="#命中VS未命中" class="headerlink" title="命中VS未命中"></a>命中VS未命中</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667293060253-505d30ef-10f6-4824-95fc-6d3e8a72b7f7.png" alt="image.png"><br />通过这种映射关系判断有无命中<br><a name="BLU4w"></a></p><h4 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667293140962-04cc6eae-a14c-4b3f-93be-d17bf41743bc.png#averageHue=%23f0eeee&clientId=u06f12690-f928-4&from=paste&height=294&id=ue781c9ad&name=image.png&originHeight=367&originWidth=691&originalType=binary&ratio=1&rotation=0&showTitle=false&size=94471&status=done&style=shadow&taskId=udb808d65-418b-4d5d-8d33-e712d39e5e7&title=&width=552.8" alt="image.png"><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667294596527-0cf700f6-71c6-444b-acb7-b1c0b5392e3c.png" alt="image.png"></p><ul><li>把块给<code>Cache</code>，把字给处理器</li><li>两种方式时间开销上无较大差异</li><li>系统总线代表主存，主存速度很慢，而<code>CPU</code>会一直申请数据，所以需要缓冲器</li></ul><p>因为会重复访问特定的数据<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667294557008-b0914a4a-57d2-49f2-b8f2-3fd4007be848.png" alt="image.png"></p><ul><li>字在某一个块中，传递块而不是字</li><li>通过标记，判断字所在的块命中了，则字命中了&#x3D;&gt;所以块是预先划分好的</li><li>方便访问相邻数据<br><a name="h7IOU"></a></li></ul><h4 id="平均访问时间"><a href="#平均访问时间" class="headerlink" title="平均访问时间"></a>平均访问时间</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667295313429-3eb83d8c-ec9c-45d2-aab0-a5778b5f7c9b.png" alt="image.png"><br /><code>Tc</code>：做的是检查<br /><code>Ta = 检查时间+访问主存的时间（1-p 需要访问）</code></p><ol><li>降低<code>Tm</code>很难，受到电容的限制</li><li>命中率高要求cache大，而这会使访问cache时间变大<br><a name="LpKUq"></a></li></ol><h4 id="Cache未命中原因"><a href="#Cache未命中原因" class="headerlink" title="Cache未命中原因"></a>Cache未命中原因</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667295595914-e082f099-0bb8-40aa-a756-a2127b17c664.png" alt="image.png"> </p><ul><li>容量失效：原8kb的数据块访问后被后面的8kb的数据覆盖。如果再要访问到该8kb的数据，因为已经被替换了，则会失败，导致失效</li><li>冲突失效：<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667384986023-53efd5cd-671e-4f4a-b4d8-a3f6b8390d2c.png" alt="image.png"><br><a name="n370z"></a></li></ul><h3 id="Cache的设计要素"><a href="#Cache的设计要素" class="headerlink" title="Cache的设计要素"></a>Cache的设计要素</h3><ul><li>容量：太大-命中率低；太低：容量失效</li><li>映射功能：冲突失效</li><li>替换算法：用一个更小的区域放一个更大的区域，有更高概率被访问的数据留下来</li><li>写策略</li><li>Cache行大小（主存的块大小）</li><li>Cache数目<br><a name="cqwNm"></a></li></ul><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667295799998-8959f701-2751-4514-bfac-cb82477c6c18.png" alt="image.png"><br />涉及到的空间局部性和所需的数据更大，则容量设置的更大<br><a name="MlIc9"></a></p><h4 id="映射功能"><a href="#映射功能" class="headerlink" title="映射功能"></a>映射功能</h4><p><a name="WqwNQ"></a></p><h5 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667296212193-00f04372-8719-4439-a29b-a5998082176c.png" alt="image.png"></p><p>使用地址的高2位就可以<img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667296380909-54fc0771-6e3d-4ce1-aed2-bc6cf0027a2a.png#averageHue=%23e8c878&clientId=u06f12690-f928-4&from=paste&height=21&id=ub6935c40&name=8A81E895498104367421DECBCC173E3F.png&originHeight=26&originWidth=25&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1551&status=done&style=shadow&taskId=u6ecf5acd-f1f5-4ebb-b616-6636b062cb6&title=&width=20" alt="8A81E895498104367421DECBCC173E3F.png">指向具体的行<br /><code>**M是128/8=16，C=4 所以n=2：**</code><br /><strong>16个块，有4行，所以一行中有4个块，所以需要2位标记</strong><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667296502468-b839cc2a-2cf3-426a-aec8-7b6a994e409f.png" alt="image.png"><br /><code>CPU</code>寻找主存，通过主存地址进行寻找<br />一个块包含很多字，一个块对应的是<code>cache</code>中的一行。<br />所以要通过块内地址找到块中具体的字在哪里。</p><ul><li>什么是每行包含8个字：一个块包含了八个字，需要用3位二进制进行。这里的字可以理解为一个数据单元。</li><li>主存中包含128个字：所以主存地址为7位</li><li>主存和缓存是按块进行存储的</li><li>块的大小是相同的</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667296642223-21734d28-1639-4116-8a8b-9b5828c260a7.png#averageHue=%23f6f4f3&clientId=u06f12690-f928-4&from=paste&height=506&id=ucadff43d&name=image.png&originHeight=633&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&size=133543&status=done&style=shadow&taskId=u3fffeb46-09f2-4e14-81d9-9f9eceee242&title=&width=692.8" alt="image.png"><br />命中了的话再根据子块内地址找到对应的字<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667388177145-4c64d0e3-aebd-48b3-b1d2-de30698abe5d.png" alt="image.png"></p><ul><li>因为只有16行，所以只需要1位表示就行（前提是16进制）</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667388340836-59e73bb1-60ee-4569-a917-1cd05b528ab5.png" alt="image.png"><br /> <code>Cache</code>中本身不记录行号和块号，是逻辑上产生<br><a name="Xcxzr"></a></p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667463892544-629a5f53-40c6-44ad-864d-2cc90f1af93d.png" alt="image.png"></p><ul><li>行数变多：数据之间的关联性降低，因此冲突失效概率降低</li><li>电路简单：增大容量，但是映射关系仍然保持一致，所以检查时间变化不大</li><li>降低检查时间<code>Tc</code>，增加命中率，这两者直接存在矛盾。<br><a name="hzC0t"></a></li></ul><h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>一个主存块可以装入<code>Cache</code>任意一行，所以不需要记录行号了<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667464555767-4bc9de8e-c557-4d46-98f1-47547de9ee39.png" alt="image.png"><br><a name="o9XHQ"></a></p><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p>代价：</p><ol><li>需要知道哪一行是空的</li><li>要访问每一行，所以容量增大的话，则<code>Tc</code>显著增加</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667464443441-912339c9-7b78-43e0-8f95-2d115d55c81c.png" alt="image.png"><br />对于小容量，不适合直接映射<br><a name="bfLZr"></a></p><h5 id="组关联映射"><a href="#组关联映射" class="headerlink" title="组关联映射"></a>组关联映射</h5><p>将书柜分区：中文区、日文区、英文区<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667464714834-86ff1b21-3887-49fc-a8e2-b330790f4082.png#averageHue=%23f6f4f4&clientId=uaa87a2dc-af29-4&from=paste&height=258&id=uae9304a1&name=image.png&originHeight=323&originWidth=793&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81508&status=done&style=shadow&taskId=uab9e02b6-2f1f-407f-b0fe-8ec3b58c301&title=&width=634.4" alt="image.png"><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667464835947-858cc66f-18f1-4508-a464-4fc22d60ef5a.png" alt="image.png"><br><a name="t5O7u"></a></p><h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h6><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667465027916-d6c6957f-0522-4e65-a468-47ef90a89f8d.png" alt="image.png"><br><a name="hu8bR"></a></p><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667465192606-c777eb24-b3c9-4670-903a-33e5b7f672f8.png" alt="image.png"><br /><strong>K和容量、命中率、检查时间的变化</strong><br><a name="LmvZA"></a></p><h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667465463904-3cf6cdf1-0337-4c41-8fab-36ee1a1634bf.png" alt="image.png"><br />可以通过软件进行模拟，例如解决缓存问题。但本身是通过<strong>硬件</strong>实现<br />再次访问的概率相较于其他行更低？<br><a name="x1PLV"></a></p><h5 id="最近最少使用算法-LRU？"><a href="#最近最少使用算法-LRU？" class="headerlink" title="最近最少使用算法 LRU？"></a>最近最少使用算法 LRU？</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667465619658-1f43e206-092a-4a1d-ac4e-be4858032bf2.png#averageHue=%23f2f1f1&clientId=uaa87a2dc-af29-4&from=paste&height=454&id=u9967a4cb&name=image.png&originHeight=568&originWidth=819&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146966&status=done&style=shadow&taskId=udea36be2-a366-4e3b-a18e-3fda1177be6&title=&width=655.2" alt="image.png"><br />非此即彼：0&#x2F;1代表的是访问时间的近远<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667466998466-045f1ece-9b44-4523-a305-fc63938562bf.png" alt="image.png"><br><a name="iY2yC"></a></p><h5 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h5><p>仍然存储抖动现象<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667467396784-995a5bb6-3d2a-42ab-a351-4d98caa8d64f.png#averageHue=%23f6f3f2&clientId=uaa87a2dc-af29-4&from=paste&height=303&id=u1bcd893f&name=image.png&originHeight=379&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139846&status=done&style=shadow&taskId=u0e9709c5-2032-47fb-8052-e3e32164ae4&title=&width=624.8" alt="image.png"><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667467358785-5ade1a2b-31a0-4927-b26a-3eda7127e036.png" alt="image.png"><br><a name="JrlNC"></a></p><h5 id="最不经常使用算法-LFU"><a href="#最不经常使用算法-LFU" class="headerlink" title="最不经常使用算法 LFU"></a>最不经常使用算法 LFU</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667467410431-db70e4fa-499c-4b88-8f6b-afdbaa5a293b.png" alt="image.png"><br><a name="T0X33"></a></p><h5 id="随机替换算法"><a href="#随机替换算法" class="headerlink" title="随机替换算法"></a>随机替换算法</h5><p>假设的情况和真正情况的符合度较高。所有能够进入<code>Cache</code>的数据，本身都是“万里挑一的”<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667467503132-aebe0253-1371-408e-aff9-d05d7e1c5bc1.png" alt="image.png"><br><a name="gw6Sv"></a></p><h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><p><a name="JVQGR"></a></p><h5 id="缓存命中时的写策略"><a href="#缓存命中时的写策略" class="headerlink" title="缓存命中时的写策略"></a>缓存命中时的写策略</h5><p><a name="v8bXo"></a></p><h6 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h6><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667468245448-bceb6ff8-8f87-4729-b2dd-ca4e2eefd1e0.png" alt="image.png"><br><a name="VRVWw"></a></p><h6 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h6><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667468274096-63437b84-2bb1-4d6d-904a-40a4d23337e7.png" alt="image.png"><br><a name="ov8D6"></a></p><h5 id="缓存未命中时的写策略"><a href="#缓存未命中时的写策略" class="headerlink" title="缓存未命中时的写策略"></a>缓存未命中时的写策略</h5><p>写不分配：对安全要求较高的<br />写分配：程序中隐含较多时间和空间的局部性<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667468309563-d70f3f1b-5d70-4e61-8581-9f3a5932716e.png" alt="image.png"><br><a name="VfMw8"></a></p><h4 id="行大小"><a href="#行大小" class="headerlink" title="行大小"></a>行大小</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667468442985-db7915c2-ce8e-4f60-961c-986426baea6f.png" alt="image.png"><br />不是违反了时间关系，而是违反了时间局部性：<strong>重复访问存储在相同位置的信息</strong>，那么每一次找都要找很久<br />反空间局部性：**重复<br><a name="Po3ao"></a></p><h4 id="Cache数目"><a href="#Cache数目" class="headerlink" title="Cache数目"></a>Cache数目</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667468656923-5bf32d4e-8fa1-43b2-9eb4-763f086628bc.png#averageHue=%23eeeeee&clientId=uaa87a2dc-af29-4&from=paste&height=244&id=uc84faddd&name=image.png&originHeight=305&originWidth=840&originalType=binary&ratio=1&rotation=0&showTitle=false&size=97318&status=done&style=shadow&taskId=u0219c0e0-0f21-4e92-8dac-b13a61bb8f4&title=&width=672" alt="image.png"><br />冯诺依曼：指令和数据不区分。根据阶段进行区分<br />对与<code>Cache</code>，数据很快会把Cache填满，而指令也会频繁使用-都受到局部性的支配，所以需要消除竞争关系，避免冲突失效<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667468849188-a8539d6d-e141-41ab-b533-9be656164c6e.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十一课 冗余磁盘阵列</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/20131784">RAID有哪几种？有什么区别？ - 知乎</a><br /><a href="https://zhuanlan.zhihu.com/p/119452913">各种 RAID 详解</a></p><ul><li>RAID3是如何找到错误并纠错的？</li><li>RAID50 的容量利用率为什么比RAID5 高</li><li>关于RAID 2的思考题</li></ul><p>在已知坏了哪2块盘的情况下，RAID 2是否能够重构数据？</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668702216809-9f66c46f-12ee-48f1-a8f7-7d6786847a21.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668505094811-f40d5c16-15d0-4fbb-b581-cf5b565c0064.png" alt="image.png"></p><ul><li>RAID10：结合RAID0 和RAID1</li><li>大IO 小IO：大小描述数据量的多少<br><a name="YPRMc"></a></li></ul><h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h2><p>按条带的顺序而不是磁盘的顺序存储数据。从条带0、条带1……进行存储，而不是存完磁盘1后再存磁盘2<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668702198817-0a7b4ce8-592e-40fa-b868-67050c1df025.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668505569008-a1f5c31a-d2a9-4ac7-aa0d-9ef2609e126f.png" alt="image.png"><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668505609551-624c04a2-e7e6-448b-8785-6edb6834b87d.png" alt="image.png"><br />与单个大容器磁盘相比：</p><ul><li>高数据传输率：多个硬盘可以同时提供读写操作（每个硬盘都有缓存，提高传输速率）<strong>针对大的数据块</strong></li><li>高速响应I&#x2F;O请求：<strong>两个I&#x2F;O</strong>请求所需要的数据块可能<strong>在不同的磁盘上 针对的是小的IO块</strong></li></ul><p><strong>缺点：数据可靠性比单盘低。因为只要有一个磁盘出错了，整个RIAD0就无法正常工作</strong><br><a name="o5kWn"></a></p><h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h2><p>读取速度是单盘的两倍 — 因为可以同时使用两个条带<br />写入速度受限于两个条带中更慢的磁盘。</p><ul><li>优点</li></ul><ol><li>高速响应IO请求:即便是<strong>同一个磁盘上</strong>的数据块，也可以由<strong>两组硬盘（原装+备份）分别响应</strong></li><li>读请求可以由包含请求数据的两个对应磁盘中的某一个提供服务，可以<strong>选择寻道时间较小的那个（选择磁头位置离目标位置更近的）</strong></li><li>写请求需要更新两个对应的条带:可以并行完成，但<strong>受限于写入较慢的磁盘</strong>。</li><li>单个磁盘损坏时不会影响数据访问，<strong>恢复受损磁盘简单</strong></li><li><strong>小IO请求可以由两组硬盘响应，所以读取速度是单盘两倍。大IO请求可能设计到同一磁盘的多个条带，所以比单盘块，但是没有涉及到两倍的速度</strong></li></ol><ul><li>缺点：价格昂贵，有一半的磁盘用于存放冗余数据</li><li>用途</li></ul><ol><li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li></ol><ul><li>与RAIDO相比</li></ul><ol><li>如果有<strong>大批的读请求</strong>，则RAID 1能实现高速的IO速率，性能可以达到RAID 0（<strong>如果两个条带都在一个单盘上时，只能和普通单盘一样去响应</strong>）的两倍</li><li>如果IO请求有相当大的部分是写请求，则它不比RAID 0的性能好多少</li></ol><ul><li>采用了数据条带</li><li>采用简单地<strong>备份所有数据的方法</strong>来实现冗余</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668505752836-d076f564-d0ed-403d-8a25-83f60f432e05.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668506181935-38580cc6-c7cf-4a7a-b9ef-67d21ab6136c.png" alt="image.png"><br><a name="Eh0c6"></a></p><h2 id="RAID10-和-RAID01比较"><a href="#RAID10-和-RAID01比较" class="headerlink" title="RAID10 和 RAID01比较"></a>RAID10 和 RAID01比较</h2><ol><li><strong>RAID10比RAID01安全性要好</strong></li><li>RAID1的特性是同一组的磁盘互为镜像，其中一个损坏时，<strong>同组的另一个会代替损坏的继续提供服务</strong></li><li>RAID0没有冗余功能，<strong>任何一个磁盘的损坏就会导致的数据不可用。</strong></li><li>RAID01可以当做普通的RAID1</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668672966673-85910e16-3028-4e35-831b-677b1d24cff9.png" alt="image.png"><br />因此，对于RAID 01</p><ul><li>如果Disk0坏了，Disk1是不能正常工作的 – 是不能配合Disk2工作的</li><li>如果Disk3坏了，Disk2也是不能正常工作的</li></ul><p>对于RAID 10</p><ul><li>如果Disk0坏了，同组的Disk1仍然可以正常工作 – 可以配合Disk2工作</li><li>如果Disk3坏了，同组的Disk2也是可以正常工作的<br><a name="x7bwO"></a></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>RAID0解决的是条带化的问题。多个磁盘，不是独立的应用，而是条带化，一起使用</li><li>RAID1解决的是冗余的问题，通过直接的简单备份，提高数据的可用性、容错能力</li><li>RAID10和RAID01的搭配问题<br><a name="zhq8d"></a></li></ol><h2 id="RAID2"><a href="#RAID2" class="headerlink" title="RAID2"></a>RAID2</h2><p>并行存取的特点：</p><ol><li>各个驱动器的轴同步旋转</li><li>采用非常小的数据条带</li></ol><p>并行存取的目标：<strong>所有</strong>磁盘都参与<strong>每个</strong>io请求（不论大小）。<br /><strong>条带很小</strong>：写入时才能让所有磁盘都能调用。因为一个条带必须用满了才能使用下一个条带，所以条带需要很容易被填满。从而使得所有磁盘都参与进去。<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668672924570-bed0abee-c51e-462a-abdd-359a657b997c.png" alt="image.png"></p><ul><li>利用海明码校验，根据公式<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/c3c20b7c5e26e4fda0b3b2188b2355bf.svg"></li><li>在写入时，RAID 2在<strong>写入数据位同时</strong>还要<strong>计算出它们的汉明码并写入校验阵列</strong>，读取时也要对数据即时地进行校验，最后再发向系统。</li><li><strong>海明码只能对一个位的出错进行定位和纠错</strong>，所以RAID 2也只能允许一个硬盘出问题，如果两个或以上的硬盘出问题，RAID 2的数据就将受到破坏</li><li>RAID0的条带是KB级，RAID2的条带是字节级。同样很小的IO请求，RAID0只需要一个盘，RAID2需要4个数据盘</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668673179868-9c487527-463e-4f75-aa86-ac93edfcabde.png" alt="image.png"></p><ul><li>单个磁盘本身具有校验位</li></ul><p>磁盘数量：<code>n+m</code>，m个磁盘用来存储校验位<br><a name="x7Yr2"></a></p><h2 id="RAID3"><a href="#RAID3" class="headerlink" title="RAID3"></a>RAID3</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668703045075-e6abfe0f-3fb9-43de-a6c3-319d8d0d3334.png" alt="image.png"><br><br /><br>RAID 3 是把数据分成多个“位元组”，按照 一定的容错算法，连续存放在N+1个磁盘上，<strong>N个磁盘存数据，第N+1个磁盘上存储校验容错信息</strong>，当这N+1个磁盘中的一个磁盘出现故障时，依据其它N个硬盘中的数据，可以恢复完整的原始数据，这样，仅使用这N个硬盘也可以带伤继续工作（如采集和回放素材），当更换一个新硬盘后，系统可以重新恢复。<br />奇偶校验码只能发现有错，不能发现谁出错了。在RAID中，是为了防止<strong>磁盘坏了</strong>，而不是数据出错。磁盘坏了，能够清楚的<strong>明确是哪一个磁盘出错了</strong>，而数据出错则无法发现。<strong>在RAID中的冗余，是为了防止磁盘损坏</strong><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668673540430-fc64810c-9495-4467-b33e-fa1f8af415de.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668673915863-5ebb1285-2abf-4a20-a8fc-b7be05e627b4.png" alt="image.png"></p><ul><li>奇偶校验码码距是2，只具有检错的能力，不具有纠错的能力，不能纠错是因为不知道哪一位数据出错了</li><li>磁盘损坏是已知的，所以通过奇偶校验可以知道是哪一个出错了<blockquote><p>RAID 3 使用字节级别的条带化技术，并<strong>采用专用的奇偶校验磁盘</strong>。RAID 3 阵列能在一个磁盘出现故障的情况下确保数据不丢失。如果一个物理磁盘出现故障，该磁盘上的数据可以重建到更换磁盘上。如果数据尚未重建到更换驱动器上，而此时又有一个磁盘出现故障，那么阵列中的所有数据都将丢失。</p></blockquote></li></ul><p><a name="bdbj8"></a></p><h2 id="RAID4"><a href="#RAID4" class="headerlink" title="RAID4"></a>RAID4</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668674101595-1f204daf-2380-48d2-a1d2-3253f7d6f9e5.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668674199002-ba45f835-cdeb-4b73-b4e2-cfc27602f1e9.png" alt="image.png"></p><ul><li>不需要向RAID3一样所有盘都同步传动</li><li>瓶颈：写入四个盘时，都会争夺同一个校验盘（<strong>校验盘指的是一整个磁盘，因为磁盘本身是同步转动的</strong>），因此会产生瓶颈。<strong>无法实现写操作的独立</strong></li><li>两次读写：当写入一位数据时，因为需要同步修改校验码，所以需要修改校验码。同时，由于不知道其他盘的数据，因此需要知道该盘之前的数据以及之前的校验码，所以需要写两次和读两次。<strong>读两次：读旧的数据和旧的校验码，写两次：写新的数据和新的校验码</strong></li></ul><p>对于小IO请求，也需要使用奇偶校验码，看上去使用了4位，4个任务都会争夺同一个校验码。对于RAID3，因为读写同步，所以b1 b2 b3都是已知的，但是对于RAID4，写入B0时，其他的都是未知的，需要读出B1 B2 B3。所以，写入之前，先把<code>P(B)</code>   <code>B0</code>都先读出来。每一次写操作，实际上都要<strong>写两次，读两次</strong><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668674833267-027f9199-002c-493e-a577-cdc3b4b3c76a.png" alt="image.png"><br><a name="vFa3i"></a></p><h2 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h2><blockquote><ol><li>RAID5 应该是目前最常见的 RAID 等级，它的原理与 RAID4 相似，<strong>区别在于校验数据分布在阵列中的所有磁盘上，而没有采用专门的校验磁盘。</strong>对于数据和校验数据，它们的写操作可以同时发生在完全不同的磁盘上。因此， RAID5 不存在 RAID4 中的并发写操作时的校验盘性能瓶颈问题。</li><li>RAID5 的磁盘上同时存储数据和校验数据，<strong>数据块和对应的校验信息存保存在不同的磁盘上</strong>，当一个数据盘损坏时，<strong>系统可以根据同一条带的其他数据块和对应的校验数据来重建损坏的数据</strong>。与其他 RAID 等级一样，重建数据时， RAID5 的性能会受到较大的影响。</li></ol></blockquote><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668674484168-d8a5e506-0168-4d4a-9bf3-4748335df37c.png" alt="image.png"></p><ul><li>没有单独的校验盘，没有单独的数据盘</li><li>避免RAID4中集中访问同一个校验盘的现象</li><li>修改时还是会涉及到<strong>两读两写</strong></li><li><strong>在写操作时，一个平面的块都会受到影响，无法写入，但是相比RAID 4，不会对一整个磁盘造成影响。例如块0和块9，在不同平面，在RAID5中不会有冲突，但是在RAID 4中就会造成冲突</strong><br><a name="B1xwQ"></a></li></ul><h2 id="RAID-50"><a href="#RAID-50" class="headerlink" title="RAID 50"></a>RAID 50</h2><blockquote><p>RAID 5与RAID 0的组合，先作RAID 5，再作RAID 0，也就是对多组RAID 5彼此构成Stripe访问。由于RAID 50是以RAID 5为基础，而<strong>RAID 5至少需要3颗硬盘</strong>，因此要以多组RAID 5构成RAID 50，至少需要6颗硬盘。以RAID 50最小的6颗硬盘配置为例，先把6颗硬盘分为2组，每组3颗构成RAID 5，如此就得到两组RAID 5，然后再把两组RAID 5构成RAID 0。<br>RAID 50在底层的任一组或多组RAID 5中出现1颗硬盘损坏时，仍能维持运作，不过如果任一组RAID 5中出现2颗或2颗以上硬盘损毁，整组RAID 50就会失效。<br>RAID 50由于在上层把多组RAID 5构成Stripe，<strong>性能比起单纯的RAID 5高，容量利用率比RAID5要低</strong>。比如同样使用9颗硬盘，由各3颗RAID 5再组成RAID 0的RAID 50，每组RAID 5浪费一颗硬盘，利用率为(1-3&#x2F;9)，RAID 5则为(1-1&#x2F;9)。</p></blockquote><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668675235775-9454f75a-079d-41ed-863c-f1ca012cef8b.png" alt="image.png"><br />用3个磁盘空间去做奇偶校验，而如果只是RAID5，则只需要用一个磁盘的空间<br><a name="vHKMr"></a></p><h2 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h2><ul><li>前面所述的各个 RAID 等级都<strong>只能保护因单个磁盘失效而造成的数据丢失</strong>。如果两个磁盘同时发生故障，数据将无法恢复。 RAID6 引入<strong>双重校验</strong>的概念，它<strong>可以保护阵列中同时出现两个磁盘失效时，阵列仍能够继续工作，不会发生数据丢失</strong>。 RAID6 等级是在 RAID5 的基础上为了进一步增强数据保护而设计的一种 RAID 方式，它可以看作是一种扩展的 RAID5 等级。</li><li>RAID6 不仅要支持数据的恢复，还要支持校验数据的恢复，因此实现代价很高，控制器的设计也比其他等级更复杂、更昂贵。 <strong>RAID6 思想最常见的实现方式是采用两个独立的校验算法</strong>，假设称为 P 和 Q ，校验数据可以分别存储在两个不同的校验盘上，或者分散存储在所有成员磁盘中。<strong>当两个磁盘同时失效时，即可通过求解两元方程来重建两个磁盘上的数据。</strong></li><li>RAID6 具有快速的读取性能、更高的容错能力。但是，它的<strong>成本要高于 RAID5 许多，写性能也较差</strong>，并有设计和实施非常复杂。因此， RAID6 很少得到实际应用，主要用于对数据安全等级要求非常高的场合。它一般是替代 RAID10 方案的经济性选择</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668675293673-f7a370f3-3233-4932-bb5c-156b133a221c.png" alt="image.png"><br><a name="MgIW2"></a></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668703858623-88a01b8a-8ac7-48ea-a149-b293be444d8b.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668675564994-2e8d74a6-8f92-4c9d-84d9-9dce33907f99.png" alt="image.png"><br><br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668675632716-b5bb40ae-f19c-4f7c-a1c8-0ebcdd01727a.png" alt="image.png"><br><br /><br>RAID3适合大数据的单次的IO读写，按顺序读写-寻道时间更少<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668675671383-a37e8860-2040-44a5-8f23-2f33d32be087.png" alt="image.png"><br><br />RAID2 RAID4已经弃用了</p><hr><p>RAID 0：如果你有n块磁盘，原来只能同时写一块磁盘，写满了再下一块，做了RAID 0之后，n块可以同时写，速度提升很快，但由于没有备份，可靠性很差。n最少为2。<br />RAID 1：正因为RAID 0太不可靠，所以衍生出了RAID 1。如果你有n块磁盘，把其中n&#x2F;2块磁盘作为镜像磁盘，在往其中一块磁盘写入数据时，也同时往另一块写数据。坏了其中一块时，镜像磁盘自动顶上，可靠性最佳，但空间利用率太低。n最少为2。<strong>写操作可以并行完成</strong><br />RAID 3：为了说明白RAID 5，先说RAID 3.RAID 3是若你有n块盘，其中1块盘作为校验盘，剩余n-1块盘相当于作RAID 0同时读写，当其中一块盘坏掉时，可以通过校验码还原出坏掉盘的原始数据。这个校验方式比较特别，<strong>奇偶检验</strong>，1 XOR 0 XOR 1&#x3D;0，0 XOR 1 XOR 0&#x3D;1，最后的数据时校验数据，当中间缺了一个数据时，可以通过其他盘的数据和校验数据推算出来。但是这有个问题，由于n-1块盘做了RAID 0，每一次读写都要牵动所有盘来为它服务，而且万一校验盘坏掉就完蛋了。<strong>最多允许坏一块盘</strong>。n最少为3.<br />RAID 5：在RAID 3的基础上有所区别，同样是相当于是1块盘的大小作为校验盘，n-1块盘的大小作为数据盘，但校验码分布在各个磁盘中，不是单独的一块磁盘，也就是分布式校验盘，这样做好处多多。最多坏一块盘。n最少为3.<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668703844625-2b4cfea9-a8f9-4d60-adaf-232a18531f30.png" alt="image.png"></p><ul><li>RAID 3 是采取<strong>并行存取技术</strong>，所以只需要一次写操作和一次读操作就能更新校验码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十二课 虚拟存储器</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a name="nFqlT"></a></p><h3 id="分区方式"><a href="#分区方式" class="headerlink" title="分区方式"></a>分区方式</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277706527-998432e0-a2fc-4508-a459-0462d95d9259.png" alt="image.png"><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277715931-9cb5eb6d-3720-4614-8410-6308a5873c48.png" alt="image.png"><br><a name="gg4z0"></a></p><h3 id="分页方式"><a href="#分页方式" class="headerlink" title="分页方式"></a>分页方式</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277748398-0cc4a6e2-fdca-4261-aa6d-4c371ba1833b.png" alt="image.png"><br><a name="L6lhU"></a></p><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277942468-ec1e84a3-ebaa-404a-82f7-12d0f536d4cf.png" alt="image.png"><br><br />只需要保证同时<strong>需要载入的页</strong>的大小是低于主存的大小就行。对于同一个任务，其实是每个时刻只会执行部分代码段，所以只需要载入部分页进入内存就行<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277966166-0c715239-9ac1-42b2-8d05-30ecde4fc470.png" alt="image.png"></p><ol><li>所有的任务的所有的页放入硬盘的特定区域中，也就是<strong>虚拟内存</strong></li><li>每个任务正在使用的页载入主存当中</li><li>没命中时主存从硬盘中加载；有修改时，硬盘也会从主存加载</li><li>页表：对每个任务生成一个页表，记录页的状态</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277979600-731a069b-e5e4-4b80-8d9a-99071803ad2a.png" alt="image.png"></p><ul><li>全相联映射：命中率更高</li><li>写回：避免像写直达一样，多次对硬盘进行操作<br><a name="krw6M"></a></li></ul><h3 id="分页式虚拟存储器"><a href="#分页式虚拟存储器" class="headerlink" title="分页式虚拟存储器"></a>分页式虚拟存储器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669278432223-3b432e84-bedf-423a-b55a-9efc2a0488e8.png" alt="image.png"></p><ul><li>编写程序时，默认自己有一个很大的、连续的空间，所以记录在页表中的地址都是虚拟地址。</li><li>程序真正被启动时，会产生很多页面，载入硬盘中</li><li>把要用的页面真正载入主存中，由页表来记录</li><li>页表也存在主存中<br><a name="OrHIE"></a></li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669278909804-03e37ac1-149e-48c0-8717-bfab35e6db6a.png" alt="image.png"><br><a name="i21yx"></a></p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p><strong>物理页和虚拟页的大小是一样的。所以页内偏移量是一致的</strong><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669279021802-26aa3ba1-42dc-4880-b68b-4894c1759968.png" alt="image.png"></p><ul><li><code>null</code>磁盘没有存储VP0 VP4，对应的位置存储了其他信息<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669279176054-4dd0b82e-33cc-4447-9762-53cbe5f148b9.png" alt="A959A7B612035ABFFB13EF2EC4BE03A8.png"></li><li><code>PP0</code>物理页号：说明在主存中有载入</li><li>指针：说明在磁盘存储器中有，但是没有载入主存中。</li><li><strong>虚拟地址比物理地址更长</strong>，虚拟空间比物理空间更大，虚拟页号比物理页号的长度更长；<strong>存放位置时的指针长度比物理地址小</strong></li><li>不需要额外用空间记录虚拟页号，因为是按顺序排放的</li><li>**存放位置的长度是按照最长的物理地址存放的 **<br><a name="bgiXr"></a></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669279472951-53ed2a0f-fd94-4324-a79a-5247a2c03333.png" alt="image.png"><br><a name="JQN19"></a></p><h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669279512490-aad58c79-5266-41cd-8c4a-7076d662ddb1.png" alt="image.png"><br><a name="YxFIf"></a></p><h4 id="CPU访存过程"><a href="#CPU访存过程" class="headerlink" title="CPU访存过程"></a>CPU访存过程</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669280124191-614a3c12-4a15-49db-bfdd-fe3f90a7e44f.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669280143486-c3062d63-658c-4610-95dc-55cc0bf9d235.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669280570598-b997891c-1fd3-4266-a226-636230946178.png" alt="image.png"></p><ol start="2"><li>访问的是主存中的数据，因为在Cache中miss了</li><li>访问的是主存中的页表，数据仍然在Cache中</li><li>出现缺页情况，访问硬盘和访问主存速度差距非常大</li><li>TLB中有，页表中也一定有<br><a name="oXU29"></a></li></ol><h3 id="分段式虚拟存储器"><a href="#分段式虚拟存储器" class="headerlink" title="分段式虚拟存储器"></a>分段式虚拟存储器</h3><p>物理地址&#x3D; 段号左移4位+段内偏移量<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669280849606-3494bb7d-aff3-4ab5-a9b1-eaeac95777fd.png" alt="image.png"><br />分页式：对权限管理很混乱，每一个页都要单独记录权限<br />分段式：</p><ul><li>会有重复地址</li><li>长度不固定</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669281353237-f9a73a1a-49b5-4214-b7e9-149015592132.png" alt="image.png"><br><a name="huy5f"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669281422445-f6f60a5a-1b1e-4cbc-8196-882371e9d52c.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十七课 输入输出</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AF%BE%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AF%BE%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092964050-b0e027e7-bc8e-4829-a530-a148b4e45cf1.png" alt="image.png"><br><a name="nE4qE"></a></p><h2 id="I-x2F-O模块"><a href="#I-x2F-O模块" class="headerlink" title="I&#x2F;O模块"></a>I&#x2F;O模块</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093087561-d646c3ca-3b7d-48fe-88de-e325489b8ea9.png" alt="image.png"><br><a name="wW1Fq"></a></p><h3 id="外围设备的接口"><a href="#外围设备的接口" class="headerlink" title="外围设备的接口"></a>外围设备的接口</h3><p>转换器：外设的数据格式和计算机内部的数据格式可能不一致<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093193022-7d5eedaa-0baf-4319-823d-b3a910548468.png" alt="image.png"><br><a name="PlgC4"></a></p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093407597-d8eb7ef7-f7f6-4f2d-a13a-7a98d555997d.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093513588-823d2062-a477-498d-8e52-25f669c46e16.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093735022-348f6ecf-41aa-40a1-a1ea-e50dff7f9168.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093853802-b9ae09b6-fe76-447a-9f29-55c44f39015b.png" alt="image.png"><br><a name="m9WZ2"></a></p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671094127152-0da4f1d4-1aa5-41fa-b8c9-e9ed5d443490.png" alt="image.png"></p><ul><li>CPU对外设的命令是走数据线的，是具体的操作</li><li>状态和控制不是同一时间发生，只有确认了状态后，才能确认控制。状态是从右往左返回，控制是从左往右返回</li><li>数据寄存器实际上是输入寄存器和输出寄存器的合并<br><a name="e1inL"></a></li></ul><h4 id="外部接口"><a href="#外部接口" class="headerlink" title="外部接口"></a>外部接口</h4><p>事实上，并行接口，每一根线的延迟可能是不一样的，当线的长度非常长时，每一位传输时就会导致错位，数据传输出错。<br />所以，需要按照一定频率传输<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671094339336-88e79342-c69f-44a6-8172-9d16892fa542.png" alt="image.png"><br><a name="cbgly"></a></p><h4 id="串行总线"><a href="#串行总线" class="headerlink" title="串行总线"></a>串行总线</h4><ul><li>批量传输比同步传输多了“握手”，是为了实现<strong>异步</strong></li><li>同步传输：传送音视频时，需要同步。音视频对实时性的要求较高；允许一定的误码率</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671094569227-cd489685-adec-429e-bbf6-cd331cdf06b4.png" alt="image.png"><br><a name="Aqr1z"></a></p><h2 id="I-x2F-O操作技术"><a href="#I-x2F-O操作技术" class="headerlink" title="I&#x2F;O操作技术"></a>I&#x2F;O操作技术</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671095525199-68ebb65d-fad4-4811-b3a9-cda3794389b9.png" alt="image.png"><br><a name="uKPNs"></a></p><h3 id="编程式I-x2F-O"><a href="#编程式I-x2F-O" class="headerlink" title="编程式I&#x2F;O"></a>编程式I&#x2F;O</h3><p>缺点：比较低效？<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671095898490-1402e9b6-37b2-4785-88de-193d125eeca5.png" alt="image.png"><br><a name="wuNWA"></a></p><h4 id="I-x2F-O命令"><a href="#I-x2F-O命令" class="headerlink" title="I&#x2F;O命令"></a>I&#x2F;O命令</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096036418-f99e8058-f321-48f5-b18c-edc79c8530d2.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096107530-655b7a58-ef2f-4139-84c4-d69942c4922a.png" alt="image.png"></p><ul><li>CPU需要做什么 - 指令</li><li>I&#x2F;O需要做什么 - 命令<br><a name="PDNTN"></a></li></ul><h3 id="中断驱动式I-x2F-O"><a href="#中断驱动式I-x2F-O" class="headerlink" title="中断驱动式I&#x2F;O"></a>中断驱动式I&#x2F;O</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096337526-b350ddfe-4c1b-488b-8e94-f1adff4e3e77.png" alt="image.png"><br><a name="hSAwA"></a></p><h4 id="模块理解"><a href="#模块理解" class="headerlink" title="模块理解"></a>模块理解</h4><ul><li>I&#x2F;O模块等处理器，而不是处理器等I&#x2F;O了</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096515962-86e808e7-0488-4d59-9689-023fcbd0de84.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096596053-66c6bb00-ec53-4f0f-ac9f-2b29780358fc.png" alt="image.png"><br><a name="B9NcS"></a></p><h4 id="中断允许和中断禁止"><a href="#中断允许和中断禁止" class="headerlink" title="中断允许和中断禁止"></a>中断允许和中断禁止</h4><ol><li>中断处理之前，要保存现场</li><li>保存现场时，不能被中断。所以中断响应后，要进入中断禁止，保护现场</li><li>恢复现场时，也不能被中断</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096773626-57c52056-552d-4964-8ec5-594321a48c1a.png" alt="image.png"></p><p><a name="sYj5L"></a></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671097206942-6ab2d824-8025-4b8d-8ee9-bca3fea55158.png" alt="image.png"></p><ol><li>主程序的响应优先级和处理优先级的最低</li><li>先执行和处理完L1（L3 L4的处理优先级比L1低），回到主程序</li><li>先响应3，但是先处理完L4</li><li>恢复L3，发生了L2中断，但是L2的处理优先级低于L3，所以先处理L3</li></ol><p><strong>处理优先级决定哪些中断可以被响应，响应优先级决定哪些中断最先被响应</strong><br /><strong>行屏蔽是从处理优先级的角度出发的</strong><br><a name="QyvRS"></a></p><h4 id="设备识别"><a href="#设备识别" class="headerlink" title="设备识别"></a>设备识别</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671097342189-5f34c4b6-dd42-4d30-b78f-192778334e48.png" alt="image.png"><br><a name="OZUXo"></a></p><h3 id="直接存储器存取-DMA"><a href="#直接存储器存取-DMA" class="headerlink" title="直接存储器存取 DMA"></a>直接存储器存取 DMA</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671097553947-c02d296e-f133-4716-af15-982d51221831.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671097702884-b866c684-3e96-4b27-8656-aa7d0f7c87ec.png" alt="image.png"></p><ul><li>DMA和CPU访问同一块内存时，可能会导致冲突<br><a name="kAlv8"></a></li></ul><h4 id="DMA内存访问：CPU停止法"><a href="#DMA内存访问：CPU停止法" class="headerlink" title="DMA内存访问：CPU停止法"></a>DMA内存访问：CPU停止法</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671097979359-580da163-ee98-444d-b288-e9062336671c.png" alt="image.png"><br><a name="x6TRy"></a></p><h4 id="DMA内存访问：周期窃取"><a href="#DMA内存访问：周期窃取" class="headerlink" title="DMA内存访问：周期窃取"></a>DMA内存访问：周期窃取</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671098030143-2c2dde0e-8e15-4b2b-9d16-02ff8b52ed59.png" alt="image.png"><br />断断续续：存储周期处于空闲状态。一次IO请求可能会有多次DMA访存<br><a name="TeNwY"></a></p><h4 id="DMA内存访问：交替分时访问"><a href="#DMA内存访问：交替分时访问" class="headerlink" title="DMA内存访问：交替分时访问"></a>DMA内存访问：交替分时访问</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671098195384-c84307a0-a2a4-4358-a9d0-1b52dc70bea9.png" alt="image.png"><br><a name="rxceT"></a></p><h4 id="DMA配置机制：单总线分离DMA"><a href="#DMA配置机制：单总线分离DMA" class="headerlink" title="DMA配置机制：单总线分离DMA"></a>DMA配置机制：单总线分离DMA</h4><p><a name="fUNAy"></a></p><h4 id="单总线集合的DMA"><a href="#单总线集合的DMA" class="headerlink" title="单总线集合的DMA"></a>单总线集合的DMA</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671098378607-c95fdc3e-a6a6-4ddc-b923-c3126a62e70f.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671098413471-c4398552-0841-43d5-8597-01aaa3e85394.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671529051743-1938edaa-753d-4131-921a-f3171431780a.png" alt="image.png"><br />CPU还在操控，但是不等待<br><a name="ELnew"></a></p><h2 id="I-x2F-O模块的演变"><a href="#I-x2F-O模块的演变" class="headerlink" title="I&#x2F;O模块的演变"></a>I&#x2F;O模块的演变</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671529094550-d4297325-a0ec-4f2d-80d1-9d0b8f5f455f.png" alt="image.png"><br><br />I&#x2F;O处理器不仅有处理器，同时也有了局部存储器<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671529173900-2335dbc1-7bb5-484a-9cba-f616a1639309.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十六课 控制器</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AF%BE%20%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AF%BE%20%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a name="BRwKC"></a></p><h2 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919267410-b94ec08c-05ac-449c-919f-031d7d8674cf.png" alt="image.png"></p><ul><li>用户：特指<strong>编程人员</strong></li><li>可见：通过编程语言访问</li><li>状态寄存器：没有必要让编程人员访问，也不应该可见<ul><li>会导致不安全的情况</li><li>程序出现漏洞的风险也会增高</li><li>指令集的复杂度也会增加，效率降低<br><a name="gfdqI"></a></li></ul></li></ul><h3 id="用户可见寄存器"><a href="#用户可见寄存器" class="headerlink" title="用户可见寄存器"></a>用户可见寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919504581-833c4d81-e3f5-4a76-ae7d-0167b57216f6.png" alt="image.png"><br />条件码寄存器不是必须的。缺点：硬件复杂性增加<br><a name="iHNFa"></a></p><h4 id="设计出发点"><a href="#设计出发点" class="headerlink" title="设计出发点"></a>设计出发点</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919636491-3d32eb25-46dc-40f3-8577-7f9cb58cd6a8.png" alt="image.png"><br><a name="G79C6"></a></p><h4 id="保存和恢复"><a href="#保存和恢复" class="headerlink" title="保存和恢复"></a>保存和恢复</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919811007-34076bad-ede8-40d3-ac75-c8b6238983c1.png" alt="image.png"><br><a name="A2wGH"></a></p><h3 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919880475-246bf2a4-189f-44f4-8f70-63e43e5f22fd.png" alt="image.png"><br><br /><code>PC</code>是可见的<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919980960-f01b11a6-0a3a-4a0e-821e-fb049ecc856c.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920013758-9acefedd-9918-49fe-a397-cf2afa4620ab.png" alt="image.png"><br><a name="yDFme"></a></p><h4 id="设计出发点-1"><a href="#设计出发点-1" class="headerlink" title="设计出发点"></a>设计出发点</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920061137-5ee03a91-a0d4-4ad2-a8c3-6b498f92b717.png" alt="image.png"><br><a name="JFQzs"></a></p><h2 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h2><p><a name="jbGbq"></a></p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920320585-fce0f067-ad8e-4215-883c-0c429b8ddc6b.png" alt="image.png"><br><a name="KW0ws"></a></p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920401702-9d3ce9cb-112c-43a2-b978-231abda3f33c.png" alt="image.png"><br><a name="lgfCS"></a></p><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920577701-e5ef5114-9804-4636-a5d8-bd4401951de3.png" alt="image.png"><br><a name="nuD1B"></a></p><h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920615142-39d5a8ec-56dc-453c-81c5-902d046e14e1.png" alt="image.png"><br><br />为什么是<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/64636e8771ef215128139253c19e840a.svg"><br><a name="nVEMI"></a></p><h2 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920926888-8a8daa14-86b0-4e14-a571-30406aa00211.png" alt="image.png"><br><a name="gDz4A"></a></p><h3 id="分组原则"><a href="#分组原则" class="headerlink" title="分组原则"></a>分组原则</h3><p>通过放在前后的时间周期内，让时间的流动顺序恰当<br />对同一个寄存器进行读写，不能放在同一个时间周期内<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670921380192-1f213a4c-3bd9-4a7e-a35c-c0ef2679ec12.png" alt="image.png"><br><a name="HYPOh"></a></p><h3 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670921071143-60ece1e9-30f3-4388-8cc0-ff65658979a1.png" alt="image.png"><br />t1：数据通过MAR传给地址总线<br />t2：对应两个微操作</p><ul><li>取出指令放到数据总线上</li><li>PC+”1” <strong>要当心同步、异步 — 发送在同一个时间单位内</strong></li></ul><p>每一个<code>t</code>表示一个时间单位，表示微操作发送在哪一个时间单位内。<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676278523396-e3840dbe-3f21-4676-abab-1a1476fb7136.png" alt="image.png"><br />调整了<code>pc + 1</code>的位置<br><a name="mhhov"></a></p><h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p>将间接地址转换成有效地址<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676278788647-3d63125c-b97e-4e52-af77-2946c0253697.png" alt="image.png"> </p><ol><li>IR中存了取到的指令，将指令中的地址部分放到MAR中</li><li>将地址对应的内容从存储器中放到MBR中</li><li>替换IR的地址部分<br><a name="TZTmR"></a></li></ol><h3 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670921628782-56c3af73-0ac2-4068-9815-af825b50c551.png" alt="image.png"></p><ol><li>送地址后才能取到内容，所以t1和t2不能合并</li><li><code>t2</code>是写<code>MBR</code>，<code>t3</code>是读<code>MBR</code>，所以不能合并</li></ol><p>转移并保存：保存PC地址，并跳转到一个新的地址</p><ol><li>将IR中的地址送到MAR中，告诉MAR，PC要存到哪里，该地址是PC要保存到的地址。把PC的内容送到MBR中。这俩个步骤互相独立，可以存放在同一个时间周期内。</li><li>把MBR的内容写到主存中，把新的地址存到PC中。只有PC保存了，才能更新PC；只有写入了MBR，才能继续读MBR</li><li>PC+1<br><a name="fGC5U"></a></li></ol><h3 id="中断周期？"><a href="#中断周期？" class="headerlink" title="中断周期？"></a>中断周期？</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676280174445-3d2b645b-a50c-452e-8184-9f1f59fe1696.png" alt="image.png"><br />只需要两个时间单位<br><a name="KfHQA"></a></p><h2 id="指令周期代码-ICC"><a href="#指令周期代码-ICC" class="headerlink" title="指令周期代码 ICC"></a>指令周期代码 ICC</h2><p><strong>取指、间址、中断周期各有一个微操作序列</strong>，执行周期则对于<strong>每个操作码有一个微操作序列</strong><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670923075438-d6d8e465-8686-4a40-b27c-8526d10f6896.png" alt="image.png"><br><a name="uOKF1"></a></p><h3 id="取指周期-1"><a href="#取指周期-1" class="headerlink" title="取指周期"></a>取指周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676280691528-bbc07979-212b-4fec-99ce-282976e7cc33.png" alt="image.png"><br><a name="tMwuv"></a></p><h3 id="间址周期-1"><a href="#间址周期-1" class="headerlink" title="间址周期"></a>间址周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676280775169-d67730ae-883a-40a8-bdd4-09b8a62d4d85.png" alt="image.png"><br><a name="vGdBp"></a></p><h3 id="执行周期-1"><a href="#执行周期-1" class="headerlink" title="执行周期"></a>执行周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676280817628-3d293da8-8921-4ba2-9e5e-e21a587769f4.png" alt="image.png"><br><a name="JXVaS"></a></p><h3 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676280899073-1d33d56f-2433-47f7-9f6c-d696c17dd9f1.png" alt="image.png"><br><a name="mlWDz"></a></p><h2 id="CPU内部总线"><a href="#CPU内部总线" class="headerlink" title="CPU内部总线"></a>CPU内部总线</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676281035906-53dbaff2-32e7-4ae7-adc8-7e12974ea3de.png" alt="image.png"><br><a name="LrJFt"></a></p><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p><a name="j278F"></a></p><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676281278060-8d173a61-1a73-453e-821c-54461a8baa9c.png" alt="image.png"><br><a name="mMIIK"></a></p><h3 id="控制器的输入"><a href="#控制器的输入" class="headerlink" title="控制器的输入"></a>控制器的输入</h3><p>操作码影响执行周期<br />寻址方式影响间址周期<br /><strong>控制器也会收到控制信号：中断请求</strong><br /> <img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924080197-92f1345a-44b0-4fd6-b352-a2ad677591fb.png" alt="image.png"><br><a name="VGiFM"></a></p><h3 id="控制器的输出"><a href="#控制器的输出" class="headerlink" title="控制器的输出"></a>控制器的输出</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924058358-da3ce790-1839-46be-937f-a330ae23528b.png" alt="image.png"><br><a name="OHh5Y"></a></p><h3 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924483599-b92aeb4a-7e93-4064-91ab-8445e1ea85be.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676281867546-98feb1b3-1158-412b-bb4a-91f8eb712476.png" alt="image.png">（图有点小问题）<br><a name="mjmzm"></a></p><h3 id="控制器的最小特性"><a href="#控制器的最小特性" class="headerlink" title="控制器的最小特性"></a>控制器的最小特性</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924690734-76f534ec-3118-4d4e-8e78-eabeba97f725.png" alt="image.png"><br />实现上尽可能地简洁<br><a name="K8fzg"></a></p><h2 id="控制器实现"><a href="#控制器实现" class="headerlink" title="控制器实现"></a>控制器实现</h2><p><a name="e3A87"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924736797-818d155f-84a8-425a-8e59-d6f108c9de65.png" alt="image.png"></h4><p><a name="rRAKd"></a></p><h3 id="硬布线实现"><a href="#硬布线实现" class="headerlink" title="硬布线实现"></a>硬布线实现</h3><p><a name="L0ANx"></a></p><h4 id="控制器输入"><a href="#控制器输入" class="headerlink" title="控制器输入"></a>控制器输入</h4><p>时钟、标志、控制总线的输入、指令寄存器</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924821550-85ba9bbb-1562-4713-80e2-963a120852ae.png" alt="image.png"><br><br />操作码通过译码器转化为微操作序列<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924860619-1d10e097-e753-49c0-b8bb-b285856ec712.png" alt="image.png"><br><a name="IwrJu"></a></p><h4 id="控制器逻辑"><a href="#控制器逻辑" class="headerlink" title="控制器逻辑"></a>控制器逻辑</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670925024608-139dd57a-92b9-4aae-8f1c-46031c93a366.png" alt="image.png"><br />缺点：太过复杂<br><a name="NhjWi"></a></p><h3 id="微程序实现？"><a href="#微程序实现？" class="headerlink" title="微程序实现？"></a>微程序实现？</h3><p>和硬布线实现有什么不同<br><a name="tf8By"></a></p><h4 id="基本概念和思路"><a href="#基本概念和思路" class="headerlink" title="基本概念和思路"></a>基本概念和思路</h4><ul><li>微程序(固件)介于硬件与软件之间</li><li>设计固件比设计硬件容易，但写固件程序比软件程序困难·微指令序列</li><li>微指令∶<strong>每行</strong>描述一个时间内出现的<strong>一组微操作</strong>。</li></ul><p>基本思路</p><ul><li>对于每个微操作，控制器的任务是产生<strong>一组控制信号</strong>，即控制器发出的<strong>每根控制线或开或关</strong>（每根控制线由一个二进制数字表示）·构造一个控制字，每位代表一根控制线，这样每个微操作能用控制字中的不同的0和1的样式来表示</li><li>将这些控制字串在一起，可以表示控制器需要完成的微操作序列</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670925452420-15ec817d-0ecb-4f92-8b9e-3747a0d218b5.png" alt="image.png"><br><a name="yIwzn"></a></p><h3 id="微程序执行？"><a href="#微程序执行？" class="headerlink" title="微程序执行？"></a>微程序执行？</h3><p>取指、间接、中断的微操作序列是一样的，都可以用相同的微指令** ？ 为什么是一样的**<br />相同的操作码可以用相同的微指令序列<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676300014626-a8f2f12a-c1d1-44a6-bded-c06f4a19dcde.png" alt="image.png"><br><a name="QQce4"></a></p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671091969058-f30ca772-1c3f-45ce-9b46-13fdd746c7ef.png" alt="image.png"><br><a name="l6F1h"></a></p><h4 id="定序"><a href="#定序" class="headerlink" title="定序"></a>定序</h4><p>下一个指令的地址在哪？<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092076221-584ed9b1-f56e-48c2-964c-08168387ac63.png" alt="image.png"><br />双地址：指令太长，成本上升<br />地址选择有不同的方式。<br><a name="G6wv4"></a></p><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676300598587-c67eb512-c1e2-4278-892e-7f0b9e22843b.png" alt="image.png"><br><a name="PSznR"></a></p><h4 id="工作流程？？"><a href="#工作流程？？" class="headerlink" title="工作流程？？"></a>工作流程？？</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092388440-552fbd64-9c06-49d9-946b-e5ec3eb1ac1a.png" alt="image.png"><br><br />下面这张图什么意思？<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092511829-b0e54373-734f-494d-ad8d-d7a9a8445a6d.png" alt="image.png"></p><ul><li>操作码在指令寄存器中，需要进行译码器译码<br><a name="GnlTH"></a></li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092548608-5f84db8f-8a05-4361-9fc0-d82d24687646.png" alt="image.png"><br><a name="PsYUs"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092625274-a3d92e0f-6821-4343-bcf7-cd8c895f7189.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十课 数据校验码</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E8%AF%BE%20%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E8%AF%BE%20%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><a name="PzQE5"></a></p><h3 id="差错"><a href="#差错" class="headerlink" title="差错"></a>差错</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668072243204-c84422fd-18cd-4ca5-97c2-7366d05627fa.png" alt="image.png"><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668072867915-b6daef4a-6422-4b57-999c-1f107467e5b4.png" alt="image.png"><br><a name="a31Gg"></a></p><h3 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668073261817-d8c44924-6189-48d8-b516-2ce0c440c03f.png" alt="image.png"><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668073252925-c5f59f43-da29-4d58-83bd-2d6c4c4dcfe0.png" alt="image.png"></p><p><a name="GeMKt"></a></p><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668073398885-759187f4-99e9-443d-aa0b-7e955548d242.png" alt="image.png"><br />判断奇数&#x2F;偶数：异或<br />奇偶校验：相差一个异或<code>1</code><br />多一个异或：相当于多一个非门，多了一级门延迟</p><ul><li>奇校验的作用：防止全<code>0</code>数据的传输（同步传输中），从而区分传输有无结束</li><li>偶校验：门延迟更低</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668073730554-ce6cab88-339c-4fca-8b08-af11c8e1114c.png" alt="image.png"><br />长度短：发生偶数位的差错概率更低<br><a name="wDvPo"></a></p><h2 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503322446-e867af91-1154-4612-a236-7b82d99bf2d0.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503335114-07b6101b-e172-475a-8851-b1dbbb92e96e.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503343047-fe6c229e-ddd4-4d5e-ba7a-33176ab4640d.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668501979453-d9c73b31-adbb-4d05-b53b-f24cadf82cf0.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503434104-33246edd-f80b-4c48-82d4-4fa881c09981.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503457828-645948bf-3dd6-428a-a76e-604d13dfd0f4.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503471385-27e56ca9-9909-4e67-9b7e-0c01897f0825.png" alt="image.png"><br><a name="eVelZ"></a></p><h3 id="码距和纠错理论"><a href="#码距和纠错理论" class="headerlink" title="码距和纠错理论"></a>码距和纠错理论</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668501191956-9a846bfd-f5f2-4104-ae87-3801e306d165.png" alt="image.png"><br><br /><br>奇偶校验的码距是2：如果D中有一位发生了变化则C中也有一位发生变化，如果D中有两位发生了变化，则C中没有变化<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668502235956-3f49ff77-6d27-4bb3-9d95-e180e811e10b.png" alt="image.png"><br />海明码2.0：同时可以识别出2位出错的情况，是双检错，但依然是<strong>单纠错</strong><br />D1 D2出错和C5 D3出错的情况相同，所以只能具备单纠错的能力<br><a name="oOj3b"></a></p><h3 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503492488-add43037-7eeb-4440-acf0-667766475aef.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503669170-2bbd8525-5af0-4c61-a7b7-a906eb1b130c.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503682149-b77d16a1-7e9c-487e-a188-835d61841472.png" alt="image.png"></p><ul><li>无借位减，等价于异或运算</li><li>多项式1001对应的是<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/3619ace3eb24da39bda024bcf29b14ac.svg" alt="image.png"></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668504591848-89723a4a-c613-452f-9732-b8d48931813a.png" alt="image.png"></p><ul><li>海明码1.0只适合1位出错的情况</li><li>奇校验码能增加1，区分出传送的00000000数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第四课 整数运算</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%9B%9B%E8%AF%BE%20%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%9B%9B%E8%AF%BE%20%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p><a name="nhw6e"></a></p><h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><p><a name="Gpexo"></a></p><h3 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h3><p>前提假设：<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664467718264-0c488d43-4145-4ebd-8945-b62cc8662389.png" alt="image.png"><br><a name="pgspn"></a></p><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>公式：<br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/6b6d76946fe54be4b3057c06487abf03.svg" alt="image.png"><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664467409312-d330df3d-06a5-410f-a57a-9d76e0ccc733.png" alt="image.png"><br><a name="MQufc"></a></p><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>公式</p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/e43dff128f12eb9e1f959290b6c873db.svg" alt="image.png"><br><br />其中，并非 <br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/fa0e3b48e6cf2289e98b7449bf402186.svg"> 的返回值为真，而是因为和前面的X与Y相配合，刚好形成了对应的结果<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664467661390-9e89045b-7a4c-4d0f-acf5-806f90e44c62.png" alt="image.png"><br />那么这种改善的好处是，减少了与门的使用</p><p><a name="KBcWd"></a></p><h3 id="串行进位（行波进位）加法器"><a href="#串行进位（行波进位）加法器" class="headerlink" title="串行进位（行波进位）加法器"></a>串行进位（行波进位）加法器</h3><ul><li>1位加法：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/f4941249f1d11a1885789b6eae8696d4.svg" alt="image.png"></li><li>第i位加法：</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/43267647225ac22f9d5b38f5d111a94c.svg" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664468091575-81876688-7542-418a-8b6d-4430faaec967.png" alt="image.png"></p><p><br />Cn 是2n的延迟，原因是每个延迟为2：与操作+或操作<br />Fn是2n+1的延迟，原因是，</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/ffa01558fab0e00cfdd749ec2d60f2f4.svg"><br><br />其中，</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/81083cba0c4fb4c4d3ec9ac308736a49.svg"> 额外+3 是因为F产生的延迟。需要注意的是</p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/7e7defc5e24c1284250e6c1ee1153487.svg">因此，不会产生额外的延迟<br><a name="zSccX"></a></p><h3 id="全先行进位加法器"><a href="#全先行进位加法器" class="headerlink" title="全先行进位加法器"></a>全先行进位加法器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664470369829-6e248a4c-87cc-49c6-ad9f-6272f5170136.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664470145406-a7817201-d9aa-4e33-b189-295b391eecce.png" alt="image.png" title="n个或门改为1个或门"></p><ul><li>1ty：代表的是生成信号和传播信号的生成</li><li>2ty：代表的是第i个进位信号的生成：1延迟的与运算+1延迟的或运算【与运算和或运算可以接受任意个数的参数】</li><li>3ty：代表的是第i个本位的生成：3延迟的或运算【和之前的1+2并行消耗，先计算X和Y的异或运算，经过3延迟后，C也得到了】+3延迟的或运算<br><a name="DqoPF"></a></li></ul><h3 id="部分先行进位加法器"><a href="#部分先行进位加法器" class="headerlink" title="部分先行进位加法器"></a>部分先行进位加法器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664470171477-4aece9f3-73d1-401d-b7b0-13ef941e40d4.png" alt="image.png"></p><ul><li>3ty&#x3D;2ty+1ty</li></ul><p>在最开始时，</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/f067520d99b0a22dee9abd4241528bfb.svg" alt="image.png">此时的计算需要最初的1ty，之后，再根据计算公式可知需要2ty的延迟来生成<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/3251ead7580cfd081ce354aaaf39201e.svg"> 因此总延迟为3</p><ul><li>2ty 2ty 分别代表<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/41afffd775e4ecdc5fca82f842aa1c9b.svg" alt="image.png">和<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/738bcc5adfc17944d2fae6b7fa88ea40.svg">的生成</li><li>5ty &#x3D; 3ty + 2ty 其中3ty代表的则是F的生成，2ty代表最后一次进位的生成<br><a name="ZiA71"></a></li></ul><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><p><a name="yDkpT"></a></p><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664470207731-27c3d92c-f614-4a9b-8d4a-2b0b24080dbf.png" alt="image.png"></p><p><br />标注：此处的<br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1f093cca47b2c22bde288e8322d68fa5.svg">单单第n位<br><a name="f43T5"></a></p><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664871896605-00f88e72-4afb-4038-8c5c-69c34a7e6c17.png" alt="image.png"><br><br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664871790303-9d8a4091-a940-4767-8135-00a6ca831d57.png" alt="image.png"><br><a name="Twjzd"></a></p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>二进制乘法不需要乘法表进行存储。十分方便</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664872256196-9c3f454e-c8f4-4d30-9820-a544b539687f.png" alt="image.png"><br><br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664872573267-7c707b44-df0b-4dc5-a4ad-44ccb9d40808.png" alt="image.png"></p><p><a name="cziiN"></a></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664873083261-c5dfb876-e557-42c5-8267-8880d9263bf5.png" alt="image.png"></p><p><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664873700060-4153e091-b6ad-4e34-9db5-9e30599dd25d.png" alt="image.png"></p><p><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664873711104-44feb530-e235-43cf-8824-7c6e286fc498.png" alt="image.png"></p><p><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677227495378-49285cfa-2079-466a-aea7-983cbcde62d1.png" alt="image.png"></p><p><a name="OAWYS"></a></p><h4 id="出错"><a href="#出错" class="headerlink" title="出错"></a>出错</h4><ol><li>原码一位乘法</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664874010621-a3a12e09-883b-487e-84c0-6cc18b625b17.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664876294590-608360fa-eb5e-40ad-bea8-91cd0e461fc4.png" alt="image.png"></p><p><a name="IatBN"></a></p><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p><a name="fn65V"></a></p><h4 id="原码：恢复余数法"><a href="#原码：恢复余数法" class="headerlink" title="原码：恢复余数法"></a>原码：恢复余数法</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579103517-21bc973e-b11d-4d6e-9dc4-9ff3f7a18596.png" alt="image.png"><br />余数逻辑左移是为了实现错位相减。因为手算时实际上是除数右移，而我们规定除数不移动时，则是余数左移 <br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665046084999-fcd74f9f-0fe8-47ad-86b9-488c58d7454f.png" alt="image.png"></p><p>优化：并行+硬件的节省<br />并行：<br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665046246364-e0791a34-797b-4388-89b4-9cb48fc432f3.png" alt="image.png"><br><a name="siEx8"></a></p><h4 id="原码：不恢复余数法"><a href="#原码：不恢复余数法" class="headerlink" title="原码：不恢复余数法"></a>原码：不恢复余数法</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579191990-bdda3b92-bd88-4f85-92fb-d515840a9493.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579365006-a43c0888-f001-4d5a-8fe4-87d7e335a295.png" alt="image.png"><br />若最后一步余数为负数，仍然需要恢复为正确余数<br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579436894-84f3a9d4-7811-463d-8a7a-3b44b91052d5.png" alt="image.png"></p><p><a name="Qj7E8"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>余数和被除数的符号相同</strong><br><a name="KNCuv"></a></p><h4 id="补码：不恢复余数法"><a href="#补码：不恢复余数法" class="headerlink" title="补码：不恢复余数法"></a>补码：不恢复余数法</h4><p><strong>余数和除数相减：</strong></p><ul><li>如果余数和除数的符号相同：减法</li><li>如果余数和除数的符号不同：加法</li></ul><ol><li>够减：余数和新余数的符号不能变</li><li>不够减：余数和新余数的符号改变</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665048069773-3951cb9f-66ca-47a0-950c-61e963f6fc6b.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579578780-d5692823-6614-40ad-a7b2-90686d44692f.png" alt="image.png"><br><a name="ML3zD"></a></p><h4 id="除法硬件改善"><a href="#除法硬件改善" class="headerlink" title="除法硬件改善"></a>除法硬件改善</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665047579085-5f0b98ff-e23e-4909-9617-03b56fa5a3bb.png" alt="image.png"><br><br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665047595553-58e0bc80-0076-41ca-b06a-e287844ffb3f.png" alt="image.png"><br /><strong>被除数移动了，除数就不需要移动了</strong><br><a name="xB2lR"></a></p><h4 id="除法运算总结"><a href="#除法运算总结" class="headerlink" title="除法运算总结"></a>除法运算总结</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579646869-a44972c3-bead-470a-9bd7-42c6d1d185aa.png" alt="image.png"><br><a name="aHsWD"></a></p><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p><a name="Dob89"></a></p><h4 id="乘法溢出"><a href="#乘法溢出" class="headerlink" title="乘法溢出"></a>乘法溢出</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665460775408-5807ea34-f57e-4adf-a3b2-1ceb739a75cb.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
