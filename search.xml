<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一课 发展历程</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%80%E8%AF%BE%20%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%80%E8%AF%BE%20%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>语言的多义性决定了语言的丰富。但是对于计算机而言，描述必须精准</p><ul><li>Syntax 语法</li><li>Semantics 语义</li><li>Pragmatics 语用</li></ul><p>BNF语法图<br />句型： Thank sb for sth. 其中sb和sth都可以由其他东西替代（可替代部分+不可替代部分）<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662444962624-1e45f756-8b6f-47cc-a90d-05b286820024.png" alt="image.png"><br>在BNF中，不可替代部分成为alphabet，又称作字。即：ASCII 定义了所有可以出现在程序中的字母表<br />如何判断标识符符合规定：</p><ol><li>deduct：“_a9”是一个identifier吗？</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662444573424-b85dd72b-ebf3-4b38-9328-eee446d3506c.png" alt="image.png"><br>根据定义，利用递归，从上往下推导</p><ol start="2"><li>reduce：按照递归树从下往上推导</li></ol><p><strong>语言是建立在一定的字母表上，按照一定的规则，所构成的符号串的集合。（集合是无穷无尽的，因为包含了递归）</strong><br /><strong>编译器：完成识别的过程，判断语言是不是符合对应的规则。把程序员所写的语言程序等价翻译为机器语言</strong></p><h3 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h3><p>语言的约束越强，对应的集合越小</p><ul><li>RG：Regular Grammer 正则语法  — FA：finite automata 有限状态自动机</li><li>CFG： Context Free Grammer  —PDA：push down automata</li><li>CSG：context sensitive Grammer —LBA： linear bounded automata 线性界限自动机</li><li>PSG —TM：</li></ul><p>程序语言：词法符合RG，语法大多数符合CFG  </p><h2 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h2><ol><li>programming 是一种 science</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662446400921-75e7ccb6-38c2-4e6c-a31a-46a47042ada6.png" alt="image.png"><br>用数学对前后置条件进行限制<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662446421868-55139af5-356e-4a8f-bfe8-d9a0fe23a1d9.png" alt="image.png"><br>经验：调试bug时要考虑数据流，而不是只是考虑输入流。看数值的变化是否满足对应的前后置的限制条件</p><ol start="2"><li>programming 是一种 art “The Art of Computer Programming”</li></ol><p>类比：以法国人的思维说法语</p><h2 id="Progarmming-Paradigm"><a href="#Progarmming-Paradigm" class="headerlink" title="Progarmming Paradigm"></a>Progarmming Paradigm</h2><h3 id="命令式程序设计-imperative-programming"><a href="#命令式程序设计-imperative-programming" class="headerlink" title="命令式程序设计 imperative programming"></a>命令式程序设计 imperative programming</h3><p>清楚的知道内存中数据的表示，每一条指令都是清晰的</p><ul><li>Procedural</li><li>Object-Oriented</li></ul><h3 id="declarative-programming"><a href="#declarative-programming" class="headerlink" title="declarative programming"></a>declarative programming</h3><ul><li>Functional: side effect函数副作用，函数发挥作用时受上下文环境影响。在此处的function不能有side effect。f() g()可以并行地发挥作用，前后顺序不影响结果</li></ul><p>例如：在排版系统中，加粗和调整字体都是functional programming</p><ul><li>Logical programming paradigm：根据已知的规则和事实进行判断 prolog</li></ul><h2 id="Development-History"><a href="#Development-History" class="headerlink" title="Development History"></a>Development History</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662450058611-31be0828-3f84-4b7b-ba44-bb6e55b54d28.png" alt="image.png"><br>simula 67 开销太大</p><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><ol><li>第一个程序设计语言 Fortran：解决了从汇编语言到高级程序设计语言的飞跃，主要问题是移植性差，从冯诺依曼结构产生出来，和机器硬件绑定太强</li><li>Algol 60：把程序设计语言作为一个学科，提出了结构化程序设计语言的发展&#x3D;&gt;Algol  68</li><li>CPL(combined programming language ) 和机器贴合紧密，过于注重细节&#x3D;&gt;B（bracket 闭合的语句块）CPL。把IO输入输出以库的形式提出，提出了闭合的相关概念&#x3D;&gt;B（进一步精简）&#x3D;&gt;C（写unix操作系统）</li><li>Simula 67</li></ol><p>C++：</p><ul><li>结构化程序设计基因：Algol 60</li><li>系统程序设计基因：CPL</li><li>object-oriented programming OO思想：Simula 67</li></ul><h3 id="OO的诞生-Simula-67"><a href="#OO的诞生-Simula-67" class="headerlink" title="OO的诞生-Simula 67"></a>OO的诞生-Simula 67</h3><ul><li>Simulation System:需要求的数值，但是没有现实的模型。需要映射出一个模型，通过实验的手段，在人为营造的环境中让系统不断演变</li><li>背景： Nygaard 做核反应堆铀棒直径的计算，需要做一个simulation system</li></ul><p>用新的表述方法（simulation language）去描述仿真系统中的活动，而不是人为的去用代码描述</p><ul><li>选择：Fortran or ALGOL 60</li></ul><p>后者：有块结构+优良的程序安全，问题更少+欧洲情结（Fortran在美洲）</p><ul><li>入手：打破LIFO（先进后出）<strong>仿真系统中有一些个体，并不是先创建就一定先消亡</strong> </li><li>措施：<ol><li>有一个可以描述行为的程序</li><li>有一个pointer能够控制实体</li><li>有些操作只能针对某些数据</li><li>需要管理者管理数据，控制其生命周期等</li></ol></li></ul><p>实现：写了一个runtime system，创建了一个关键字“SIMULA”（利用compiler先翻译为algol 60），兼容algol 60 &#x3D;&gt;SimulaI 1（不是设计语言）</p><h3 id="Simula-67-为什么没有进一步发展？"><a href="#Simula-67-为什么没有进一步发展？" class="headerlink" title="Simula 67 为什么没有进一步发展？"></a>Simula 67 为什么没有进一步发展？</h3><ol><li>Born：在欧洲出身，缺少大量应用，科技中心在美洲</li><li>Expensive</li><li>缺乏一个好的IDE，集成开发效率没有提示</li><li>没有更多的publication</li><li>程序占用体积非常大，对并发、数据类型、runtime的表述也不太好</li></ol><h3 id="C-的诞生"><a href="#C-的诞生" class="headerlink" title="C++的诞生"></a>C++的诞生</h3><p>Bjarne Stroustrup</p><h4 id="史前1979（剑桥实验室）"><a href="#史前1979（剑桥实验室）" class="headerlink" title="史前1979（剑桥实验室）"></a>史前1979（剑桥实验室）</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663072053058-c6dc0148-4586-4881-9689-7b8ef03548ed.png" alt="image.png"><br>PASCAL？？为什么不选择–类型系统的支持太弱<br />但是，遇到了<strong>灾难：缺点-性能差，无法从模拟器中获取数值，模拟器没有提供他所需要的数值</strong><br /><strong>问题：Linker 不适合大程序 原因：运行中 的类型检查和废料收集消费了80%</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663072325747-b891f2db-b861-4399-994c-a09f1c6749a6.png" alt="image.png"><br>第二阶段：BCPL 缺点：太复杂，Debug难<br />不使用C：对C语言不熟悉<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663072435974-0bfa7f50-0bed-4be1-941d-89fe7d211ef3.png" alt="image.png"><br>BCPL不是一个合适的工具，并且目前对C不熟悉<br />所以此时并没有发明C++的想法，有做一定的思考</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663072591666-877ea1f2-a96f-4666-a99c-5ed8a813728c.png" alt="image.png"><br>哲学观（对C++的指导有一定重要作用）：存在主义（与创始人-克尔凯郭尔同为丹麦人）&#x3D;&gt;尊重个体的差异性&#x3D;&gt;有用即可以包含进来&#x3D;&gt;成为各种工程师都可以使用的工具</p><ol><li>实验更重要</li><li>不是科学家的玩物（《地下室手记》）</li><li>不是证明一种观点，而是解决一个问题，可以风格多样，而不是“真理之路 ”</li></ol><h4 id="1979（Bell-Lab）"><a href="#1979（Bell-Lab）" class="headerlink" title="1979（Bell Lab）"></a>1979（Bell Lab）</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663073359288-2562db63-2fef-40b8-92c4-586dfca4776d.png" alt="image.png"><br>Bell Lab中有Unix的创始人（Ken Thompson）&#x3D;&gt;可以熟练使用C了</p><ul><li>并行用库实现</li><li>舍弃常用的科学数据的支持</li><li>遇到了Link问题，所以需要兼容C，利用C的link，放弃housekeeping</li></ul><p><strong>引入一切我觉得有用的东西，并且不轻易放弃 程序语言的设计者不替程序员做出决定</strong></p><h4 id="1982-发展"><a href="#1982-发展" class="headerlink" title="1982 发展"></a>1982 发展</h4><p>McIroy：做Unix的三剑客之一（RobPike、Thompson）<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663073562162-e06ec8a7-2bf5-4921-8b1a-20153a253b16.png" alt="image.png"></p><h4 id="1983-诞生"><a href="#1983-诞生" class="headerlink" title="1983 诞生"></a>1983 诞生</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663074332166-fa77cf41-8eb9-44a3-88ba-c3dc25dc1f8b.png" alt="image.png"><br>cPP:pre Process 预处理：做editor工作。define&lt;&#x3D;&gt;find &amp; replace 编辑不是编译<br />Cpre:C with class 翻译成C。如果出错则即使返回。由C compiler判定有无语法上的错误<br />Cfront：C++的语法检查器，此时C compiler不做语法上的检查<br />C++是C的扩充，编译时不是直接翻译成机器代码的，而是C，需要依靠C的link</p><ul><li>ANSI：科学家+工程师+工具的开发者。业界专业人士认可</li><li>ISO：国际组织</li></ul><p>正交性：功能上的冲突</p><h3 id="C和C-的关系"><a href="#C和C-的关系" class="headerlink" title="C和C++的关系"></a>C和C++的关系</h3><ol><li>C++是C的超集</li><li>C++支持C所支持的全部编程技巧</li><li>任何C程序都能被C++用基本相同的方法编写，并具备同等开销（时间、空间）</li></ol><p><strong>与可能出现的错误相比，更重要的是能做什么好的事情</strong><br /><strong>Programmer needs to be trusted</strong></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>C语言：</p><ul><li>开发效率低</li><li>易用性和安全性低（没有越界检查），是为了提高语言本身的表达能力</li><li>运行效率高&#x3D;&gt;硬件效率高仍然需要软件的运行效率高 例如：3D渲染、自动驾驶、功耗控制</li><li>具有不可替代性 不能保证新写的程序效果一定一样，程序正确性无法证明。早期用C语言写的，在关键领域中不能随意改变</li><li>灵活、高效、可用、可移植</li><li>某些语言结构不安全，没有舍弃C中的危险之处</li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663077652393-995d2800-b0b8-4c1d-88a0-1caa10540bdb.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663077620317-126e8c4f-6d5a-4159-982f-f59f7ab61308.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663077637077-bfe54c46-c02f-4d38-8a15-719e315d0d9a.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二课 SP</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%BA%8C%E8%AF%BE%20SP/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%BA%8C%E8%AF%BE%20SP/</url>
      
        <content type="html"><![CDATA[<p>思想：自顶向下，逐步求精<br />控制流：顺序、选择、重复，不允许随意出现goto语句。消除goto语句后，程序的表达能力不变<br />组成 &#x3D; Data structure + algorithm</p><ol><li>Built in data type：char int float double</li><li>计算控制</li><li>组织 function </li><li>构造数据类型：array struct union pointer</li></ol><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p><strong>Use const whenever possible</strong></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>int x &#x3D; 8;<br />组成：</p><ol><li>性质：变量、常量</li><li>名</li><li>值</li><li>地址—需要touch硬件。simula 67 把所有的数据都放入heap中，造成了效率缓慢</li><li>ADT：抽象数据类型–在计算机中，任何一个数据都是有限的、可数的、离散的。数据类型决定了值集 16位（-32768~32767）</li></ol><p>Data type 定义了值集和**同类型计算的语义 **例如int+double，是通过数据类型的转换实现的<br />类型系统：</p><ol><li>强类型语言、弱类型语言：体现对数据类型的容忍度的强弱，是否宽松。弱类型更灵活，但负载更大、问题更多</li><li>动态语言、静态语言：在compiler+linker阶段可以确定，则是静态类型，要运行阶段确定则是动态类型（例如实现多态时，只有在实际运行时调用，才能确定具体的数据类型，但是需要满足一定的约束）。    <strong>C++：强类型、动&#x2F;静结合</strong> <strong>类型安全不能代替测试</strong></li><li>更加灵活的语言类型：duck</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663250150255-bfe343b5-29c6-47a8-b69c-f595dce6df46.png" alt="image.png"> <br />都有quack（）则可以调用，不一定需要父子类关系</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ol><li>要考虑优先级、结合性</li><li>类型转换约定：混合类型转换（int可以转换为double） **逐个、趋强  **</li><li>求值次序：取决于compiler（副作用：破坏可移植性，降低可读性，一定要消除）</li></ol><p>表达式越清晰越好，副作用的产生没有任何好处。表达式效率由compiler决定</p><ol start="4"><li>谨防overflow</li><li>auto：由编译器推理出数据的类型，表达更加灵活（新引入的机制）</li></ol><p>种类：</p><ul><li>赋值：x&#x3D;8 是表达式             x&#x3D;8; 是表达式语句 目的：<strong>使语言更灵活，使得操作符可重载</strong></li></ul><p>左值：可以出现在赋值表达式左部的表达式，具有存放数据的确定地址。<strong>不一定是变量，例如函数（返回reference）</strong><br />类型不同时，先计算右值表达式的值，再转换为左值类型，然后赋值</p><ul><li>逗号</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663255686452-64b56afe-42f8-4ed6-9f88-2f21fba42839.png" alt="image.png"></p><ul><li>算术</li><li>关系和逻辑</li><li>条件运算符表达式：<ul><li>唯一的三目运算符</li><li>只计算一个运算分量</li><li>不可以操作重载</li><li>可嵌套：就近原则</li></ul></li><li>字位运算符表达式（用bit表示状态位）</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663255982050-b33523c9-acf7-48ee-ab7f-badc0f8fc70e.png" alt="image.png"><br>SSA：static single assignment 处理中间码-异或操作 </p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h4 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h4><p>表达式+分号：方便进行操作符的重载，给语言带来很大的灵活性</p><h4 id="IO语句"><a href="#IO语句" class="headerlink" title="IO语句"></a>IO语句</h4><p>封装在库，剥离开来</p><ul><li>cin、cout    iostream iostream.h</li><li><blockquote><blockquote><p>、&lt;&lt;可重载</p></blockquote></blockquote></li></ul><h4 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h4><p>顺序、选择、重复</p><ul><li>for：循环三要素：循环变量初始化、终止条件、改变循环控制变量。<strong>for将该三要素放在一起，方便更清晰地看清循环</strong></li><li>switch+整型表达式；case:整型常量表达式（在编译之时就知道值）。只用一次比较就可以跳转到其他地方，比if语句减少了许多比较的消耗。<strong>brake</strong>记得使用。**尽量避免用字面常量，该用符号常量或者enum枚举类型 **</li></ul><p>符号常量 const int RED &#x3D; 0；<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663257563741-1cfe6b2c-4277-4acc-aad9-5bff897315c6.png" alt="image.png"><br>代码结构非常一致：利用枚举和表的形式。同时表可以存储在外部文件（资源文件）中，不需要放置在源代码中<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663257801245-73a603d8-fa30-427c-8730-f94739c811fc.png" alt="image.png"></p><h2 id="C-的用途"><a href="#C-的用途" class="headerlink" title="C++的用途"></a>C++的用途</h2><ul><li>everywhere</li><li>everything</li><li>invisible</li></ul><p>Zero 零开销<br />语言的发展和Compiler的发展紧密相关。当compiler做的比人好时，才可以将对应的语言成分添加进来。<strong>避免效率上的降低。包含了C，又实现了抽象，同时又不降低效率</strong><br />Syntax - Deduct Reduce</p><h3 id="命令式编程范式"><a href="#命令式编程范式" class="headerlink" title="命令式编程范式"></a>命令式编程范式</h3><ul><li>结构化程序设计：<strong>顺序、选择、循环</strong> 三种控制结构决定了整个控制流</li><li>面向对象程序设计：<strong>封装、继承、多态</strong> 没有改变命令式编程范式的状态转换的思想</li></ul><h3 id="声明式编程范式"><a href="#声明式编程范式" class="headerlink" title="声明式编程范式"></a>声明式编程范式</h3><p><code>Select xxx form xxx when xxx</code>无法知道某一时刻程序的状态 &#x3D;&gt;数据库管理系统（<strong>有后台系统管理支撑</strong>）<br />风险：不可控，虽然描述简单，但无法对复杂度进行控制。 </p><ul><li>函数式编程：代码简洁、易于理解、并发（不依赖时间和环境）。要求：<strong>纯函数</strong>：<strong>不依赖环境，如果改变了外部环境，就会产生副作用</strong></li></ul><p>**但是，副作用在程序中非常有效     **</p><ul><li>逻辑程序设计</li></ul><h3 id="遗传程序设计-Genetic-Programming"><a href="#遗传程序设计-Genetic-Programming" class="headerlink" title="遗传程序设计 Genetic Programming"></a>遗传程序设计 Genetic Programming</h3><ol><li>算法不依赖于数据结构的特定实现，算法可以从特定实现中抽象出来，而且<strong>效率无损</strong></li><li>ADT把实现和接口分开，不应该忽略复杂度</li><li>template并不实际生成代码，类似于图纸，在编译时生成对应的数据类型。描述算法的时候不使用数据类型，但实际上运行时需要有代码，所以依靠的就是template</li><li>Alexander Stepanov 设计了STL（standard template library） - &gt; <strong>泛型程序设计</strong></li></ol><br /><h3 id="函数式程序设计-functonal-programming"><a href="#函数式程序设计-functonal-programming" class="headerlink" title="函数式程序设计 functonal  programming"></a>函数式程序设计 functonal  programming</h3><h3 id="结构化程序设计-Structured-Programming"><a href="#结构化程序设计-Structured-Programming" class="headerlink" title="结构化程序设计 Structured Programming"></a>结构化程序设计 Structured Programming</h3><h3 id="面向对象程序设计-Objected-oriented-Programming"><a href="#面向对象程序设计-Objected-oriented-Programming" class="headerlink" title="面向对象程序设计 Objected-oriented Programming"></a>面向对象程序设计 Objected-oriented Programming</h3><h2 id="历史发展路径"><a href="#历史发展路径" class="headerlink" title="历史发展路径"></a>历史发展路径</h2><p> <img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664261519533-1aad5d5d-00c7-4cd4-aaef-2d0eefcb7d31.png" alt="image.png"></p><hr><h2 id="C-是C的超集"><a href="#C-是C的超集" class="headerlink" title="C++是C的超集"></a>C++是C的超集</h2><p>C++ 支持 C 所支持的全部编程技巧<br />任何 C 程序都能被 C++ 用基本相同的方法编写，并具备同等开销（时间、空间）</p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO 设计</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/IO%20%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/IO%20%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="getline（）"><a href="#getline（）" class="headerlink" title="getline（）"></a>getline（）</h2><p>Get line from stream into string</p><ul><li>Extracts characters from <em>is</em> and stores them into <em>str</em> until the delimitation character <em>delim</em> is found (or the newline character, ‘\n’, for <em>(2)</em>).</li></ul><p>从is中提取字符并将其存储到str中，直到找到<strong>分隔符delim</strong>（或**换行符’\n’**，for（2））。</p><ul><li>The extraction also stops if the end of file is reached in <em>is</em> or if some other error occurs during the input operation.</li></ul><p>如果在中到达文件结尾，或者在输入操作期间发生其他错误，提取也会停止。</p><ul><li>If the delimiter is found, it is extracted and discarded (i.e. it is not stored and the next input operation will begin after it).</li></ul><p>如果找到分隔符，则会将其提取并丢弃（即不存储它，然后将开始下一个输入操作）。</p><ul><li>Note that any content in str before the call is replaced by the newly extracted sequence.<br />Each extracted character is appended to the <a href="https://cplusplus.com/string">string</a> as if its member <a href="https://cplusplus.com/string::push_back">push_back</a> was called.</li></ul><p>请注意，调用之前str中的任何内容都将被新提取的序列替换。<br />每个提取的字符都附加到字符串中，就好像调用了其成员push_back一样。</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>使用指针开辟数组时，一定要在使用前<strong>初始化值</strong></li><li>使用指针才能够开辟动态数组，但是不太容易得到数组的长度</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三课 Function</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%89%E8%AF%BE%20Function/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%89%E8%AF%BE%20Function/</url>
      
        <content type="html"><![CDATA[<p>BNF</p><ol><li>Associativity 结合性</li><li>Priority</li><li>Type conversion 混合类型运算时的数据类型转换（决定了二进制序列的解释方式）</li><li>Evaluation order 求值次序 &#x3D; &gt; side effect 从左往右和从右往左算的时候结果不一样 （表达式的副作用没有用，函数的副作用才有用）</li></ol><p>异常：Exception  <br />特征：</p><ol><li>可以预见到</li><li>无法避免</li></ol><p>类型：</p><ul><li>Side effect</li><li>精度问题：类型转换涉及精度变换   doube -&gt; int 窄转换</li><li>Overflow</li></ul><h2 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h2><p>许多改进都是为了<strong>更方便的写程序，减少错误</strong></p><ol><li>auto - 编译器根据表达式确定数据类型，避免数据类型名的重复。关键字的引入需要综合考虑，如果太短，会造成已有的变量名冲突，如果太长，则会不受欢迎</li><li>Range-for <code>for(auto i:vector )</code><ol><li>for <code>trivial</code>错误</li><li>避免for循环的边界错误</li></ol></li><li>Uniform Initialization 结构化和OO的初始化不一致</li><li>Constexpr  利用<strong>纯函数</strong>不能受到状态的影响</li></ol><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>以空间换时间：<br />用表存储switch的所有结果，实现一次比较找到目标<br />可以用if else 、表、平衡二叉树表示</p><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664432297062-f3537141-b196-4496-8fbc-1a7b58a3d4a4.png" alt="image.png"><br>Data 全局数据区：下界清楚，存放全局变量<br />栈：存放函数。可以重复利用有限空间，符合局部性原则，由编译器控制生死<br />堆：存放动态变量，malloc()，heap中的管理由程序员接管<br />栈和堆的大小由程序运行的逻辑决定，所以<strong>堆从下往上，栈从上往下</strong><br />代码区：以function为基本单位，函数有完整的逻辑。<br />函数有定义点和调用点。所以函数定义时也需要存储在符号表中。节省了重复代码的出现。<br /><strong>RAII</strong>机制<br /><strong>DLL</strong>按需所取，牺牲时间，节省空间，但是不是全平台自适应，因为不一定有对应的code<br />static：永远分配 - 》 给予固定空间：无法实现递归，好处是减少了和内存之间的交互<br />函数的调用：后进先出 – &gt; 表达能力更强（可以递归），但是在数据区付出了更多的<strong>COST 代价</strong><br />符号表的建立：</p><ol><li>当看到<strong>使用点</strong>时，在符号表中找到对应的地址，取值使用</li><li>当和lib进行link时，找到需要的变量</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664431914980-4d999132-86af-419c-a6ab-916fc037af8f.png" alt="image.png"></p><ol><li>C里面不允许函数重载，所以可以用fun代表 。但是如果重载，需要在符号表中嵌入参数</li><li><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664432871903-1ba977fa-21fe-42b0-a0a5-695cbe9d27a0.png" alt="image.png">  4代表后面四个字节为函数名，i代表int，d代表double   &#x3D;&gt;  使用Lib需要注意什么？ &#x3D;&gt; <strong>添加接口 <strong><code>**extern &quot;C&quot; **</code></strong> &#x3D;&gt; 判断有无name mangling</strong></li></ol><h3 id="函数的COST"><a href="#函数的COST" class="headerlink" title="函数的COST"></a>函数的COST</h3><p>函数：复用机制+自顶向下，逐步求精<br />指令开销+数据开销<br />能在不降低可读性的前提下，降低COST吗？</p><ol><li>在src源代码中写的是函数</li><li>在经过编译器编译后，将函数代码直接放在对应的代码块中，不产生函数调用，省去了压栈出栈的过程</li></ol><p>缺点：</p><ol><li>替换后代码会拉长</li><li>代码段的拉长会带来危害</li></ol><p>程序员主动使用<code>inline</code>，向编译器提出申请，直接把函数对应的代码放入源代码中 &#x3D;&gt; 因为不是完美的，所以需要程序员自己提出申请。但是，<strong>提出申请后，编译器有权驳回</strong><br />程序员使用<code>virtual</code> 提出<code>dynamic binding</code>，副作用：效率较低，以低效率获得语言的灵活性。不像java，全部默认为<code>dynamic binding</code>。 <strong>Programmer can be trusted</strong><br />原则</p><ul><li>定义不允许嵌套</li><li>先定义后使用：给描述以约束，同时提高编译器的效率：编译器是一个个cpp扫描的</li></ul><h3 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数 inline"></a>内联函数 inline</h3><p>要明智的申请inline函数</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>提高可读性，提高效率</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>编译系统将为 inline 函数创建一段代码，在调用点，以相应的代码替换</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法实现递归，语言表达能力降低</li><li>代码段的增加会带来效率的降低</li><li>函数指针</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ol><li>函数的长度短小，避免替代带来额外开销</li><li>使用频繁的代码</li><li>简单的代码：不要有多个转移接口的结构</li></ol><p><strong>构造函数</strong>适合inline函数。构造函数放入class的定义中，会自动申请inline</p><h4 id="局部性原则"><a href="#局部性原则" class="headerlink" title="局部性原则"></a>局部性原则</h4><p>为什么代码段增大会出现问题？为什么不能有复杂的数据结构？<br /><strong>时间局部性，空间局部性 &#x3D;&gt; 每一次都是调用相关的放入内存，如果有额外需要，再通过虚拟内存管理，从硬盘中获得对应数据</strong><br />因为内存是分级的，附近的代码放入Cache中（高速缓存）。原来的Cache中，为<code>x=1 ;f(1) ;</code>，一直都在Cache中循环。但如果<code>f(1)</code>替代为<code>Ablock</code>，因为Cache有限，block中的有些代码在Cache中，有些不在，需要不断调换block在Cache中的代码。Cache中会产生<strong>抖动</strong>，即<strong>调度的cost</strong></p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增大目标代码</li><li>病态的换页</li><li>降低指令快取装置的命中率</li></ul><h3 id="函数指针-？？"><a href="#函数指针-？？" class="headerlink" title="函数指针 ？？"></a>函数指针 ？？</h3><p>实现<code>framework</code></p><h3 id="函数的执行机制"><a href="#函数的执行机制" class="headerlink" title="函数的执行机制"></a>函数的执行机制</h3><ul><li>建立被调用函数的栈空间</li><li>参数传递</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664433776047-374a9de5-e426-45ea-83d0-ffed58580c62.png" alt="image.png"></p><ul><li>值传递</li><li>引用传递</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664435210023-67c5958e-e097-4127-b390-eabe1c7acef3.png" alt="image.png"></p><ul><li>保存调用函数的运行状态</li><li>将控制转交给被调用函数</li></ul><p><strong>局部变量要主动初始化</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664434310533-342546b2-d6c4-4495-a4f2-62321d71fe37.png" alt="image.png"></p><h3 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h3><h4 id="cdecl"><a href="#cdecl" class="headerlink" title="_cdecl"></a>_cdecl</h4><h4 id="stdcall"><a href="#stdcall" class="headerlink" title="_stdcall"></a>_stdcall</h4><p><strong>参数的空间是由被调用者返回，不支持参数是可变长的  — 适合平台的协作</strong></p><ul><li><strong>_cdecl：参数的空间是由调用者返回，支持参数是可变长的 例如：</strong><code>**printf(char  *s, ...) **</code></li></ul><p>可变参数的缺点： </p><ol><li><code>**printf(&quot;hi &quot;,num1,num2 )**</code> 有缺陷：没有用num1 num2，却可以拿到对应的值，不安全</li><li>会增大代码的长度。因为调用是复用多次的，所以积少成多了</li></ol><p><code>cout</code>中<code>&lt;&lt;</code>是双目操作符，实现原理是操作符重载，而不是可变参数的调用<br />调用者还和被调用者还<br />差别：发生在返回时</p><h4 id="fastcall"><a href="#fastcall" class="headerlink" title="_fastcall"></a>_fastcall</h4><p>参数传递放入的是寄存器中，而不是push到栈中<br />瓶颈：<br />寄存器数量有限，每用一个寄存器，寄存器中原有的值都要保存下来</p><h4 id="thiscall"><a href="#thiscall" class="headerlink" title="_thiscall"></a>_thiscall</h4><p>略</p><h3 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h3><h4 id="Call-by-name"><a href="#Call-by-name" class="headerlink" title="Call by name"></a>Call by name</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664436709907-02d36654-e2eb-453c-9fb1-810fd5d02fe6.png" alt="image.png"><br>结果: a[2] &#x3D; 3</p><h4 id="Call-by-value-result"><a href="#Call-by-value-result" class="headerlink" title="Call by value-result"></a>Call by value-result</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664436780089-f29835a9-326d-445d-afc1-dcd8c2a9302a.png" alt="image.png"></p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>原型：<code>void f（int ， int）</code><br />编译器在调用函数时，能根据原型生成正确的代码<br />如果编译没找到时，也会在link时找到</p><ul><li>遵循先定义后使用原则</li><li>自由安排函数定义位置</li><li>只需参数类型，无需参数名称</li><li>编译器检查</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>原则：</p><ul><li>名同，参数不同</li><li>返回值类型不作为区别重载函数的依据</li></ul><p>匹配原则</p><ul><li>会产生<strong>二义性</strong>：10可以转为long，也可以转为double <code>**ambiguous**</code></li><li>严格</li><li>内部转换</li><li>用户定义的转换</li></ul><p>意义：多态<strong>一名多用</strong> 属于语言的特征</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ol><li>默认参数的声明<ol><li>函数原型中给出 <code>int f(int =1,int =2,int =3)</code> <strong>原型决定默认参数</strong></li><li>先定义的函数给出</li></ol></li><li>默认参数的顺序<ol><li><br /></li></ol></li><li>默认参数与函数重载</li></ol><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><ul><li>提供坏地址 &#x3D; &gt; 指令和数据为正交</li><li>不自动写代码，而是选择指令去运行（借刀杀人）&#x3D;&gt; 内存地址的随机化，不会产生错误，只会产生异常</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计类题目</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E7%B1%BB%E9%A2%98%E7%9B%AE/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E7%B1%BB%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="355-设计推特"><a href="#355-设计推特" class="headerlink" title="355. 设计推特"></a><a href="https://leetcode.cn/problems/design-twitter/">355. 设计推特</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/10/3.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设计推特</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> timestamp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tweet</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tweet* next;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="built_in">Tweet</span>(<span class="type">int</span> id,<span class="type">int</span> time)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;time = time;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; followed;</span><br><span class="line">    Tweet* head;</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">int</span> userId)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = userId;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//        默认关注自己</span></span><br><span class="line">        <span class="built_in">follow</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        关注用户</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">follow</span><span class="params">(<span class="type">int</span> userId)</span></span>&#123;</span><br><span class="line">        followed.<span class="built_in">insert</span>(userId);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        取消关注</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unfollow</span><span class="params">(<span class="type">int</span> userId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (userId!= <span class="keyword">this</span>-&gt;id)&#123;</span><br><span class="line">            followed.<span class="built_in">erase</span>(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(<span class="type">int</span> tweetId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tweet = <span class="keyword">new</span> <span class="built_in">Tweet</span>(tweetId,timestamp);</span><br><span class="line">        timestamp++;</span><br><span class="line">        tweet-&gt;next = head;</span><br><span class="line">        head = tweet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> userId;</span><br><span class="line"><span class="comment">//    unordered_map&lt;int,*User&gt; userMap;</span></span><br><span class="line"><span class="comment">//    unordered_map&lt;int,User&gt; userMap;</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,User*&gt; userMap;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Twitter</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        c++ unordered_map不允许有重复的key。因此，如果key存在，则count返回1，如果不存在，则count返回0.</span></span><br><span class="line">        <span class="keyword">if</span> (!userMap.<span class="built_in">count</span>(userId))&#123;</span><br><span class="line">            User* newUser = <span class="keyword">new</span> <span class="built_in">User</span>(userId);</span><br><span class="line">            userMap.<span class="built_in">insert</span>(&#123;userId, newUser&#125;);</span><br><span class="line">            <span class="comment">//            userMap.insert(userId,*new User(userId))</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> user = userMap.<span class="built_in">find</span>(userId);</span><br><span class="line">        user-&gt;second-&gt;<span class="built_in">post</span>(tweetId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** follower 关注 followee */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若 follower 不存在，则新建</span></span><br><span class="line">        <span class="keyword">if</span> (!userMap.<span class="built_in">count</span>(followerId))&#123;</span><br><span class="line">            User *newUser = <span class="keyword">new</span> <span class="built_in">User</span>(followerId);</span><br><span class="line">            userMap.<span class="built_in">insert</span>(&#123;followerId,newUser&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 followee 不存在，则新建</span></span><br><span class="line">        <span class="keyword">if</span> (!userMap.<span class="built_in">count</span>(followeeId))&#123;</span><br><span class="line">            User *newUser = <span class="keyword">new</span> <span class="built_in">User</span>(followeeId);</span><br><span class="line">            userMap.<span class="built_in">insert</span>(&#123;followeeId,newUser&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        userMap.<span class="built_in">find</span>(followerId)-&gt;second-&gt;<span class="built_in">follow</span>(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** follower 取关 followee，如果 Id 不存在则什么都不做 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (userMap.<span class="built_in">count</span>(followerId))&#123;</span><br><span class="line">            <span class="keyword">auto</span> follower = userMap.<span class="built_in">find</span>(followerId);</span><br><span class="line">            follower-&gt;second-&gt;<span class="built_in">unfollow</span>(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt; 运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (Tweet &amp;a, Tweet &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b.time &gt; a.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;Twitter::<span class="built_in">getNewsFeed</span>(<span class="type">int</span> userId) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!userMap.<span class="built_in">count</span>(userId))&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; followersId = userMap.<span class="built_in">find</span>(userId)-&gt;second-&gt;followed;</span><br><span class="line">    priority_queue&lt;Tweet*&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> id : followersId )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> usr = userMap.<span class="built_in">find</span>(id)-&gt;second-&gt;head;</span><br><span class="line">        <span class="keyword">if</span> ( !usr ) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        pq.<span class="built_in">push</span>(usr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( !pq.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( res.<span class="built_in">size</span>() == <span class="number">10</span> ) <span class="keyword">break</span>;</span><br><span class="line">        Tweet *twt = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(twt-&gt;id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( twt-&gt;next )</span><br><span class="line">        &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(twt-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先级队列实现"><a href="#优先级队列实现" class="headerlink" title="优先级队列实现"></a>优先级队列实现</h4><p><a href="http://c.biancheng.net/view/6987.html">C++ STL priority_queue容器适配器详解</a></p><h4 id="无序map容器"><a href="#无序map容器" class="headerlink" title="无序map容器"></a>无序map容器</h4><p><a href="http://c.biancheng.net/view/7231.html">C++ STL unordered_map容器用法详解</a></p><h4 id="运算符重载支持自定义比较函数"><a href="#运算符重载支持自定义比较函数" class="headerlink" title="运算符重载支持自定义比较函数"></a>运算符重载支持自定义比较函数</h4>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第四课 程序组织</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%9B%9B%E8%AF%BE%20%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%9B%9B%E8%AF%BE%20%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87/</url>
      
        <content type="html"><![CDATA[<h2 id="程序组织"><a href="#程序组织" class="headerlink" title="程序组织"></a>程序组织</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664867305730-0e04b845-a0b6-4d31-aa70-fbecfdec6975.png" alt="image.png"></p><p>作用域scope </p><ul><li>程序级：link中都是可见的</li><li>函数级</li><li>块级</li><li>文件级</li></ul><p>生命周期：获得内存 - &gt; 失去内存。生命周期外的数据都是无效的<br /><strong>idle point</strong> 悬挂指针 – 想要的资源被人夺走了</p><h3 id="引入外部数据"><a href="#引入外部数据" class="headerlink" title="引入外部数据"></a>引入外部数据</h3><p>extern：非本地定义的，进行引入<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664867669847-e620aea7-f570-46e5-b616-4690212bce65.png" alt="image.png"><br>头文件：将给别人的接口、数据写在头文件中。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664867774586-de2f9ca1-0927-40a5-853d-154892edfe4e.png" alt="image.png"><br><code>#</code><strong>编译预处理符号，作用为</strong><code>**editor**</code>   include找到对应头文件，ctrl+all+进行copy。后缀<code>.h</code>不是必须的，是统一规范好的<br />static：<strong>将作用域由程序级限制为文件级</strong>。因此，即使变量重名，互相不影响。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664868100617-e238648c-b115-4faf-9d73-aa65434e94f9.png" alt="image.png"><br>公开的放入头文件中，为程序级。私有的设置<code>static</code>，为文件级。<br />对于常量：默认属性为static<br />使用常量头文件<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664868126354-ddc3d778-37eb-4e42-ad50-6adc61a4d339.png" alt="image.png"></p><p>main中的局部变量是<strong>全生命周期的</strong><br />static定义的局部变量是静态局部变量，当自己创建后不会被消除</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ol><li>常量定义</li><li>变量、函数声明</li><li>编译预处理</li><li>类型定义</li><li>inline函数</li></ol><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664868545815-d0187d6c-f2f8-4b82-96bd-e9dec6ae584f.png" alt="image.png"><br>declaration：类似绝对路径<br />directive：使用目录，批量处理</p><ul><li>开放：当需要补充时，直接在当前文件补充代码即可</li><li>别名</li><li>全局</li><li>可嵌套</li><li>重载：不建议在同一作用域两次使用using-directive，优先考虑  using-declaration</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664868814834-34f93d66-d599-4ce2-a441-1a7fc0989488.png" alt="image.png"></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><a href="https://blog.csdn.net/ypshowm/article/details/89030194#:~:text=static%20%E6%98%AFC%2F,C%2B%2B%E4%B8%AD%E7%9A%84%20%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%E3%80%82">c++中static的作用</a></p><ol><li>修饰<strong>局部变量</strong>时，表明该变量的值不会因为函数终止而丢失。  </li><li>修饰<strong>函数</strong>时，表明该函数只在同一文件中调用。</li><li>修饰<strong>全局变量</strong>时，表明一个全局变量只对定义在同一文件中的函数可见。</li></ol><h3 id="编译预处理"><a href="#编译预处理" class="headerlink" title="编译预处理"></a>编译预处理</h3><p>不理解cpp的语法，没有程序设计的概念。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664869191454-f81af710-8dbe-4e6b-bbc0-d833d90153ac.png" alt="image.png"></p><ul><li>穿透作用域</li><li>潜伏于环境  <code>gcc -7 -Dsqrt=rand -Dreturn=exit </code>等价 <code>#define sqrt random</code></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664869150689-3cb3aaff-4613-431d-bf6c-264d9679f6f1.png" alt="image.png"></p><p>替代编译预处理：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664869273741-1ab1e243-846c-42f9-8bdf-0fcd3a656191.png" alt="image.png"><br>log：记录执行时间、次数等，利用<code>_FILE_</code>等宏。</p><h4 id="ifdef"><a href="#ifdef" class="headerlink" title="ifdef"></a>ifdef</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> check </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> release 定义最后将要发布的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  如果check没有定义，则后面的相关代码根本不会产生。让程序员选择</span></span><br><span class="line">将要参与编译的语句。仍然是在editor期间发挥作用</span><br></pre></td></tr></table></figure><ul><li>版本控制</li><li>注释代码</li></ul><h4 id="pragma"><a href="#pragma" class="headerlink" title="pragma"></a>pragma</h4><ol><li>error</li><li>warning：包含潜在的错误，进行预警<ol><li>local variable没有定义</li><li>strcpy 的两个长度不同</li><li>强制转换时会产生精度损失</li></ol></li></ol><p>利用pragma可以把warning升级为error</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic <span class="keyword">error</span> <span class="string">&quot;-Wuninitialized&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i;    <span class="built_in">printf</span>(“%d\n<span class="string">&quot;, i);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>利用pragma进行编译预处理，常用于没有ide时</p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++常用处理</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/C++%E5%B8%B8%E7%94%A8%E5%A4%84%E7%90%86/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/C++%E5%B8%B8%E7%94%A8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-输入多行字符串出错"><a href="#1-输入多行字符串出错" class="headerlink" title="1. 输入多行字符串出错"></a>1. 输入多行字符串出错</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; ws;</span><br><span class="line"><span class="comment">//    输入整数后，后面会跟着一个换行符，需要额外进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        string line;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关键：使用<code>**cin&gt;&gt;ws**</code>来吸收残存在输入流中的换行符</p><h3 id="2-判断字符串内容是否为整数"><a href="#2-判断字符串内容是否为整数" class="headerlink" title="2. 判断字符串内容是否为整数"></a>2. 判断字符串内容是否为整数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(<span class="type">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> &amp;c: str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键：调用<code>**isdigit()**</code>函数，一个一个进行判断，不要嫌弃麻烦<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664888337017-65e8ea0f-6c34-43cb-8043-8c3f78ad0cb4.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664888353963-5d911b02-9b7a-4761-91d1-1799257bd802.png" alt="image.png"></p><h3 id="3-字符串按字符切割"><a href="#3-字符串按字符切割" class="headerlink" title="3. 字符串按字符切割"></a>3. 字符串按字符切割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">stringSpilt</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> <span class="type">char</span> split, vector&lt;string&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">    string token;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(iss, token, split)) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键：</p><ol><li>调用<code>**istringstream iss (str)**</code></li><li>调用 <code>**getline(iss,token,split)**</code></li></ol><h3 id="4-修改哈希表中的值"><a href="#4-修改哈希表中的值" class="headerlink" title="4. 修改哈希表中的值"></a>4. 修改哈希表中的值</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setVariable</span><span class="params">(string &amp;str, string &amp;val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">checkVal</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (mapVal.<span class="built_in">count</span>(str))&#123;</span><br><span class="line">        mapVal.<span class="built_in">erase</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    mapVal.<span class="built_in">insert</span>(&#123;str, <span class="built_in">stoi</span>(val)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>直接使用数组的表现形式进行增加或者修改</p><h3 id="5-字符串转数字"><a href="#5-字符串转数字" class="headerlink" title="5. 字符串转数字"></a>5. 字符串转数字</h3><p><strong>stoi</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;2&quot;</span>) &lt;&lt; endl;   <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;21214 avb&quot;</span>) &lt;&lt; endl;<span class="comment">//21214</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;1000&quot;</span>, <span class="literal">nullptr</span>, <span class="number">2</span>) &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stof</span>(<span class="string">&quot;221.4240&quot;</span>) &lt;&lt; endl;<span class="comment">//221.424</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stoi</span>(<span class="string">&quot;221.4240&quot;</span>) &lt;&lt; endl;<span class="comment">//221</span></span><br></pre></td></tr></table></figure><h3 id="6-纯手工char数组转数字"><a href="#6-纯手工char数组转数字" class="headerlink" title="6. 纯手工char数组转数字"></a>6. 纯手工char数组转数字</h3><p>写该函数时，涉及到的小的细节特别的多，需要条理清晰地进行解答。</p><ol><li><code>index</code>问题，因为涉及到<code>arr</code>和<code>tmp</code>双数组，且分别用了<code>i</code> <code>j</code> <code>count</code>三个数字来表示下标。因此，很容易出错。<strong>如果发现输入不同却输出相同时，很可能是下标</strong><code>**j**</code>** 使用时不小心打的是**<code>**count**</code></li><li>初始化问题。因为传入的cmd数组初始化时是<code>**char* cmd[20] = &#123;&#39;0&#39;&#125;;**</code> 。但是，最终赋值的时候，却初始化的是 <code>**&#39;\000&#39;**</code> ，对应的ASCII码值是0。而在这之中，我一直是以48的ASCII码值去进行计算。最终导致结果总是不对</li><li><strong>下标和指数的不一致：该问题很经典。对于一个数组，读取时是需要从右往左读的，但是，这样子时，常用的</strong><code>**i**</code><strong>就不能直接作为pow的第二个参数使用，而是要额外使用一个变量。即：读取时是从右往左，计算时却是从左往右</strong></li><li>最后的一个处理是char数组的结束符是跟随系统的变化而变化的，因此要十分小心。</li><li>关于<strong>负数</strong>🍀~蚌埠住了哇Σ(っ °Д °;)っ。还有<strong>小数</strong>的处理。要<strong>根据需要进行优化</strong>吧<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *tmp = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * DEF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; DEF; ++i) &#123;</span><br><span class="line">        tmp[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = start; j &lt; DEF; ++j) &#123;</span><br><span class="line">        <span class="type">char</span> x = cmd[j];</span><br><span class="line">        tmp[count] = cmd[j];</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="comment">//        int x = tmp[i]-&#x27;0&#x27;;</span></span><br><span class="line"><span class="comment">//        x 被赋值为1 或者 -48 了 原因是cmd初始化时里面是 0&#x27;\000&#x27; 而不是 48&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">//          两者的区别造成了算数时无法统一</span></span><br><span class="line">        <span class="keyword">if</span> (tmp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最开始是使用tmp[count] OMG！！怎么会这么不小心</span></span><br><span class="line">        ans += (tmp[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(<span class="number">10</span>,w );</span><br><span class="line">        w++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="7-去重"><a href="#7-去重" class="headerlink" title="7. 去重"></a>7. 去重</h3><h4 id="set-assign"><a href="#set-assign" class="headerlink" title="set+assign"></a>set+assign</h4><p>在三数求和为0的题目中，需要进行去重。那么最好的方式是使用<code>set</code>集合进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;vector&lt;<span class="type">int</span>&gt;&gt; tmp&#123;ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()&#125;;</span><br><span class="line">ans.<span class="built_in">assign</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure><p>此处<code>ans</code>中有重复的元素，则利用<code>set&lt;T&gt;</code>进行 初始化后再重新赋值即可</p><ul><li>assign可以理解为利用迭代器<strong>重新进行赋值</strong>。那么其ans中的原本数据会丢失<blockquote><p>函数原型是：<br>1:void assign(const_iterator first,const_iterator last);<br>2:void assign(size_type n,const T&amp; x &#x3D; T());<br>第一个相当于个<strong>拷贝函数，把first到last的值赋值给调用者</strong>；（<strong>注意区间的闭合-前闭后开</strong>）<br>第二个把n个x赋值给调用者；</p></blockquote></li></ul><h4 id="sort-unique-erase"><a href="#sort-unique-erase" class="headerlink" title="sort+unique+erase"></a>sort+unique+erase</h4><ol><li>unique函数属于STL中比较常用函数，它的功能是元素去重。即<strong>”删除”序列中所有相邻的重复元素(只保留一个)<strong>。此处的删除，并不是真的删除，而是</strong>指重复元素的位置被不重复的元素给占领了</strong>(详细情况，下面会讲)。由于它”删除”的是相邻的重复元素，所以<strong>在使用unique函数之前，一般都会将目标序列进行排序</strong>。</li><li>unique函数通常和erase函数一起使用，来达到删除重复元素的目的。(注：此处的删除是真正的删除，即从容器中去除重复的元素，<strong>容器的长度也发生了变换</strong>；而单纯的使用unique函数的话，<strong>容器的长度并没有发生变化</strong>，只是元素的位置发生了变化)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> myints[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(myints)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(myints, myints + len)</span></span>;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    vec.<span class="built_in">erase</span>(<span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : vec)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>iterator unique(iterator it_1,iterator it_2);<br>这种类型的unique函数是我们最常用的形式。其中这两个参数表示对容器中[it_1，it_2)范围的元素进行去重(注：区间是前闭后开，即不包含it_2所指的元素),返回值是一个迭代器，<strong>它指向的是去重后容器中不重复序列的最后一个元素的下一个元素。</strong><br>unique函数的去重过程实际上就是不停的把后面不重复的元素移到前面来，也可以说是用不重复的元素占领重复元素的位置。</p></blockquote></li></ol><h3 id="8-二分法"><a href="#8-二分法" class="headerlink" title="8. 二分法"></a>8. 二分法</h3><h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h4><ol><li><p>原型1:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,  <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>原型2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h5 id="模板参数解释"><a href="#模板参数解释" class="headerlink" title="模板参数解释"></a>模板参数解释</h5><ol><li><code>ForwardIterator</code>就是一个迭代器，<code>vector&lt; int &gt; v</code>，v数组的首元素就是 <code>v.begin()</code></li><li><code>T&amp;val</code> , 就是一个T类型的变量</li><li><code>Compare</code> 就是一个比较器，可以传仿函数对象，也可以传函数指针</li></ol><h5 id="函数作用："><a href="#函数作用：" class="headerlink" title="函数作用："></a>函数作用：</h5><p>前提是<strong>有序</strong>的情况下，<code>lower_bound</code>返回指向第一个值不小于<code>val</code>的位置，也就是返回第一个<strong>大于等于</strong><code>val</code>值的位置。（通过二分查找）</p><h5 id="参数、返回值含义"><a href="#参数、返回值含义" class="headerlink" title="参数、返回值含义"></a>参数、返回值含义</h5><ul><li><strong>first,last</strong>: 迭代器在排序序列的起始位置和终止位置，使用的范围是<code>[first,last)</code>包括</li></ul><p><code>first</code>到<code>last</code>位置中的所有元素</p><ul><li><strong>val</strong>: 在<code>[first,last)</code>下，也就是区分（找到<strong>大于等于</strong>val值的位置，返回其迭代器）</li><li><strong>comp</strong>： 主要针对于原型二，传一个函数对象，或者函数指针，按照它的方式来比较</li><li><strong>返回值</strong>：返回一个迭代器，指向第一个大于等于val的位置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v= &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//先排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()); <span class="comment">// 1 2 3 4 8</span></span><br><span class="line"><span class="comment">// 定义两个迭代器变量 </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter2; </span><br><span class="line">iter1 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">3</span>);<span class="comment">//迭代器指向3</span></span><br><span class="line">iter2 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">8</span>);<span class="comment">//迭代器指向8（因为第一个大于等于8）</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; *iter1 &lt;&lt; endl; <span class="comment">//输出3</span></span><br><span class="line">    cout &lt;&lt; *iter2 &lt;&lt; endl; <span class="comment">//输出8 说明能够找到最后一个元素</span></span><br><span class="line">    cout &lt;&lt; *iter3 &lt;&lt; endl; <span class="comment">//输出为0</span></span><br><span class="line">cout &lt;&lt; iter1 - v.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//下标 2</span></span><br><span class="line">cout &lt;&lt; iter2 - v.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//下标 4 </span></span><br><span class="line">    cout &lt;&lt; iter3 - v.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//下标5</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">end</span>() - v.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//返回值为5</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h4><p>用法和上面类似。<strong>只是把lower_bound的大于等于换成大于</strong>。仿函数等等<strong>全是相同的用法</strong></p><h3 id="9-迭代器"><a href="#9-迭代器" class="headerlink" title="9. 迭代器"></a>9. 迭代器</h3><h4 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h4><p>容器的end()方法，返回一个<a href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&spm=1001.2101.3001.7020">迭代器</a>，需要注意：这个迭代器<strong>不指向实际的元素</strong>，而是<strong>表示末端元素的下一个元素</strong>，这个迭代器起一个哨兵的作用，<strong>表示已经处理完所有的元素</strong>。<br />因此，在查找的时候，<strong>返回的迭代器，不等于end()，说明找到了目标</strong>。<strong>等于end()，说明检查了所有元素，没有找到目标。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(matrix[i].<span class="built_in">begin</span>(),matrix[i].<span class="built_in">end</span>(),target);</span><br><span class="line">        <span class="keyword">if</span> (it != matrix[i].<span class="built_in">end</span>() &amp;&amp; *it ==target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 此处用二分法获得迭代器，但同时使用 💥!=end() 来说明已经找到了</span></span><br><span class="line">            <span class="comment">// 因为没找到都是默认返回end迭代器，或者说是最后一个元素的下一个元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-自定类处理"><a href="#10-自定类处理" class="headerlink" title="10. 自定类处理"></a>10. 自定类处理</h3><h4 id="vector存储"><a href="#vector存储" class="headerlink" title="vector存储"></a>vector存储</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">movie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> movieId;</span><br><span class="line">    <span class="type">bool</span> isRented;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="type">int</span> shopId;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">movie</span>(<span class="type">int</span> movieId, <span class="type">int</span> price, <span class="type">int</span> shopId) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;movieId = movieId;</span><br><span class="line">        <span class="keyword">this</span>-&gt;price = price;</span><br><span class="line">        <span class="keyword">this</span>-&gt;shopId = shopId;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isRented = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于<code>movie</code>类，如果要用<code>vector</code>存储，有以下可能的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;movie&gt; movieList;</span><br><span class="line"><span class="comment">// 1.在vector中直接存储对象</span></span><br><span class="line">vector&lt;*movie&gt; movieList;</span><br><span class="line"><span class="comment">// 2.错误的使用指针的表示方式</span></span><br><span class="line">vector&lt;movie*&gt; movieList;</span><br><span class="line"><span class="comment">// 3.使用指向movie的指针</span></span><br></pre></td></tr></table></figure><p>建议不直接存储对象</p><ol><li><code>STL</code>的存储实际上是拷贝，因此会重新调用构造函数，再进行赋值，开销大</li><li>从<code>STL</code>中获得的值也不是原来的对象，而是一份新的拷贝，所以存储的指针的值也会改变</li><li>因此，使用指针能够节省成本</li></ol><h4 id="STL删除"><a href="#STL删除" class="headerlink" title="STL删除"></a>STL删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;obj *&gt;m_list;</span><br><span class="line">list&lt;obj *&gt;::iterator ite;</span><br><span class="line"><span class="keyword">for</span>( ite = m_list.<span class="built_in">begin</span>(); ite != m_list.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">delete</span> (*ite);</span><br><span class="line">ite = m_list.<span class="built_in">erase</span>(ite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先<code>delete</code>，释放内存，在将其从容器中删除</p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><ol><li><code>shop *shop = new class shop_(_shopId_)_;</code></li></ol><p><code>auto *ptr = new class shop_(_shop_)_;</code><br />如果只使用<code>shop *shop;</code>则在重新赋值的时候会出现错误</p><ol start="2"><li>容器中最好存储指针，否则也会出现一些错误，使用指针在进行函数的调用和参数的传递时是比较方便的。</li></ol><h3 id="11-自定义函数比较"><a href="#11-自定义函数比较" class="headerlink" title="11. 自定义函数比较"></a>11. 自定义函数比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;movie*&gt; movieRented;</span><br><span class="line">std::<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;movieRented.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;movieRented.<span class="built_in">end</span>(), compMovie);</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compMovie</span><span class="params">(<span class="type">const</span> movie *mov1, <span class="type">const</span> movie *mov2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mov1-&gt;price == mov2-&gt;price) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mov1-&gt;shopId == mov2-&gt;shopId) &#123;</span><br><span class="line">            <span class="comment">// * 5.如果仍然相同，则 moviej 较小 的排在前面</span></span><br><span class="line">            <span class="keyword">return</span> mov1-&gt;movieId &lt; mov2-&gt;movieId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// * 4.如果价格相同，则 shopj 较小 的排在前面</span></span><br><span class="line">        <span class="keyword">return</span> mov1-&gt;shopId &lt; mov2-&gt;shopId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// * 3.res 中的电影需要按 价格 升序排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mov1-&gt;price &lt; mov2-&gt;price;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; target;</span><br><span class="line">std::<span class="built_in">sort</span>(target.<span class="built_in">begin</span>(), target.<span class="built_in">end</span>(), compShop);</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compShop</span><span class="params">(vector&lt;<span class="type">int</span>&gt; x, vector&lt;<span class="type">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x[<span class="number">1</span>] == y[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// * 2.商店需要按照 价格 升序排序</span></span><br><span class="line"><span class="comment">// * 3.如果价格相同，则 shopi 较小 的商店排在前面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-子串的寻找"><a href="#12-子串的寻找" class="headerlink" title="12. 子串的寻找"></a>12. 子串的寻找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s1 &gt;&gt; s2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() &gt;= s2.<span class="built_in">size</span>())</span><br><span class="line">            cout &lt;&lt; (s1.<span class="built_in">find</span>(s2) != string::npos) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; (s2.<span class="built_in">find</span>(s1) != string::npos) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-得到子串"><a href="#13-得到子串" class="headerlink" title="13. 得到子串"></a>13. 得到子串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1.<span class="built_in">substr</span>(index, num)</span><br><span class="line"><span class="comment">// 从字符串str1的index索引位置开始获取num个字符；</span></span><br><span class="line">str1.<span class="built_in">substr</span>(index)</span><br><span class="line"><span class="comment">// 从字符串str1的index索引位置开始获取，一直获取到末尾的字符；</span></span><br></pre></td></tr></table></figure><h3 id="14-字符串大小写转换"><a href="#14-字符串大小写转换" class="headerlink" title="14. 字符串大小写转换"></a>14. 字符串大小写转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-字符串替换"><a href="#15-字符串替换" class="headerlink" title="15. 字符串替换"></a>15. 字符串替换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//将当前字符串</span></span><br><span class="line"></span><br><span class="line">从pos索引开始的n个字符，替换成字符串s</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">size_t</span> n1, <span class="type">char</span> c)</span></span>; <span class="comment">//将当前字符串从pos索引开始的n个字符，替换成n1个字符c</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="function">string&amp; <span class="title">replace</span><span class="params">(iterator i1, iterator i2, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;<span class="comment">//将当前字符串[i1,i2)区间中的字符串替换为字符串s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello,world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s1.<span class="built_in">size</span>()&lt;&lt;endl;                     <span class="comment">// 结果：12</span></span><br><span class="line">    s1.<span class="built_in">replace</span>(s1.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);           <span class="comment">// 结果：hello,world.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的6表示下标  5表示长度</span></span><br><span class="line">    s1.<span class="built_in">replace</span>(<span class="number">6</span>,<span class="number">5</span>,<span class="string">&quot;girl&quot;</span>);                    <span class="comment">// 结果：hello,girl.</span></span><br><span class="line">    <span class="comment">// s1.begin(),s1.begin()+5 是左闭右开区间</span></span><br><span class="line">    s1.<span class="built_in">replace</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">begin</span>()+<span class="number">5</span>,<span class="string">&quot;boy&quot;</span>); <span class="comment">// 结果：boy,girl.</span></span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-字符串的构造函数"><a href="#16-字符串的构造函数" class="headerlink" title="16. 字符串的构造函数"></a>16. 字符串的构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">string str：生成空字符串</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str)</span>：生成字符串为str的复制品</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, strbegin,strlen)</span>：将字符串str中从下标strbegin开始、长度为strlen的部分作为字符串初值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(cstr, char_len)</span>：以C_string类型cstr的前char_len个字符串作为字符串s的初值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(num ,c)</span>：生成num个c字符的字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, stridx)</span>：将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">eg:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    string str1;</span>               <span class="comment">//生成空字符串</span></span><br><span class="line">    <span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;  <span class="comment">//生成&quot;1234456789&quot;的复制品</span></span><br><span class="line">    <span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;<span class="comment">//结果为&quot;123&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;012345&quot;</span>, <span class="number">5</span>)</span></span>;  <span class="comment">//结果为&quot;01234&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>;       <span class="comment">//结果为&quot;11111&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;      <span class="comment">//结果为&quot;3456789&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="built_in">size</span>()和<span class="built_in">length</span>()：返回string对象的字符个数，他们执行效果相同。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="built_in">max_size</span>()：返回string对象最多包含的字符数，超出会抛出length_error异常</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="built_in">capacity</span>()：重新分配内存之前，string对象能包含的最大字符数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="17-数字与字符串的相互转换"><a href="#17-数字与字符串的相互转换" class="headerlink" title="17. 数字与字符串的相互转换"></a>17. 数字与字符串的相互转换</h3><h4 id="数字to字符串"><a href="#数字to字符串" class="headerlink" title="数字to字符串"></a>数字to字符串</h4><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    string str;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    ss &lt;&lt; x;</span><br><span class="line">    ss &gt;&gt; str;</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 浮点数会附带小数点后六位，不足补零，不推荐浮点数使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    str = <span class="built_in">to_string</span>(x);</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符串to数字"><a href="#字符串to数字" class="headerlink" title="字符串to数字"></a>字符串to数字</h4><h5 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用&lt;string&gt;中的stoi()函数，其中还有对于其他类型的函数，如stod()，stof()等，根据类型选取</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    x = <span class="built_in">stoi</span>(str);</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    string str;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    ss &lt;&lt; str;</span><br><span class="line">    ss &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="18-溢出"><a href="#18-溢出" class="headerlink" title="18. 溢出"></a>18. 溢出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">long</span> <span class="type">long</span> right = <span class="built_in">min</span>(a,b)*(<span class="type">long</span> <span class="type">long</span> )n;</span><br><span class="line"><span class="comment">/// 如果不对n进行强制类型转换，那么溢出。</span></span><br><span class="line"><span class="comment">// 虽然right已经定义了long long，但是在乘法计算时就已经溢出了</span></span><br></pre></td></tr></table></figure><h3 id="19-map遍历"><a href="#19-map遍历" class="headerlink" title="19. map遍历"></a>19. map遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;_map;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">while</span>(iter!=_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; iter-&gt;second&lt;&lt;endl;</span><br><span class="line">    iter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(iter = _map.<span class="built_in">begin</span>(); iter != _map.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于数组和指针的分析</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="Array-type-is-not-assignable"><a href="#Array-type-is-not-assignable" class="headerlink" title="Array type is not assignable"></a>Array type is not assignable</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">  str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, str[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: array type <span class="string">&#x27;char [4]&#x27;</span> is <span class="keyword">not</span> assignable</span><br></pre></td></tr></table></figure><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">4</span>] = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>在变量初始化时，就进行赋值。在长度为4的char数组中，’a’放进str[0]，’b’放进str[1]，’c’放进str[2]，’\0’放进str[3]分别放入a b c 元素</p><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str;</span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>这是声明一个<strong>char型指针变量 str，</strong>然后创建一个字符串常量”abc”，然后char指针 str 指向这个常量的内存，其实你可以试试，你可以<strong>通过str输出这个字符串（可以读），但是不能更改它（不能写）</strong>。因此在C++11里，对类型加了更强的定义，<strong>即指针指向的内容如果不可修改，就建议把该指针确认为const指针类型；</strong>如果不加const标志符，就提示一个警告。</p><h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>这种是有语法错误的，先声明一个char数组str[4]，这时候str[4]有一块内存，而<strong>str作为数组名，相当于一个指针常量</strong>，固定指向str[4]这个数组的第一个元素的地址。<br />而你使用str&#x3D;”abc”，相当于想要给一个指针常量赋值，所以显然是有语法错误的。想想你对一个常量赋值，当然会有错误！！</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>数组名只是代表数组第一个元素的地址的值</strong>，比如数组 int a[10]，a实际上就是 &amp;a[0]，它只是一个值，就像 5 这类东西一样，<strong>是不能作为左值的，不能给它赋值。</strong><br />所谓<strong>指针只是一种保存地址的变量，单独用数组名的时候它只是数组第一个元素的地址的值，<br />并不是保存第一个元素地址的变量</strong>。<br />所以在任何时候都不能把数组名直接放在等号的左边，这个问题跟字符串什么的并没有什么关系。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="字符串常量修改与赋值"><a href="#字符串常量修改与赋值" class="headerlink" title="字符串常量修改与赋值"></a>字符串常量修改与赋值</h3><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>数组c的声明，是将<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>常量“复制”到数组中，复制来的字符串是可以修改的</li><li>指针p的声明，指向的是字符串常量的地址，而常量只读不可修改</li><li>关键：如果直接赋值字符串（<strong>实际上是赋值地址</strong>）时，<strong>会在字符串常量区开辟对应内存存放字符串</strong>，如果赋值给指针p，那么p中的内容就不可修改。因为p是指向常量区的，而<strong>常量区中的内容是不可修改的</strong>。如果是动态分配，在赋值字符串，同理；但是如果使用<code>strcpy</code>，那么就相当于再堆内存中写入对应的<strong>字符串内容，而非直接赋值地址</strong>，那么此时p指向的内容就可以修改。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p, *m;</span><br><span class="line">p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">m = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">p = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* q=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> c[<span class="number">30</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">p[<span class="number">2</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">puts</span>(p);</span><br></pre></td></tr></table></figure></li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>指针p的存储地址为 0x004FFD5C<br />指针q的存储地址为 0x004FFD44<br />你会发现他们地址几乎都在一起，因为他们存储的地方是栈内存<br />要知道<code>p = &quot;hello&quot;</code>;意思是将字符串<code>&quot;hello&quot;</code>的地址存储到p内<br />而p内存储字符串的地址为 0x00667B30<br />q内存储的字符串的地址为 0x00667B30<br />你会发现存储的地址是一样的，说明字符串<code>&quot;hello&quot;</code>的地址放在一个地方，也就是我们说的<strong>字符串常量区，字符串常量区内的元素，只读不可修改</strong>。<br />你们会问，为什么p内的地址为字符串常量的地址呢？<br />首先，<strong>指针p申请动态内存后，p内存储的是申请的内存的起始地址，而之后，p又存储字符串“hello”的地址，所以，最后p内存储的地址为字符串常量“hello”的地址。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span>* p, *m;</span><br><span class="line">p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">m = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//p = &quot;hello&quot;;</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">char</span>* q=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> c[<span class="number">30</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">p[<span class="number">2</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">puts</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家又会问：为什么用<code>strcpy(p, &quot;hello&quot;);</code><br />因为<strong>字符串被复制到堆内存中，而不是访问字符串常量区</strong><br /><strong>指针p首先动态申请内存，这时，指针p的值是申请的内存起始地址，所以strcpy是将字符串复制到申请的内存当中。</strong>所以使用strcpy后，p中的内容是可以修改的。</p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OJ 使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/OJ%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/OJ%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="答案不一致"><a href="#答案不一致" class="headerlink" title="答案不一致"></a>答案不一致</h4><p>如果出现本地IDE和OJ上输入相同，输出不同的情况，考虑是否为系统不一致的情况：</p><ol><li>是否为IO的处理不同。当输入整数后，为了吸收换行符，建议统一使用<code>**cin &gt;&gt; ws**</code> 进行处理</li><li>如果排除掉IO的情况后，可以考虑结束符号的不同。例如，在Windows中，char数组的结束符号为<code>**&#39;\0&#39;**</code>；而在我调试代码时，发现在OJ上，结束符号为<code>**&#39;\r&#39; **</code>。因此需要特别小心</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第五课 数组与指针</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%BA%94%E8%AF%BE%20%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%BA%94%E8%AF%BE%20%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.yuque.com/austyn-c3emm/yxffx0/ob20zu">关于数组和指针的分析</a></p><blockquote><p>指明了类型，就指明了操作</p></blockquote><p>特征：</p><ul><li>相同类型</li><li>连续存储</li></ul><p>可以按下标访问，也可以按地址访问。<strong>C++是基于实现的</strong><br />C++中的二维数组是复合类型，没有Array。<br />数据类型决定范围和取值方式，<strong>什么样的类型定义了什么样的访问方式</strong><br /><code>int len = sizeof(arr)/sizeof(arr[0])</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">f</span>(a)  <span class="comment">//在参数传递时，发生了变化，变成了表达式，由一个数组变成了相关的指针</span></span><br><span class="line"><span class="comment">// a是数组类型，只不过进行了隐式类型转换</span></span><br><span class="line">    <span class="comment">// 所有的指针的sizeof(*p) 都是一样的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(a[<span class="number">0</span>]);i++)&#123;</span><br><span class="line">        <span class="comment">// 所以此时不能输出a中的每一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 因此，元素个数需要通过参数显式给出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++是允许数组下标越界的，因为越界是<strong>有用的</strong>前提是空间是合理的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(<span class="type">char</span>[] a )</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (a[i+ <span class="number">1</span>] !=<span class="string">&#x27;/0&#x27;</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665470118492-ef584ee7-e92f-400c-966e-4a0dfbbc1e76.png" alt="image.png">** <strong><br />所以</strong>输出s2时，会一直输出下去**，直到刚好碰到<code>&#39;\0&#39;</code><br />没有初始化的空间全部默认为 0xcc，代表中文的烫<br />利用malloc时不初始化，空间会默认为0xcd，代表中文的屯。【debug版本中打开&#x2F;GZ开关，方便找到潜在的错误 &#x3D; 》现在使用&#x2F;RTC1】<br />C++中的变量是不会自己初始化的<br />mallopt指定自己配置的空间是什么【写在代码中的】<br />valgrind设置栈、堆里面的填充【不修改代码】</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针必须初始化，防止调用垃圾地址并修改了其中的内容<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665470614133-7c6a4d2b-0068-4eb5-ae6a-7e2d2c25c935.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665470621676-09712e81-2dda-48c5-b4ba-919448538fb2.png" alt="image.png"></p><h3 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h3><p><code>void *v</code> 则 <code>*v</code>是不被运行的。所以<code>**v**</code><strong>可以作为任何类型指针的公共接口，只具有记录地址的作用，是可以被信任的。任何指针都可以赋值给</strong><code>**void ***</code><strong>，但void * 不能赋值给其他指针</strong><br />清零<br />int a[100]  全部赋值为0</p><ol><li><code>for</code>循环</li><li><code>memset函数(起始地址，大小)</code> 则起始地址必须为<code>**void ***</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">memset</span><span class="params">(<span class="type">void</span> *p,<span class="type">int</span>  n)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *q = (<span class="type">char</span> *)p; <span class="comment">// 进行强制类型转换为char *，一个一个字节的删除即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    *(q+i) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665471919019-8d7f5fe9-3fe5-40e7-874b-6e48c8a30770.png" alt="image.png"><br><strong>a 是一个常量指针，数组名是常量指针</strong></p><ol><li><strong>通过数组下标访问</strong></li><li><strong>通过指针访问</strong></li><li><strong>通过数组名访问</strong></li></ol><p>动态数组<br /><code>int *p =(int*) malloc (……)</code></p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>通过一维数组不断复合，依然是一段连续的数据。<br />参数传递：缺少第一维，因为对应的就是<strong>指针</strong>，指向后面的维度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>]; <span class="comment">// </span></span><br><span class="line"><span class="keyword">using</span> T = <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] &lt;=&gt; T a[<span class="number">3</span>]; 相当于额外定义了基类型</span><br></pre></td></tr></table></figure><p>升维操作：动态多维数组需要借助一维数组来实现，利用升维操作 </p><h4 id="降维操作p-i"><a href="#降维操作p-i" class="headerlink" title="降维操作p[i]"></a>降维操作<code>p[i]</code></h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665581024915-f41d6b67-1dab-441b-844b-52c88e4c310b.png" alt="image.png"></p><h4 id="降维操作q-i-j"><a href="#降维操作q-i-j" class="headerlink" title="降维操作q[i][j]"></a>降维操作<code>q[i][j]</code></h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665581379222-762137c7-14c5-486f-b348-21e20686a00a.png" alt="image.png"><br>为了能通过<code>q[i][j]</code>的形式表示，则需要<code>q</code>指针指向的是一个小方块，而不是一个具体从存储单元。在这个小方块中，包含若干个的最小存储单元，从而通过<code>j</code>这一坐标找到最小的存储单元<br /><code>**p+11**</code><strong>其实是越界了，方便用数组的形式访问多维数组</strong></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665581592478-98bde056-546e-4210-a1db-9b9f172eb4da.png" alt="image.png"></p><h3 id="数组升维降维"><a href="#数组升维降维" class="headerlink" title="数组升维降维"></a>数组升维降维</h3><h4 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665473312121-9afd89d3-dc73-4752-a275-03d745a1eece.png" alt="image.png"></p><h4 id="升维"><a href="#升维" class="headerlink" title="升维"></a>升维</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665473730499-f85ba331-6cbb-4a7f-bef5-34ec0b9b8c30.png" alt="image.png"></p><h4 id="ragged-array"><a href="#ragged-array" class="headerlink" title="ragged array"></a>ragged array</h4><p>java 中的二维数组不是规整的，可能是锯齿状的，不对等的<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665472501018-b591c0b0-b173-4784-90f8-bedc5fdba0cf.png" alt="image.png"></p><h3 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = mall</span><br></pre></td></tr></table></figure><p>在使用new时，会<strong>逐个调用constructor</strong>，从而实现强制类型转换。OO使得数据进入时能进行部分操作<br />new malloc 和inline一样，可能会申请不成功，所以需要<strong>有效性判定</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665474543745-69965375-c6bd-413e-976a-18b57777cde8.png" alt="image.png"></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li>可以预见：new可能会失败</li><li>无法避免</li></ol><p>可以由系统处理，也可以自定义处理。为了allocate成功，可以自己选择释放一些特定内存，要么停掉，要么交给系统处理，要么自主修改环境</p><h3 id="归还"><a href="#归还" class="headerlink" title="归还"></a>归还</h3><p>防止内存泄漏</p><ul><li>操作符 <code>new</code>、<code>delete</code></li><li>函数 <code>malloc</code>、<code>free</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  *p1  =<span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">8</span>);</span><br><span class="line"><span class="type">int</span>  *p2 = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span>  *q  = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span>  *q2 = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">8</span>);</span><br></pre></td></tr></table></figure>int *q &#x3D; new int[8]<br />delete q 只调用一个析构函数<br />delete [] q  逐个调用析构函数<br />free(q) <br />如何知道有8个？</li></ul><ol><li>符号表：耗时+会导致表的大小未定，空间不确定</li><li>用空间换取时间：在分配内存时，额外用一个空间<code>**cookie**</code>，<code>cookie</code>中存储块的大小</li></ol><p>申请的指针不要随意改变，否则容易归还失败。因此使用时要用<code>int *p1 = p;</code> </p><h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><p>compiler会自动调用<code>destructor</code>，确保对象被释放。生命周期结束的时候会自动调用delete，利用析构函数的自动调用防止内存泄漏，确保资源的初始化。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074024946-ffa46879-1310-4887-b37d-4909916b340a.png" alt="image.png"><br>unique_ptr shared _ptr  解决资源共享或者独享问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span>  i;</span><br><span class="line">    <span class="type">int</span>  *p;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="built_in">A</span>()&#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A a;<br />A b &#x3D;a;<br />会导致悬挂指针<code>idle point</code>，a 和 b 的生命周期结束不一致。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Sturct"><a href="#Sturct" class="headerlink" title="Sturct"></a>Sturct</h3><p>定义数据的顺序会影响到内存的占用，<strong>会数据对齐</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074365737-1888f32f-4ded-4835-bdcb-21ff0757e473.png" alt="image.png"></p><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074423419-fb8927df-deaa-42b3-b5ae-2604197c1924.png" alt="image.png"><br><strong>B的存储空间是最大占有的内存</strong>，所有的域代表一个公共的空间，<strong>里面的内容共享一块存储空间</strong>。<br />对于<code>struct</code>，</p><h4 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h4><p>表示方法1：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074582185-d728c632-d5ba-4306-ac70-9ac07edefba7.png" alt="image.png"><br>表示方法2：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074654444-cd439362-d28e-4643-a723-db033c24cc2d.png" alt="image.png"><br>两种访问方式：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666074727649-7e1b8cd2-af2f-4f95-917d-a453a7bc54c5.png" alt="image.png"></p><h4 id="数组-—-多态性"><a href="#数组-—-多态性" class="headerlink" title="数组 — 多态性"></a>数组 — 多态性</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666075224937-9b6c1cc8-bcb7-47f6-b725-39a5908b45f3.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666075202245-1d61c00f-e253-41a1-b4cf-f65e5e719670.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第六课 指针</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%85%AD%E8%AF%BE%20%E6%8C%87%E9%92%88/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%85%AD%E8%AF%BE%20%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>作用：</p><ol><li>管理地址信息</li><li>读写信息</li><li>调用代码</li></ol><h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>指向常量的指针</p><ol><li>常量指针可以指向变量：从而消除函数副作用<strong>只有读的能力，没有写的能力</strong>。既保护了数据，也提高了效率</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666075777093-1be322c6-8b15-4de7-8581-bdbd851e85eb.png" alt="image.png"></p><ol start="2"><li>变量指针不可以指向常量：因为担心变量指针改变常量</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666075677750-f2f8eac3-f8fe-4a2a-a24e-37e0dd786bda.png" alt="image.png">提供一个权利，相信变量指针不会改变常量<br /><strong>Use const whenever possible</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666076607331-77fe9ca5-7db6-42b8-af95-1e1d6adc6499.png" alt="image.png"><br>会把const变量转换为字面常量。所以c直接代替为128</p><h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666076675033-8b943735-7813-49fd-a483-382662982f12.png" alt="image.png"></p><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666076762509-b550ee49-3eae-45fc-9ff2-f6db42de3935.png" alt="image.png"></p><p>异步程序的调用 – 通过主程序的返回值确定<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666077003993-4a6a14e3-b5d3-490d-ac78-e57ab4b65886.png" alt="image.png"></p><h3 id="指针与结构"><a href="#指针与结构" class="headerlink" title="指针与结构"></a>指针与结构</h3><p><strong>class不写访问控制，对应的是private；struct默认的是public</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666077598289-ae50a974-adfc-4e7b-8562-a5b88cc271f9.png" alt="image.png"></p><h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><h4 id="指针作为行参"><a href="#指针作为行参" class="headerlink" title="指针作为行参"></a>指针作为行参</h4><ul><li>提高传输效率</li><li>函数副作用</li><li>常量指针</li></ul><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>作用：</p><ol><li>写框架，实现剥离</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666079041998-07398089-77d2-4d40-8acb-da84230a4cf3.png" alt="image.png"></p><ol start="2"><li>泛型</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666078881715-246db21d-3096-4f77-91a4-8d180b80d648.png" alt="image.png"><br><code>callback() function</code><br />改善：</p><ul><li>用<code>template</code></li><li>用<code>lambda function</code></li></ul><h3 id="多级指针？？"><a href="#多级指针？？" class="headerlink" title="多级指针？？"></a>多级指针？？</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666079167053-b70934ad-5d35-42ca-b080-be39cc5d29cf.png" alt="image.png"></p><h3 id="引用？？"><a href="#引用？？" class="headerlink" title="引用？？"></a>引用？？</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666079216734-616c94d5-1c7a-49e9-8f17-18cc6ba0ee54.png" alt="image.png"></p><ol><li>不能返回局部变量、全局变量，只能返回调用者有关的</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机考</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E6%9C%BA%E8%80%83/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E6%9C%BA%E8%80%83/</url>
      
        <content type="html"><![CDATA[<ol><li>小心使用指针</li></ol><p>如果直接传入字符串，则选择接收的是其内容，而不要用指针的方式接收，因为传入参数后，该地址就被自动释放，并被后面的字符串常量覆盖，造成错误。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666679605225-6050dc2e-8714-48f8-839b-0f7a2684eb73.png" alt="image.png"></p><ol start="2"><li>要放轻松，尽力就好，重点还是在笔试</li><li><strong>一定要看清题意，最好将对应的步骤描述复制到对应的函数中去</strong></li><li>在面对长段文字时，首先要从最简单的几个入手，获得一定的分数，再去做更复杂的题目</li><li>如果发现能对几个，但是对的不多，且不是算法题目，那么就要<strong>多考虑细节</strong>，要<strong>重新回到题干上进行分析</strong></li><li><strong>按照步骤读题干，同时关注已给出的加粗&#x2F;标红部分</strong></li><li><strong>多造用例，抓捕一些脑海中一闪而过的可能的错误用例，不要小看每一个特殊用例，不要觉得这个肯定不会涉及，如果有想到的，就一定要去修复，可能会有额外收获</strong></li><li>注意输出的格式是否正确。有时思路没问题，但是<strong>输出格式有误</strong>，例如：<strong>大小写输出、空格数量输出</strong>等情况</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七课 OOP</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20OOP/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20OOP/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u014391177/article/details/82228662">C++拷贝构造函数、构造函数和析构函数</a></p><ol><li>encapsulation<ol><li>减少类之间的耦合</li><li>类内部的结构可以自由的进行修改</li><li>对成员进行控制</li><li>对代码的理解性更好</li></ol></li><li>information hidding：不需要知道如何初始化，只需要使用提供的接口</li><li>Cfront 第一个C++的编译器，转为C</li></ol><ul><li>基于对象：没有继承</li><li>面向对象：封装、继承、多态</li></ul><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>开发效率、软件外部质量、软件内部质量都得到明显提升</p><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul><li>成员变量</li><li>成员函数</li><li>头文件、源文件：C++是一个个编译单元进行编译，所以需要提前知道其他编译单元的相关信息（存储在头文件中），只需要知道声明，不需要知道具体定义，减少编译复杂度</li></ul><p>将方法放在头文件中时，会将该方法当作<code>inline</code>函数。<br />主调函数运行时，如果有其他函数，会先运行其他函数，在返回主调函数。如果其他函数很短，则会在调用上消耗太多时间，所以需要变为<strong>内联函数–直接用函数体代替函数调用，代码展开，提高性能。</strong>但是，如果函数体很大时，会把代码变得很长。所以，<strong>一般的</strong><code>**set**</code>**函数 **<code>**get**</code><strong>函数、代码十行之内、没有</strong><code>**for**</code><strong>循环、没有</strong><code>**switch**</code><strong>语句声明成内联函数</strong></p><hr><p>为了优化编译，使用其他编译单元时，先不引入进来，而是在链接过程中，保证有定义即可。所以需要<strong>先声明，再使用</strong>，告诉本编译单元，该函数是合法的，所以需要<strong>头文件</strong>。</p><ol><li>本地单元进行编译时，头文件和源文件是一致的，肯定是合法的，减少了编译时的依赖关系，只需要和头文件建立依赖关系就可以了。</li><li>减少编译时引入的内容</li><li>把定义和声明放入一块，是为了支持<code>inline</code>：<strong>直接替换函数调用</strong>。如果头文件中没有具体声明，则无法使用<code>inline</code>。所以，<code>inline</code>要求<strong>头文件中必须要有声明</strong></li><li><strong>所以</strong><code>**inline**</code><strong>过多，会使编译单元过于庞大，不适合写在头文件中，而是写在源文件中</strong></li></ol><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>如果提供了有参构造函数，则编译系统不再提供默认构造函数</li><li>当类中未提供构造函数时，由编译系统提供</li><li>如果没有指定c++默认初始化，则各种变量都会有<strong>不确定的值</strong></li><li>成员变量如果是成员对象，则总是会初始化的，需要为成员对象设置构造函数</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666852754296-ad99d7fb-af8e-4267-88d6-ec874ca6cfbb.png" alt="image.png"></p><ul><li>全局变量和静态变量，未初始化，默认为0</li><li>局部变量、成员变量，未初始化，默认为不确定的值</li><li>编译系统提供的默认构造函数不会对成员变量进行处理，主要功能是<strong>完成对象的初始化，创建标识符，开辟内存空间</strong>，最后再根据传入的参数或者默认值进行对数据的处理。</li><li>构造函数可定义为<code>private</code>，避免在其他代码中创建该对象，所以<strong>只能通过类内部的方法进行创建</strong>，而类内部的方法是我自己写的，因此<strong>可以接管对象的创建</strong>，例如保证单例，或者保证只有十个对象创建</li></ul><h5 id="数组构造"><a href="#数组构造" class="headerlink" title="数组构造"></a>数组构造</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666853395899-ddd69b85-d7cd-4245-98cb-f1348a7c37f2.png" alt="image.png"></p><h4 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h4><p>在冒号和花括号之间的代码部分称为构造函数的初始值列表，<strong>它的作用是给创建的对象的某些成员赋初值</strong>。这种是在构建对象的时候的初始化，是在对象创建成功之前完成的，和在函数体内赋值是不一样的，<strong>函数体内赋值是你的对象成员都已经创建好后对成员进行的赋值。</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666854123003-fdd90dc6-e5eb-48e5-89e6-da3c44f41345.png" alt="image.png"></p><ol><li><code>static const</code>类的常量</li><li>引用类型必须初始化，不能重新赋值</li><li><strong>构造函数内赋值，实际上是先初始化为默认值，再赋值，相当于两次赋值</strong></li><li>如果使用初始化表，则是在初始化的同时进行赋值，效率更高</li><li>声明处进行初始化最为方便</li><li>在构造函数内进行赋值，成员变量已经初始化了，这次是<strong>二次赋值</strong>，效率上更低</li></ol><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> t) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hour = t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1990</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">    : _year(year), _month(month), _day(day), <span class="built_in">t</span>(<span class="number">10</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year = <span class="number">1990</span>;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">    Time t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>对于<code>const</code>和引用类型，必须要进行初始化，所以他们<strong>必须在初始化列表中进行初始化</strong>。</li><li>当类类型成员有缺省（默认）的构造函数时，在创建对象的时候系统会默认调用，因为不用传参。当你的构造函数不是缺省的，如果不在初始化列表中进行调用构造函数，系统就无法知道怎么调用t的构造函数，那么就无法创建t了。</li></ol><p>如上代码中，需要在参数列表中调用t的构造函数才不会出错</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666854897871-99657b81-0c7f-48ef-a2e0-e0176f35ddaa.png" alt="image.png"><br>数据太多，可以在声明的同时进行初始化。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li>在上面的初始列表中，每个成员只能出现一次，因为一个变量多次初始化是无意义的。</li><li>初始化列表的顺序并不限定初始化的执行顺序。<strong>成员的初始化顺序是与类中定义的顺序保持一致。</strong>最好让构造函数初始值的顺序与成员声明的顺序保持一致。</li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p><strong>程序员负责资源的申请和释放</strong><br />类的析构函数，它是类的一个成员函数，名字由波浪号加类名构成，是执行与构造函数相反的操作：释放对象使用的资源，并销毁非static成员。<br />同样的，我们来看看析构函数的几个特点：</p><ol><li>函数名是在类名前加上~，无参数且无返回值。</li><li>一个类只能有且有一个析构函数，如果没有显式的定义，系统会生成一个缺省的析构函数（合成析构函数）。</li><li>析构函数不能重载。<strong>每有一次构造函数的调用就会有一次析构函数的调用。</strong></li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666855022119-3cdc0f73-c223-45d6-96a5-bb88dfc0c1f7.png" alt="image.png"></p><ol><li>对象离开作用域</li><li>使用<code>delete</code>方法调用</li><li>作用：把对象在运行中获得的额外资源进行释放</li></ol><h4 id="声明为private"><a href="#声明为private" class="headerlink" title="声明为private"></a>声明为<code>private</code></h4><blockquote><ol><li>禁止用户对此类型的变量进行定义，即<strong>禁止在栈内存空间内创建此类型的对象。</strong>要创建对象，只能用 <code>new</code> 在堆上进行。 </li><li>禁止用户在程序中使用 <code>delete</code> 删除此类型对象。对象的删除只能在类内实现，也就是说只**有类的实现者才有可能实现对对象的 <strong><code>**delete**</code>，用户不能随便删除对象。</strong>如果用户想删除对象的话，只能按照类的实现者提供的方法进行 **</li><li>如果一个类不打算作为基类，通常采用的方案就是将其析构函数声明为<code>private</code>，限制栈对象，却不限制继承</li></ol></blockquote><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666855595621-be2da256-d2c5-4676-bf14-af1ad5626581.png" alt="image.png"><br>系统无法调用析构函数，因为是自动消亡的，内存分配在栈中，<strong>离开作用域就会自动消亡</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666855682941-ad51ba16-2810-465e-9b83-fadc93e2ef83.png" alt="image.png"><br><strong>通过将对象的析构函数定义为</strong><code>**private**</code><strong>，强制在堆上分配内存</strong>，场景：栈的内存有限，对象的内存很大。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666855753254-11b614b3-9ee7-4179-ae25-edecafd4b756.png" alt="image.png"><br>这种方法也能够将<code>p</code>指针重新定义为空指针，更好</p><h4 id="栈对象的生命"><a href="#栈对象的生命" class="headerlink" title="栈对象的生命"></a>栈对象的生命</h4><ol><li>会移动栈顶指针以“挪出”适当大小的空间</li><li>在这个空间上直接调用对应的构造函数以形成一个栈对象</li><li>当函数返回时，会调用其析构函数释放这个对象</li><li>调整栈顶指针收回那块栈内存。</li></ol><h4 id="GC-垃圾回收"><a href="#GC-垃圾回收" class="headerlink" title="GC 垃圾回收"></a>GC 垃圾回收</h4><ol><li>存在效率障碍，发生时间不确定</li><li>存在不能使用GC的场合</li><li>只能回收内存，不能回收文件操作的句柄等 <code>finalize</code></li><li>不能由程序员自己控制</li></ol><h4 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII  Resource Acquisition Is Initialization"></a>RAII  Resource Acquisition Is Initialization</h4><blockquote><p>资源获取就是初始化</p></blockquote><ol><li>什么时候获取什么时候释放都是确定的</li><li>对象获得的资源都是要在析构函数中释放的</li><li>栈上的内存资源自动释放，堆上的内存资源需要通过析构函数释放</li></ol><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li>一个对象<strong>以值传递的方式传入函数</strong></li><li>一个对象<strong>以值传递的方式从函数中返回</strong></li><li>一个对象<strong>需要通过另外一个对象进行初始化</strong></li></ol><ul><li>创建对象时，用一个同类的对象对其初始化</li><li>自动调用：<code>Test(Test &amp;c_t)是自定义的拷贝构造函数，**拷贝构造函数的名称必须与类名称一致**，函数的形式参数是**本类型的一个引用变量,且必须是引用**</code></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666856126500-f78dbc74-bfbc-495a-af46-8fb9045d3e4c.png" alt="image.png"></p><ol><li>使用引用：<strong>如果不写引用，则传参本身就会引发拷贝构造函数</strong>，导致递归</li><li>使用<code>const</code>：防止拷贝时值被修改</li><li>默认拷贝构造函数：<ol><li>逐个成员初始化</li><li>对于对象成员，该函数是递归的</li></ol></li></ol><p><strong>需要深拷贝时，要自己提供拷贝构造函数</strong></p><h4 id="浅拷贝-深拷贝"><a href="#浅拷贝-深拷贝" class="headerlink" title="浅拷贝 深拷贝"></a>浅拷贝 深拷贝</h4><ul><li>如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的位拷贝。位拷贝又称浅拷贝，后面将进行说明。</li><li>自定义拷贝构造函数是一种良好的编程风格，它可以阻止编译器形成默认的拷贝构造函数，提高源码效率。</li><li>浅拷贝：在某些状况下，类内成员变量需要动态开辟堆内存，如果实行浅拷贝，就是<strong>把对象里的值完全复制给另一个对象</strong></li></ul><p>深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，<strong>资源重新分配</strong>，这个过程就是<strong>深拷贝</strong>，反之，<strong>没有重新分配资源，就是浅拷贝。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CA</span></span><br><span class="line">&#123;</span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　<span class="built_in">CA</span>(<span class="type">int</span> b,<span class="type">char</span>* cstr)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　a=b;</span><br><span class="line">　　　str=<span class="keyword">new</span> <span class="type">char</span>[b];</span><br><span class="line">　　　<span class="built_in">strcpy</span>(str,cstr);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">CA</span>(<span class="type">const</span> CA&amp; C)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　a=C.a;</span><br><span class="line">　　　str=<span class="keyword">new</span> <span class="type">char</span>[a]; <span class="comment">//深拷贝</span></span><br><span class="line">　　　<span class="keyword">if</span>(str!=<span class="number">0</span>)</span><br><span class="line">　　　　<span class="built_in">strcpy</span>(str,C.str);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">　　&#125;</span><br><span class="line">　　~<span class="built_in">CA</span>()</span><br><span class="line">　　&#123;</span><br><span class="line">　　　<span class="keyword">delete</span> str;</span><br><span class="line">　　&#125;</span><br><span class="line">　<span class="keyword">private</span>:</span><br><span class="line">　　<span class="type">int</span> a;</span><br><span class="line">　　<span class="type">char</span> *str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="function">CA <span class="title">A</span><span class="params">(<span class="number">10</span>,<span class="string">&quot;Hello!&quot;</span>)</span></span>;</span><br><span class="line">　CA B=A;</span><br><span class="line">　B.<span class="built_in">Show</span>();</span><br><span class="line">　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="浅拷贝危害"><a href="#浅拷贝危害" class="headerlink" title="浅拷贝危害"></a>浅拷贝危害</h5><p>如A&#x3D;B。这时，如果<strong>B中有一个成员变量指针已经申请了内存</strong>，那A中的那个成员变<strong>量也指向同一块内存</strong>。这就出现了问题：当B把内存释放了（如：析构），这时<strong>A内的指针就是野指针了</strong>，出现运行错误。<br /><strong>浅拷贝资源后在释放资源的时候会产生资源归属不清的情况导致程序运行出错。</strong></p><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p><strong>程序员如果不会去做一件事，则编译器会接管，但如果程序员接管了，则编译器什么都不做</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666856786049-79893964-d3f9-48a0-8aa1-644089f67d07.png" alt="image.png"></p><h4 id="易错"><a href="#易错" class="headerlink" title="易错"></a>易错</h4><p><strong>显式地定义了析构函数的情况下，应该也把拷贝构造函数和赋值操作显式定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year=<span class="number">1990</span>,<span class="type">int</span> month=<span class="number">1</span>,<span class="type">int</span> day=<span class="number">1</span>)</span><br><span class="line">        : _year(year),_month(month),  _day(day)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Date</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year=<span class="number">1990</span>;  </span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员中有动态开辟的指针成员，在析构函数中对它进行了delete，如果不显式的定义拷贝构造函数，当你这样：Date d2（d1）来创建d2，我们都知道默认的拷贝构造函数是浅拷贝，那么这么做的结果就会是d2的成员p和d1的p是指向同一块空间的，那么<strong>调用析构函数的时候回导致用一块空间被释放两次</strong>，程序会崩溃的哦！</p><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p><code>A&amp;&amp;</code>右值引用<br />左值：赋值操作符左边的值。是可以赋值的，通常是一个变量<br />右值：赋值操作符右边的值。是一个值，通常是一个常数、表达式、函数调用</p><ul><li>不能把右值绑定在非<code>const</code>的引用上</li><li>临时变量在再次赋值时可能已经被销毁了</li><li>右值只能绑定在<strong>常量引用</strong>上 <code>const int ＆z = 5</code></li><li>右值通常不能修改</li><li>右值引用可以绑定在右值引用上</li></ul><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>使用<code>swap</code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667283981580-614f64e6-dbb8-4c2f-8ebb-b76bc6905b3e.png" alt="image.png"><br>缺点：总是需要不断拷贝</p><ul><li>移动构造：<strong>把移动完的指针置为</strong><code>**Null**</code><strong>，防止二次释放</strong></li><li>右值绑定在右值引用上时，则<strong>右值可以修改了</strong>，因为获得了其对应的内存</li><li><strong>右值引用是为了提高效率</strong></li><li>没有定义拷贝构造、拷贝赋值、析构函数，则会提供移动构造函数：移动构造是为了降低拷贝的消耗，一旦定义了拷贝构造，则编译器不再提供默认</li><li>定义了析构函数，是对申请资源进行释放，额外的资源需要如何拷贝、如何移动，编译器不知道，所以不会提供移动构造</li></ul><h3 id="类型的匹配顺序"><a href="#类型的匹配顺序" class="headerlink" title="类型的匹配顺序"></a>类型的匹配顺序</h3><p>优先级：<strong>不需要进行数据转换的优先</strong></p><ol><li>如果既有移动构造又有拷贝构造：<ol><li>普通变量：调用拷贝</li><li>右值（临时变量）：调用移动</li></ol></li><li>临时变量的值不能绑定到左值上</li><li>临时变量+<code>const</code>，可以绑定到</li><li>拷贝</li></ol><h2 id="五三原则"><a href="#五三原则" class="headerlink" title="五三原则"></a>五三原则</h2><p><strong>在c++ 中，当我们定义一个类时，我们显式或隐式地定义了此类型的对象在拷贝、赋值和销毁时做什么？</strong><br />一个类通过定义三种特殊成员成员函数来控制这些操作：拷贝构造函数、拷贝赋值函数、析构函数。<br />什么是三法则<br />C++三法则：如果需要析构函数，则一定需要拷贝构造函数和拷贝赋值操作符。<br />如何理解这句话，通常，若一个类需要析构函数，则代表其合成的析构函数不足以释放类所拥有的资源，其中最典型的就是指针成员。<br />所以，我们需要自己写析构函数来释放给指针所分配的内存来防止内存泄露。<br />那么为什么说“一定需要拷贝构造函数和赋值操作符”呢？<br />原因还是这样：类中出现了指针类型的成员。有指针类型的成员，我们必须防止浅拷贝问题，所以，一定需要拷贝构造函数和赋值操作符，这两个函数是防止浅拷贝问题所必须的。<br />什么是五法则<br />在较新的 C++11 标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“C++五法则”；<br />也就是说，“三法则”是针对较旧的 C++89 标准说的，“五法则”是针对较新的 C++11 标准说的；为了统一称呼，后来人们干把它叫做“C++ 三&#x2F;五法则”；<br /><strong>因此，如果自定义了拷贝构造函数&#x2F;拷贝赋值&#x2F;析构函数，则不会提供默认的移动构造函数&#x2F;移动赋值函数</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引用、取地址符、指针</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E3%80%81%E6%8C%87%E9%92%88/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E3%80%81%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>n 是m的一个引用（reference），m 是被引用物（referent）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> &amp;n = m;</span><br></pre></td></tr></table></figure><p><strong>n 相当于 m 的别名</strong>（绰号），<strong>对 n 的任何操作就是对m的操作</strong>。<br />所以 n 既不是m的拷贝，也不是指向 m 的指针，其实<strong>n就是 m 它自己</strong>。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol><li>引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）</li><li>不能有NULL引用，引用必须与合法的存储单元相关联（指针则可以是NULL）</li><li>一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）</li></ol><h3 id="取地址符"><a href="#取地址符" class="headerlink" title="取地址符"></a>取地址符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> &amp;y = x;</span><br><span class="line"><span class="type">int</span> *p = &amp;x;</span><br><span class="line">cout &lt;&lt; y &lt;&lt; endl; <span class="comment">// 100</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl; <span class="comment">// 0x7ffe4c99cdfc</span></span><br><span class="line">cout &lt;&lt; &amp;y &lt;&lt; endl; <span class="comment">// 0x7ffe4c99cdfc</span></span><br></pre></td></tr></table></figure><ul><li><strong>&amp;(引用)</strong>&#x3D;&#x3D;&gt;用来传值，出现在变量声明语句中<strong>位于变量左边时,表示声明的是引用。</strong></li><li><strong>&amp;(取地址运算符)</strong>&#x3D;&#x3D;&gt;用来获取首地址，在给变量赋初值时<strong>出现在等号右边</strong>或在<strong>执行语句中作为一元运算符</strong>出现时表示<strong>取对象的地址</strong>。</li></ul><h4 id="和引用的区别"><a href="#和引用的区别" class="headerlink" title="和引用的区别"></a>和引用的区别</h4><h4 id="实例如下：1）引用在赋值-x3D-的左边，而取地址在赋值的右边，比如"><a href="#实例如下：1）引用在赋值-x3D-的左边，而取地址在赋值的右边，比如" class="headerlink" title="实例如下：1）引用在赋值&#x3D;的左边，而取地址在赋值的右边，比如"></a>实例如下：1）引用在赋值&#x3D;的左边，而取地址在赋值的右边，比如</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>；</span><br><span class="line"><span class="type">int</span> &amp;b=a；        <span class="comment">//引用</span></span><br><span class="line"><span class="type">int</span> *p=&amp;a;        <span class="comment">//取地址</span></span><br></pre></td></tr></table></figure><p>  2）和类型在一起的是引用，和变量在一起的是取址。 举例同样如上，还有下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;  <span class="comment">//引用</span></span><br></pre></td></tr></table></figure><p>3）对于vector，上面2条同样适合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;  <span class="comment">//initialize vec1: 10 elements, every element&#x27;s value is 1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; &amp;vec2 = vec1; <span class="comment">// vec2 is  reference to vec1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; *vec3 = &amp;vec2; <span class="comment">//vec3 is addresss of vec1 and vec2</span></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="每一种编程语言都使用指针。C-将指针暴露给了用户-程序员-，而Java和C-等语言则将指针隐藏起来了。"><a href="#每一种编程语言都使用指针。C-将指针暴露给了用户-程序员-，而Java和C-等语言则将指针隐藏起来了。" class="headerlink" title="每一种编程语言都使用指针。C++将指针暴露给了用户(程序员)，而Java和C#等语言则将指针隐藏起来了。"></a>每一种编程语言都使用指针。C++将指针暴露给了用户(程序员)，而Java和C#等语言则将指针隐藏起来了。</h4><p>“Everything uses pointers. C++ just exposes them rather than hiding them,”<br />It’s easier to give someone an address to your home than to give a copy of your home to everyone.</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>指针能够有效的表示数据结构；</li><li>能<strong>动态分配内存</strong>，实现内存的自由管理；</li><li>能较方便的<strong>使用字符串</strong>；</li><li>便捷高效地使用数组</li><li><strong>指针直接与数据的储存地址有关</strong>，比如：<strong>值传递不如地址传递高效</strong>，因为值传递先从实参的地址中取出值，再赋值给形参代入函数计算；而指针则把形参的地址直接指向实参地址，使用时直接取出数据，效率提高，特别在频繁赋值等情况下（注意：形参的改变会影响实参的值！）</li></ul><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><p>本质：引用是别名，指针是地址，具体的：</p><ol><li>从现象上看，<strong>指针在运行时可以改变其所指向的值</strong>，而<strong>引用一旦和某个对象绑定后就不再改变</strong>。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变。</li><li>从内存分配上看，<strong>程序为指针变量分配内存区域，而不为引用分配内存区域</strong>，因为引用声明时必须初始化，从而指向一个已经存在的对象。引用不能指向空值。</li></ol><p>注：标准没有规定引用要不要占用内存，也没有规定引用具体要怎么实现，具体随编译器 <a href="http://bbs.csdn.net/topics/320095541">http://bbs.csdn.net/topics/320095541</a></p><ol start="3"><li>从编译上看，程序在编译时分别将指针和引用添加到<strong>符号表</strong>上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而<strong>引用</strong>在符号表上对应的地址值为<strong>引用对象的地址值</strong>。符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。这是使用指针不安全而使用引用安全的主要原因。从某种意义上来说<strong>引用可以被认为是不能改变的指针</strong>。</li><li><strong>不存在指向空值的引用</strong>这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。</li><li>理论上，对于指针的级数没有限制，但是引用只能是一级。如下：<br />int** p1;         &#x2F;&#x2F; 合法。指向指针的指针<br />int*&amp; p2;         &#x2F;&#x2F; 合法。指向指针的引用<br />int&amp;* p3;         &#x2F;&#x2F; 非法。指向引用的指针是非法的<br />int&amp;&amp; p4;         &#x2F;&#x2F; 非法。指向引用的引用是非法的<br />注意上述读法是<strong>从左到右</strong>。 </li><li>引用的大小是所指向的变量的大小，因为引用只是一个别名而已；<strong>指针是指针本身的大小，4个字节</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Map的使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Map%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Map%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol><li>可以根据目标键值对位于 map 容器中的位置，实现删除该键值对的目的。erase() 方法的语法格式如下：</li></ol><p><strong>&#x2F;&#x2F;删除 map 容器中指定位置的键值对<br />iterator erase (const_iterator position);</strong><br />其中，position 为迭代器，指向要删除的键值对。同时该<strong>方法会返回一个 iterator 迭代器，其指向的是删除键值对之后的那个键值对。</strong><br />注意，如果删除的键值对位于 map 容器中最后的位置，则该方法返回的迭代器指向的是最后一个键值对之后的位置（等同于 end() 成员方法返回的迭代器）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除 map 容器中指定位置的键值对</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="comment">//删除 map 容器中键为 k 的键值对</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>除了向 erase() 传入目标键值对位于 map 容器中的位置外，还可以传入目标键值对的键的值，该方法会自行根据指定的键找到目标键值对，并将其删除。erase() 方法的语法格式如下：</li></ol><p><strong>&#x2F;&#x2F;删除 map 容器中键为 k 的键值对<br />size_type erase (const key_type&amp; k);</strong><br />其中，参数 k 为要删除键值对的键的值，该方法的返回值为成功删除的键值对的个数。</p><ol start="3"><li>在某些实际场景中，可能需要删除某个指定区域内的所有键值对，也可以通过 erase() 方法实现，其语法格式如下：</li></ol><p><strong>&#x2F;&#x2F;删除 map 容器中位于 [first，last) 区域内的所有键值对<br />iterator erase (const_iterator first, const_iterator last);</strong><br />其中，参数 first 和 last 都是迭代器，它们的组合 [first, last) 就表示 map 容器中的某个范围，该方法会删除此范围内的所有键值对，并返回一个迭代器，其指向删除范围之后的第一个键值对。<br />注意，如果 [fist,last) 范围之后，不再有任何键值对，则 erase() 方法返回的迭代器将指向 map 容器最后一个键值对之后的位置（等同于 end() 成员方法返回的迭代器）。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol><li>find函数</li><li>count函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt;:: iterator ii=m.<span class="built_in">find</span>(<span class="string">&quot;uuu&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(ii==m.<span class="built_in">end</span>())&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;没有查找到uuu&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;查找uuu成功，并且它的值=&quot;</span>&lt;&lt;ii-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ii=m.<span class="built_in">count</span>(<span class="string">&quot;uuu&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(ii==<span class="number">1</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;查找成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;查找失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;_map;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">while</span>(iter!=_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; iter-&gt;second&lt;&lt;endl;</span><br><span class="line">    iter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(iter = _map.<span class="built_in">begin</span>(); iter != _map.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>对于<code>map</code>的插入，可以使用<code>insert</code>或者<code>[]</code>的形式。</p><ul><li><p><code>insert</code>插入非重复的值，如果插入的值重复出现了，则丢弃要插入的值，对原<code>map</code>不作处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> x = viewSumMap.<span class="built_in">find</span>(creators[i])-&gt;second;</span><br><span class="line">viewSumMap.<span class="built_in">erase</span>(creators[i]);</span><br><span class="line">viewSumMap.<span class="built_in">insert</span>(&#123;creators[i], views[i] + x&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>[]</code>用来插入值，如果没有出现过，则成功插入，如果插入的值重复出现了，则覆盖原<code>map</code>中已经有的值</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viewSumMap[creators[i]] += views[i];</span><br><span class="line"><span class="keyword">if</span> (viewSumMap[creators[i]]&gt;maxView)&#123;</span><br><span class="line">    maxView = viewSumMap[creators[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>一.  map、set、multimap、multiset</strong><br />上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:</p><ul><li>插入: O(logN)</li><li>查看: O(logN)</li><li>删除: O(logN)</li></ul><p><strong>二. unordered_map、unordered_set、unordered_multimap、 unordered_multiset</strong><br />上述四种容器采用哈希表实现，不同操作的时间复杂度为：</p><ul><li>插入: O(1)，最坏情况O(N)</li><li>查看: O(1)，最坏情况O(N)</li><li>删除: O(1)，最坏情况O(N)</li></ul><h3 id="搭配pair使用"><a href="#搭配pair使用" class="headerlink" title="搭配pair使用"></a>搭配<code>pair</code>使用</h3><p>很多时候，映射关系往往不止一个，但是，会关键的<code>key</code>又只有一个，因此我们可以利用<code>pair</code></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是<code>first second</code> 因为是使用<code>struct</code>不是<code>class</code>，所以可以直接使用pair的成员变量。<br />其标准库类型–pair类型定义在<code>#include &lt;utility&gt;</code>头文件中，定义如下：<br />类模板：<code>template&lt;class T1,class T2&gt; struct pair</code><br />参数：T1是第一个值的数据类型，T2是第二个值的数据类型。<br />功能：pair将一对值(T1和T2)组合成一个值，这一对值可以具有不同的数据类型（T1和T2），两个值可以分别用pair的两个公有函数<code>first</code>和<code>second</code>访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;            <span class="comment">//创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span></span><br><span class="line"><span class="function">pair&lt;T1, T2&gt; <span class="title">p1</span><span class="params">(v1, v2)</span></span>;    <span class="comment">//创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。</span></span><br><span class="line"><span class="built_in">make_pair</span>(v1, v2);          <span class="comment">// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span></span><br><span class="line">p1 &lt; p2;                    <span class="comment">// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span></span><br><span class="line">p1 == p2；                  <span class="comment">// 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span></span><br><span class="line">p1.first;                   <span class="comment">// 返回对象p1中名为first的公有数据成员</span></span><br><span class="line">p1.second;                 <span class="comment">// 返回对象p1中名为second的公有数据成员</span></span><br></pre></td></tr></table></figure><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;string,string&gt; Author;</span><br><span class="line"><span class="function">Author <span class="title">proust</span><span class="params">(<span class="string">&quot;March&quot;</span>,<span class="string">&quot;Proust&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Author <span class="title">Joy</span><span class="params">(<span class="string">&quot;James&quot;</span>,<span class="string">&quot;Joy&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// 创建一个空对象anon，两个元素类型都是string</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; word_count;     <span class="comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt; &gt; line;  <span class="comment">// 创建一个空对象line，两个元素类型分别是string和vector类型</span></span><br></pre></td></tr></table></figure><h4 id="接收pair"><a href="#接收pair" class="headerlink" title="接收pair"></a>接收<code>pair</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">getPreson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="string">&quot;Sven&quot;</span>, <span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> ages;</span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">tie</span>(name, ages) = <span class="built_in">getPreson</span>();</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, ages: &quot;</span> &lt;&lt; ages &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七课 动态内存</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/longyi1234/archive/2010/03/30/1700369.html#:~:text=%E5%9C%A8C%2FC%EF%BC%8B%EF%BC%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%AD%EF%BC%8C%E6%9C%89%E4%BA%BA%E7%BB%8F%E5%B8%B8%E6%90%9E%E4%B8%8D%E6%B8%85%E6%A5%9A%E2%80%9C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E2%80%9D%E5%92%8C%E2%80%9C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E2%80%9D%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%A6%82%E5%BF%B5%E3%80%82,%E5%85%B6%E5%AE%9E%E7%AE%80%E5%8D%95%E4%B8%80%E7%82%B9%E8%AE%B2%EF%BC%8C%E2%80%9C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E2%80%9D%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%B8%B8%E9%87%8F%EF%BC%8C%E8%80%8C%E2%80%9C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E2%80%9D%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%9C%B0%E5%9D%80%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%8F%98%E5%8C%96%E7%9A%84%E3%80%82">常量指针和指针常量</a><br>内存：</p><ol><li>堆</li><li>栈</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667284753197-c2837955-829a-4803-bc6e-e96514269d20.png" alt="image.png"></p><h2 id="动态对象"><a href="#动态对象" class="headerlink" title="动态对象"></a>动态对象</h2><ul><li>在堆中创建</li><li><code>new</code> <code>delete</code>既是操作符（可以修改默认语义），也是关键字</li><li><code>new``delete</code>可以重载：只能重载<strong>开辟内存 –</strong> 不一定从编译器管理的内存找，可以自定义在堆上、栈上管理</li></ul><h3 id="为什么需要-new-和-free"><a href="#为什么需要-new-和-free" class="headerlink" title="为什么需要 new 和 free"></a>为什么需要 new 和 free</h3><ul><li>用<code>malloc</code> 创建对象：<strong>不能</strong> 对象的创建必须调用构造函数，构造函数不是显式调用的。</li><li>需要一种新的机制：除了能分配内存，还能调用构造函数；除了能收回内存，还能调用析构函数</li><li><code>new</code>返回的是<code>A*</code>，而<code>malloc</code>返回的是<code>void*</code></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667285017101-ed9dc8a7-8371-461b-a7a5-e7ed38b12f0d.png" alt="image.png"></p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667285182323-e8caee0c-42c3-4528-9126-f861af35210c.png" alt="image.png"></p><ul><li><code>int *intPtr = new int</code>：在堆上创建了基本类型，是一种兼容</li><li>栈上的对象都有名称，<strong>堆上的对象都是无名对象，只能通过指针访问。</strong></li><li>指针本身也是一种数据类型，和字长一样大</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667285335535-599dfb93-d582-4a91-be35-5ff963b3fcee.png" alt="image.png"></p><h3 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h3><ol><li>创建对象时，实际上创建了两个内存块：</li><li><code>delete ptr</code> 删除的是<code>Object</code>，如果生命周期没有结束，仍然可以访问<code>ptr</code>。如果再次调用，会使用已经被删除的内存，出现了段错误</li><li>所以需要 <code>ptr = null</code></li><li>同时，可以避免<code>double free</code>。如果<code>ptr</code>置为<code>Null</code>了，<code>delete</code>是没有用的</li></ol><p>在使用<code>void*</code>时，使用<code>delete</code>，会根据指针类型，调用构造函数。但是，<strong>如果是</strong><code>**void***</code><strong>，直接</strong><code>**delete**</code><strong>，只会释放内存，不会调用构造函数，所以需要类型转换。类型决定了调用哪些函数！</strong></p><blockquote><p><strong>以编译为主的语言，类型十分重要</strong></p></blockquote><h3 id="动态对象数组"><a href="#动态对象数组" class="headerlink" title="动态对象数组"></a>动态对象数组</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667287273247-a93fa9cd-17fa-45d8-861c-591787c8a4d0.png" alt="image.png"></p><ul><li><strong>使用初始化列表，可以显式初始化，所以不一定需要默认构造函数了</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A *p;</span><br><span class="line"><span class="keyword">new</span> A</span><br><span class="line"><span class="keyword">new</span> A[<span class="number">100</span>]  <span class="comment">//返回的都是A*</span></span><br><span class="line">数组的首地址和<span class="number">0</span>号位置的地址一致</span><br><span class="line"><span class="keyword">delete</span>[]p </span><br></pre></td></tr></table></figure></li></ul><ol><li><code>[]</code>不能省略：从声明类型上看，<strong>不知道</strong><code>**p**</code><strong>指向的是存储</strong><code>**A**</code><strong>的数组还是</strong><code>**A**</code><strong>一个对象</strong></li><li><code>delete</code>调用析构函数，归还内存。</li><li>如何知道数组要调用多少次析构函数？</li></ol><p><code>new A[100]</code>会多分配4个字节，返回的地址之前有四个字节用来存储元素个数</p><ol start="4"><li>如果没有<code>[]</code>，<ol><li>则不会找4个字节，只会调用一次析构函数。会导致<strong>内存泄漏</strong></li><li><strong>起始地址是地址减去4个字节，会直接从中间释放，导致段错误</strong></li></ol></li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p </span><br><span class="line">p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]</span><br><span class="line"><span class="keyword">delete</span> p </span><br></pre></td></tr></table></figure><p>该写法是正确的。<strong>对于内置数据类型，不需要调用析构函数，所以不会添加4个字节，所以直接删去整块内存</strong></p><h4 id="动态2D数组"><a href="#动态2D数组" class="headerlink" title="动态2D数组"></a>动态2D数组</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667287517824-1c16de09-8834-4035-9bf7-b3a253ac6ee7.png" alt="image.png"></p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667287588030-9c4ef74c-9ea1-4ff2-b77d-4271e3d66089.png" alt="image.png"><br>缺点：红色的部分是额外的内存开销<br />所以：要用一维数组模拟二维数组<code>a[i][j] = a[i*4+j]</code> 进行操作符重载即可</p><h2 id="Const成员"><a href="#Const成员" class="headerlink" title="Const成员"></a>Const成员</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667287926876-e668fdf0-6f02-4a2b-9236-e8cd36dbca74.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num)&#123;</span><br><span class="line">        x = num;</span><br><span class="line">        <span class="comment">// 会报错</span></span><br><span class="line"><span class="comment">// Cannot assign to non-static data member &#x27;x&#x27; with const-qualified type &#x27;const int&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num):<span class="built_in">x</span>(num)&#123;</span><br><span class="line"><span class="comment">//        x = num;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>static</code>：所有的对象共享一份数据<br /><code>static const</code>：所有的对象共享一份常量。<strong>必须在定义的时候初始化，不能用初始化列表初始化</strong> 在列表中初始化，则说明不同对象可以修改了。作为<code>const</code>，必须在声明时初始化，作为<code>static</code>，不能在列表中初始化，所以只能定义时初始化了<br /><code>const 对象</code>：对象的成员变量不应该被改变<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667288480210-e82ad341-4ad4-4918-b03e-802a4e066723.png" alt="image.png"><br>编译器不知道哪些操作会改变<code>A</code>的值，哪些不会改变<br />所以需要使用：</p><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><ol><li><strong>非const对象可以访问所有的成员函数、变量；const对象除了不能访问非const成员函数外，其它都可以访问。</strong></li><li><strong>const对象中的成员变量也是可以修改的。通过引用修改即可。</strong><code>**indirect_int++**</code></li></ol><ul><li>函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如const char * getname()。</li><li>函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如char * getname() const。</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667288621359-d8b8d7c3-9269-47e4-b44f-4d3fa6e16ecc.png" alt="image.png"></p><ol><li><code>f()</code>不是const函数，则不能调用</li><li><code>show</code>可以调用。</li></ol><p>对于<code>B.cpp</code>，只需要看<code>a</code>是否调用了非<code>const</code>成员函数<br />如果在<code>f</code>后面也加入<code>const</code>，可能会出错，则需要进行复杂的检查，因为有可能会不断嵌套其他函数。<br />如果<code>A a2（0,0）</code>，所以需要<strong>对象中的变量和对象同步</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667288632395-81d8de30-232e-4ae3-bda5-2a11ab5c8624.png" alt="image.png"><br>每一个函数，都自带一个指针 <br /><code>void f(A* const this)</code> 该<code>const</code>表明指针中的内容不可变<br /><code>void show(const A* const this);</code><br />const A<em>和A</em>不是同一种类型，涉及到const类型转换<br /><strong>const靠近谁，就是谁不可变</strong>，所以第一个<code>const</code>A*不可变，即A中的内容不可变<br /><strong>调用常量对象，就只能调用该对象中this指向的const的成员函数</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667889646421-3452a6b3-561b-402a-834b-6b779a113e04.png" alt="image.png"><br><code>f</code>中<code>a</code>不可以++，但是引用<code>indirect_int</code>可以加加，因为语法上，<code>**indirect_int**</code><strong>是引用，引用是不变量 ，后面对引用的操作和引用本身无关</strong></p><ul><li><strong>对象外的内存和对象本身无关，不受到</strong><code>**const**</code><strong>的限制</strong></li><li><strong>如果</strong><code>**indirect_int**</code><strong>指向</strong><code>**a**</code><strong>，因为编译器无法区分该变量的内存是在类内还是在类外，所以编译器可以通过。</strong></li><li><strong>所以即使声明常量对象，也无法保证类内的变量不可改变（至少编译器无能为力）</strong></li><li><strong>所以，退一步：如果在变量前加入</strong><code>**mutable**</code><strong>，则该变量就是可以在</strong><code>**const**</code><strong>成员函数中被修改：通过</strong><code>**const cast &lt;A*&gt; this **</code><strong>强制类型转换，来实现</strong><code>**mutable**</code></li></ul><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667891099089-4c5fa2b1-a0ea-47b0-af69-83fa84fd8afd.png" alt="image.png"></p><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ol><li>一个类中可以有一个或多个静态成员变量，<strong>所有的对象都共享这些静态成员变量</strong>，都可以引用它。</li><li>static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，<strong>static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。</strong>而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</li><li>静态成员变量<strong>必须初始化，而且只能在类体外进行</strong>。例如：</li></ol><p><code>int Student::m_total = 10;</code><br /><strong>初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0</strong>，而<strong>动态数据区</strong>（堆区、栈区）变量的<strong>默认值是不确定的，一般认为是垃圾值。</strong></p><ol start="4"><li>静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。</li><li>在 C++ 中，static 静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667891271922-930973d6-d869-4051-9c99-184c7631e62d.png" alt="image.png"><br>什么时候定义：、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;    <span class="type">int</span>   x,y;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::shared=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 放在类外的.cpp文件中</span></span><br></pre></td></tr></table></figure><p><code>static const</code>什么时候定义：</p><ul><li><code>const</code>要在成员初始化表中初始化，是在对象创建的时候调用的</li><li>共享+不可变：<strong>在类内声明的时候定义</strong> <code>const static int x = 0</code></li></ul><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667891609721-8e8a5090-69d1-433e-b8f7-147334599d5b.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667891743612-078096d0-b329-41a5-a8c3-e74426adc649.png" alt="image.png"></p><ul><li>兼容了对象和名空间的语法</li><li>既是对象的函数也可解释为类的函数</li><li>区分静态、动态：<ul><li><strong>控制对象的创建</strong></li><li>实现共享</li></ul></li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>控制对象的创建<br />特殊：构造函数和拷贝构造函数声明为<code>private</code> – 类外不能<code>new</code>一个<code>singleton</code>，因为是在<code>new</code>中调用构造函数，但是是私有的，所以禁止在类外<code>new</code>一个对象，所以<strong>对象的创建是可控的</strong><br />懒初始化：用到了再去创建，规定了创建过程是动态的，由<code>new</code>来创建，而不是由<code>static</code>控制。<br />但类外不能创建，所以只能在类内创建 – 如何调用里面的方法？<br />所以：<strong>需要一个静态的入口</strong>，</p><ul><li><strong>静态区</strong>：专门负责动态区的对象的创建和消亡：</li><li><code>_static singleton * instance() _``_static void destroy()  _</code></li><li><strong>只能通过静态成员方法来控制</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667892193353-c847d134-54d2-4147-abb7-d91c301eb9e0.png" alt="image.png"></p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p><a href="http://c.biancheng.net/view/2233.html">C++友元函数和友元类（C++ friend关键字）</a><br>借助友元（friend），可以使得<strong>其他类</strong>中的成员函数以及全局范围内的函数<strong>访问当前类的 private 成员。</strong></p><ul><li>不是类的成员</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667892692130-70164f8a-6256-4ce3-89ca-cb3c56e82d6f.png" alt="image.png"><br>① 程序第 4 行对 Address 类进行了提前声明，是因为在 Address 类定义之前、在 Student 类中使用到了它，如果不提前声明，编译器会报错，提示’Address’ has not been declared。<strong>类的提前声明和函数的提前声明是一个道理。<br />② 程序将 Student 类的声明和实现分开了，而将 Address 类的声明放在了中间，这是因为编译器从上到下编译代码，show() 函数体中用到了 Address 的成员 province、city、district，</strong>如果提前不知道 Address 的具体声明内容，就不能确定 Address 是否拥有该成员（类的声明中指明了类有哪些成员）**。</p><p>这里简单介绍一下类的提前声明。一般情况下，类必须在正式声明之后才能使用；但是<strong>某些情况下（如上例所示），只要做好提前声明，也可以先使用。<br />但是应当注意，</strong>类的提前声明的使用范围是有限的<strong>，</strong>只有在正式声明一个类以后才能用它去创建对象<strong>。如果在上面程序的第4行之后增加如下所示的一条语句，编译器就会报错：<br /><code>Address addr;</code>&#x2F;&#x2F;<strong>企图使用不完整的类来创建对象</strong><br />因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），才能确定应该为对象预留多大的内存。</strong>在对一个类作了提前声明<strong>后，可以用该类的名字去</strong>定义指向该类型对象的指针变量<strong>（本例就定义了 Address 类的指针变量）或</strong>引用变量<strong>（后续会介绍引用），因为</strong>指针变量和引用变量本身的大小是固定的，与它所指向的数据的大小无关。<br />③ <strong>一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。</strong></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667893058472-fe4566bd-9ad8-46b3-b4b4-ec0d137414f6.png" alt="image.png"></p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li>两次声明：可以把friend看做继承</li><li>遵循<strong>先声明后使用的原则</strong>，没有声明则不能确定类型的内存大小</li><li>可以没有<code>class B</code>，但不可以没有<code>class C</code>。因为没有像C使用<code>C::f</code>。没有<code>class B</code>，可以当做一种前向声明，<strong>但是作为一个友元，需要写成</strong><code>**friend B**</code><strong>，因为肯定是引用已有的的</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667893108982-3d504155-5ecf-4abf-b6eb-c28062867ad3.png" alt="image.png"></p><h3 id="不完整声明"><a href="#不完整声明" class="headerlink" title="不完整声明"></a>不完整声明</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667893531250-3e7bf232-0bfb-4083-8f61-581e6572f675.png" alt="image.png"></p><ul><li><strong>因为vector &amp;v 是一个引用，内存大小是确认的，所以可以进行不完整的声明。</strong></li></ul><p>如果A B类互相引用对方，则头文件不能互相引用，所以要在A的头文件中进行前向声明。但是因为没有完整声明，所以A的show和B的show都要写在B的cpp文件中 &#x3D;&gt;设计有点问题 &#x3D;&gt;引入都要同时引用两个类的头文件。</p><ul><li>友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。</li><li>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。</li></ul><h3 id="友元和继承"><a href="#友元和继承" class="headerlink" title="友元和继承"></a>友元和继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    <span class="type">int</span> prot_mem; </span><br><span class="line"><span class="comment">// 该基类中没用友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;)</span></span>; <span class="comment">// clobber 是Sneaky的友元函数，可以访问Sneaky中的private和protected变量</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;)</span></span>; <span class="comment">//clobber 并不是Base的友元函数</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过继承，相当于派生类本身有prom_mem变量，所以可以当作普通的私有、保护变量处理</span></span><br><span class="line">    s.j = s.prot_mem = <span class="number">0</span>; <span class="comment">// 因此可以被友元函数访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobberUnfriend</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; <span class="comment">// 普通函数，没有声明为友元函数时，只能访问对象的公有变量</span></span><br><span class="line"><span class="comment">//    s.j = 0; // error 需要public</span></span><br><span class="line"><span class="comment">//    s.prot_mem = 0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125; <span class="comment">// 该函数需要在Base中定义为友元函数才可以使用</span></span><br></pre></td></tr></table></figure><h2 id="封装原则"><a href="#封装原则" class="headerlink" title="封装原则"></a>封装原则</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668493109613-88d9a76f-af08-42cd-a449-0f68d5ccb046.png" alt="image.png"><br>迪米特法则：信息流在模块之间流动应该是最小的，对象之间的依赖是最小的。</p><h3 id="static和const辨析"><a href="#static和const辨析" class="headerlink" title="static和const辨析"></a>static和const辨析</h3><ol><li><code>static</code>变量在类内声明，且<strong>只能在类外初始化 在类外初始化是保证static成员变量只被定义一次的好方法。</strong></li><li><code>const</code>变量只能类内初始化，不能类外初始化</li><li><code>static const</code>既可以在类内初始化，也可以做类外初始化，但是不能重复初始化</li><li><code>static</code>定义了类内变量后，不可以<code>static int A::num2 = 50;``static</code>关键字如果用了类的名空间，就只能在类内使用</li><li>非静态变量只能在类内初始化，不能在类外初始化</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm库</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/algorithm%E5%BA%93/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/algorithm%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-查找最大最小值"><a href="#1-查找最大最小值" class="headerlink" title="1. 查找最大最小值"></a>1. 查找最大最小值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// min_element/max_element example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::min_element, std::max_element</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myfn</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i&lt;j; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i&lt;j; &#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> myints[] = &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using default comparison:</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The smallest element is &quot;</span> &lt;&lt; *std::<span class="built_in">min_element</span>(myints,myints+<span class="number">7</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The largest element is &quot;</span>  &lt;&lt; *std::<span class="built_in">max_element</span>(myints,myints+<span class="number">7</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using function myfn as comp:</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The smallest element is &quot;</span> &lt;&lt; *std::<span class="built_in">min_element</span>(myints,myints+<span class="number">7</span>,myfn) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The largest element is &quot;</span>  &lt;&lt; *std::<span class="built_in">max_element</span>(myints,myints+<span class="number">7</span>,myfn) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using object myobj as comp:</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The smallest element is &quot;</span> &lt;&lt; *std::<span class="built_in">min_element</span>(myints,myints+<span class="number">7</span>,myobj) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The largest element is &quot;</span>  &lt;&lt; *std::<span class="built_in">max_element</span>(myints,myints+<span class="number">7</span>,myobj) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><code>lower_bound(起始地址, 末尾地址, target)</code>：查找第一个大于等于target目标值的位置<br /><code>upper_bound(起始地址, 末尾地址, target)</code>：查找第一个大于target目标值的位置<br /><code>binary_search(起始地址, 末尾地址, target)</code>：查找target是否存在于数组或vector中，找到返回true，否则返回false<br />这三种方法都是采用的二分查找实现的函数，用于有序数组或vector等，查找效率较高，实际写题时，直接用能较少很多代码量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lower_bound/upper_bound example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::lower_bound, std::upper_bound, std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(myints,myints+<span class="number">8</span>)</span></span>;           <span class="comment">// 10 20 30 30 20 10 10 20</span></span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span> (v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());                <span class="comment">// 10 10 10 20 20 20 30 30</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt;::iterator low,up;</span><br><span class="line">  low=std::<span class="built_in">lower_bound</span> (v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>); <span class="comment">//          ^</span></span><br><span class="line">  up= std::<span class="built_in">upper_bound</span> (v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>); <span class="comment">//                   ^</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;lower_bound at position &quot;</span> &lt;&lt; (low- v.<span class="built_in">begin</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;upper_bound at position &quot;</span> &lt;&lt; (up - v.<span class="built_in">begin</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="find查找"><a href="#find查找" class="headerlink" title="find查找"></a>find查找</h4><p><code>set.find(a)</code>：查找a是否在set中，如果找不到，返回<code>set.end()</code><br /><code>set.count(a)</code>：本来是计算a出现的次数，但是由于集合中是没有重复元素的，于是count函数也就被作为查找函数了，因为a只能出现1次或者0次，查找成功，返回1；查找失败返回0.<br /><code>map.find()</code>：主要用于查找key是否存在map中，不存在返回<code>map.end()</code>，用法和set一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(), v.end())</span></span>;</span><br><span class="line">    <span class="comment">//查找2</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="number">2</span>) != s.<span class="built_in">end</span>()) cout &lt;&lt; <span class="string">&quot;查找成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="swap（）交换"><a href="#swap（）交换" class="headerlink" title="swap（）交换"></a>swap（）交换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">( T&amp; a, T&amp; b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">c</span><span class="params">(a)</span></span>; a=b; b=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reverse（）倒转"><a href="#reverse（）倒转" class="headerlink" title="reverse（）倒转"></a>reverse（）倒转</h3><p>reverse函数反转[first, last)区间的数据，first和last都是迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reverse</span> <span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ((first!=last)&amp;&amp;(first!=--last)) &#123;</span><br><span class="line">    std::<span class="built_in">iter_swap</span> (first,last);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七课 继承</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/qlwy/archive/2011/08/25/2153584.html">C++继承：公有，私有，保护 - csqlwy - 博客园</a></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668493594435-d4b604a2-126b-4d80-811e-04f69bfa1aa0.png" alt="image.png"></p><ul><li>继承了抽象类型，保证代码不会因为子类的修改而变动，有利于今后的维护</li><li>增量开发：可以直接在<code>List</code>类下直接增加<code>LinkedList</code>，而不影响类库</li><li>继承：父类中的所有部分都必须在子类中有</li><li>继承主要是为了继承类型，而不是继承父类的代码</li><li><code>**class**</code><strong>的默认访问权限是</strong><code>**private**</code><strong>，</strong><code>**struct**</code><strong>的默认访问权限是</strong><code>**public**</code></li><li>类中的函数编译时和其他普通函数一样 <code>classname::function(classname *const this)</code></li><li>派生类调用基类的函数，向基类传入自己的指针 – 允许派生类隐式转换为基类</li><li>可以理解为派生类中内嵌了一个基类对象：基类中的<code>private</code>成员代表<strong>派生类中存在基类的私有变量，但逻辑上不可见，只能通过基类的公开方法访问。</strong></li><li>派生类中可以访问基类中的<code>protected</code>成员：如果额外创建了一个对象student，此时不可以访问，只有自己继承父类student，才可以访问其中的变量。因为额外创建的对象不是自己的，继承的是自己的。<strong>如果额外创建了一个父类对象，则不可以访问其成员</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pro = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    using B::x;</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    B *outFather = <span class="keyword">new</span> B;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">proInFather</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; pro &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 此处不会发生编译错误，因为基类嵌入在派生类的内存块中</span></span><br><span class="line">    <span class="comment">// 继承时，不管是public继承还是private/protected继承，基类对于派生类来说，其public成员和</span></span><br><span class="line">    <span class="comment">// protected成员都是可见的</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">proOutFather</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; outFather-&gt;pro &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 此处会发生编译错误，因为是额外创建了一个基类，而pro是保护成员，无法被</span></span><br><span class="line">        <span class="comment">// 实例化的对象所访问，因此会发生编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基类和继承类的方法关系"><a href="#基类和继承类的方法关系" class="headerlink" title="基类和继承类的方法关系"></a>基类和继承类的方法关系</h3><ul><li><strong>根据实际对象执行 – 在编译时期无法确定实际的对象</strong></li><li>利用名空间匹配函数名，匹配函数名成功后，继续匹配参数：但是匹配名称的过程已经结，不会在退回到此步骤（性能上的考虑），所以会直接报错</li><li>不重新定义基类中的非虚函数</li><li>方法的继承：<strong>名空间的可见</strong></li><li>属性的继承：都有拷贝，但不一定可见</li><li>访问的时候会出现<strong>名空间隐藏</strong>的问题<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">10</span>;<span class="comment">//id在Undergraduated_Student中仍然是私有的，默认权限位private</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123; <span class="built_in">strcpy</span>(nickname, s); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> nickname[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_ID</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; id = x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; nickname &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;getId&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// 通过继承基类的公有方法访问到基类的私有变量</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> y = <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span> : <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="type">int</span> dept_no&#123;&#125;;<span class="comment">//学院编号</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; dept_no = x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    void showInfo()&#123;cout &lt;&lt; dept_no &lt;&lt; &quot;:&quot; &lt;&lt; nickname &lt;&lt; endl;&#125;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_ID</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;changed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// 对基类的函数进行覆盖，并修改了访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> Student::nickname;<span class="comment">//这样在才能修改可见性</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新定义了一个private方法，父类对应方法被隐藏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Undergraduated_Student *us = <span class="keyword">new</span> Undergraduated_Student;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; us-&gt;y;</span></span><br><span class="line">    us-&gt;<span class="built_in">SetNickName</span>();</span><br><span class="line">    us-&gt;<span class="built_in">getId</span>();</span><br><span class="line"><span class="comment">//    us-&gt;showInfo(); 无法访问，通过隐藏父类的方法，修改了访问权限</span></span><br><span class="line">    us-&gt;Student::<span class="built_in">showInfo</span>(<span class="number">10</span>); <span class="comment">// 被隐藏了，但是可以显式的使用对应的名空间进行访问</span></span><br><span class="line"><span class="comment">//    us-&gt;showInfo(10); //error ,因为被子类的同名方法所隐藏了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承访问权限：<br />默认：private<br />public<br />private：原来的<br /><strong>私有继承不能用在多态中</strong><br /><strong>私有继承不是类型继承，只是代码复用，所以私有继承使用较少</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668496437699-30d6f703-f199-434b-ad58-bd98998be2dd.png" alt="image.png"><br>前向声明：只是知道有这个东西，不在乎内存大小，所以<strong>前向声明的正确方式为第二种，完整声明的正确方式为第一种</strong></p><hr><p><strong>1）基类成员对派生类都是：共有和保护的成员是可见的，私有的的成员是不可见的。</strong><br /><strong>2）基类成员对派生类的对象来说：要看基类的成员在派生类中变成了什么类型的成员。如：私有继承时，基类的共有成员和私有成员都变成了派生类中的私有成员，因此对于派生类中的对象来说基类的共有成员和私有成员就是不可见的。</strong></p><h5 id="对于公有继承方式"><a href="#对于公有继承方式" class="headerlink" title="对于公有继承方式"></a>对于公有继承方式</h5><p>(1) 基类成员对其对象的可见性：<br />公有成员可见，其他不可见。这里保护成员同于私有成员。<br />(2) 基类成员对派生类的可见性：<br />公有成员和保护成员可见，而私有成员不可见。这里保护成员同于公有成员。<br />(3) 基类成员对派生类对象的可见性：<br />公有成员可见，其他成员不可见。<br />所以，在公有继承时，派生类的对象可以访问基类中的公有成员；派生类的成员函数可以访问基类中的公有成员和保护成员。这里，一定要区分清楚<strong>派生类的对象和派生类中的成员函数对基类的访问是不同的。</strong></p><h3 id="有元和protected"><a href="#有元和protected" class="headerlink" title="有元和protected"></a>有元和protected</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668497699369-13fbaa61-6e09-4c73-9306-78ebcbaeda1e.png" alt="image.png"><br>只有基类直接的派生类可以访问到基类的protected，不可以传入基类对象或者创建基类对象进行访问。<strong>保护 — 只能访问内嵌的基类，否则就可以如上述案例，绕过保护作用</strong><br /><strong>友元不具有传递性：不能通过成为派生类的友元来成为基类的友元</strong></p><h3 id="继承时构造函数的调用顺序"><a href="#继承时构造函数的调用顺序" class="headerlink" title="继承时构造函数的调用顺序"></a>继承时构造函数的调用顺序</h3><p>1、子类对象在创建时会首先调用父类的构造函数<br />2、父类构造函数执行完毕后，才会调用子类的构造函数<br />3、当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数<br />4、析构函数调用顺序和构造函数相反<br /><strong>派生类对象的初始化</strong>由基类和派生类共同完成<br /><strong>构造函数的执行次序</strong></p><ol><li>基类的构造函数</li><li>派生类<strong>对象成员类</strong>的构造函数</li><li>派生类的构造函数</li></ol><p>**析构函数的执行次序 **与构造函数相反<br /> 执行顺序：<br />1.构造基类（因为首先要通过继承，确认成员变量）<br />2.成员变量初始化<br />3.初始化列表初始化<br />4.该类的构造函数<br /> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base1 构造函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base1 析构函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son1 构造函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Son1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son1 析构函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里可以看到，先调用Base1的构造函数</span></span><br><span class="line"><span class="comment"> * 再调用Son1的构造函数，</span></span><br><span class="line"><span class="comment"> * 然后先析构Son1，</span></span><br><span class="line"><span class="comment"> * 最后析构Base1。</span></span><br><span class="line"><span class="comment"> * 注：1、这里的顺序和类作为成员变量很像，但是</span></span><br><span class="line"><span class="comment"> *     实质是不一样的。成员是直接创建一个新的对象，</span></span><br><span class="line"><span class="comment"> *     而继承是对父类的成员调用。</span></span><br><span class="line"><span class="comment"> *     2、子类在继承父类的属性的时候，可以继承成员</span></span><br><span class="line"><span class="comment"> *     属性，但是构造和析构函数是类本身的特有属性，</span></span><br><span class="line"><span class="comment"> *     是不可以被继承下来的。这里要特别注意！！！ </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son1 s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================华丽的分割线===============================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base2 构造函数！&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Base2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base2 析构函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base2&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注:当父类没有合适的默认构造函数的时候，</span></span><br><span class="line"><span class="comment">     *    子类在调用父类的时候，需要用列表的</span></span><br><span class="line"><span class="comment">     *    方式调用父类的构造函数，否则编译不过。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     Base1 base1;</span><br><span class="line">     Base2 base2;</span><br><span class="line">    <span class="built_in">Son2</span>(<span class="type">int</span> a):<span class="built_in">Base2</span>(a), <span class="built_in">base2</span>(<span class="number">99</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son2 构造函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Son2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son2 析构函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Son2 <span class="title">s</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n==========================华丽的分割线===============================\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Base1 构造函数！</span></span><br><span class="line"><span class="comment">// Son1 构造函数！</span></span><br><span class="line"><span class="comment">// Son1 析构函数！</span></span><br><span class="line"><span class="comment">// Base1 析构函数！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==========================华丽的分割线===============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Base2 构造函数！1</span></span><br><span class="line"><span class="comment">// Base1 构造函数！</span></span><br><span class="line"><span class="comment">// Base2 构造函数！99</span></span><br><span class="line"><span class="comment">// Son2 构造函数！</span></span><br><span class="line"><span class="comment">// Son2 析构函数！</span></span><br><span class="line"><span class="comment">// Base2 析构函数！</span></span><br><span class="line"><span class="comment">// Base1 析构函数！</span></span><br><span class="line"><span class="comment">// Base2 析构函数！</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668498234783-538be04d-aa92-42da-bcfc-a6cbeef904d8.png" alt="image.png"><br>如果自定义拷贝构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(<span class="number">10</span>,<span class="number">100</span>)</span></span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">B</span> <span class="params">(<span class="type">const</span> &amp;B b)</span>:A(b)</span></span><br><span class="line"><span class="function">// 显示的声明调用A的拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li>如果自定义了B的拷贝构造函数，则先调用A的<strong>默认构造函数</strong>和B的拷贝构造函数，不会进行默认拷贝构造函数。<strong>需要显示的声明调用A的拷贝构造函数</strong></li><li>如果没有自定义B的拷贝构造函数，会调用A B的<strong>默认拷贝构造函数</strong></li><li>程序员介入了资源管理，编译器会决定什么都不干</li></ul><p>语法糖<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668498664408-4128ab5f-fddc-4be3-9267-311a490fb013.png" alt="image.png"></p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="类型相容"><a href="#类型相容" class="headerlink" title="类型相容"></a>类型相容</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669097615644-8abfdef5-9142-4062-a4d9-a80fefed2f61.png" alt="image.png"><br>类型相容：<br /><code>A a;  B b; class B: public A</code><br /><code>a=b</code>都是栈上的两个对象，会将一个内存单元的内容赋值到另一个内存单元中。但<code>a</code>的内存块通常比<code>b</code>小。<strong>赋值相容不代表精度仍然保持一致，直接丢弃超出的内容，因为赋值后身份已经发送了变化，所以不会再使用独属于派生类的属性了。</strong><br /><code>b</code>所丢失的部分就是<strong>对象切片</strong><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669098065167-7be38f9f-93a0-42ff-937c-93e517c2ad5b.png" alt="image.png"><br>引用和指针都不涉及到对象的赋值，对象身份没有改变，可以使用多态<br />C++会灵活使用栈和堆，而Java大部分都在堆上创建对象，C++效率更高</p><h3 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669098345401-a321406e-d37d-46e2-ad7f-1f5186252e98.png" alt="image.png"><br><code>func1</code>调用<code>A::f </code><br /><code>func2</code>调用<code>A::f </code><br /><strong>编译顺序很关键</strong>：</p><ol><li>先编译<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669098507783-9f529832-a853-44d8-84e0-6ec7c79c9640.png" alt="image.png">，<code>a</code>的地址已经定义好了，<code>**fun1**</code><strong>不知道实际对象是什么，只看声明的类型是什么，编译时刻已经确定地址是什么。</strong>当出现调用时，再传递参数。</li></ol><h3 id="绑定顺序"><a href="#绑定顺序" class="headerlink" title="绑定顺序"></a>绑定顺序</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669098609451-c9a15725-42bd-4437-a10a-86646f16b8dd.png" alt="image.png"></p><ul><li>前期绑定是通过声明的类型确定地址，效率更高😀</li><li>前期绑定也叫静态绑定，动态绑定也叫后期绑定</li><li>多态只能通过动态绑定实现，需要不断去寻找地址。</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669098751773-5d777830-2df2-486b-9006-79a3b3bcf468.png" alt="image.png"><br><strong>基类中被定义为虚成员函数，则派生类中对其重定义的成员函数均为虚函数</strong><br /><strong>在子类中重写函数，但是没显示写virtual，仍然会默认为虚函数</strong></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul><li>类的成员函数才可以是虚函数</li><li>静态成员函数不能是虚函数：在全局初始化时，静态编译时就已经确定，<strong>只和类有关，和对象无关，类是通过静态绑定的。</strong></li><li>内联成员函数不能是虚函数：在编译时进行代码替换，需要决定用哪一段代码进行替换，已经消除了函数调用，相当于复制了函数内容</li><li>构造函数不能是虚函数</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669270003568-cd301292-6551-438d-b907-229ce23d7ad5.png" alt="image.png"><br>不存在声明类型和实际类型不一致的情况</p><ul><li>析构函数可以（往往）是虚函数</li></ul><p><strong>当基类指针指向派生类的时候，若基类析构函数不声明为虚函数，在析构时，只会调用基类而不会调用派生类的析构函数，从而导致内存泄露。</strong></p><h3 id="动态绑定的实现"><a href="#动态绑定的实现" class="headerlink" title="动态绑定的实现"></a>动态绑定的实现</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669099413312-8d7304c5-0ac3-48af-9b6f-cc689a7e4fd1.png" alt="image.png"></p><ul><li>调用<code>p-&gt;f </code>因为是虚函数，所以指向a时，调用的是A中的f，指向b时，调用的是B中的f。每一次调用，都要<strong>寻找地址</strong></li><li>调用<code>p-&gt;h</code>，调用的都是A中的h，因为是<strong>静态绑定</strong>的，所以只和声明的类型有关，是为了提高效率</li></ul><p><code>_**(**((char *)p-4))(p)**_</code><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669100693413-17a4d8f4-11a7-496d-a674-8802585aea97.png" alt="image.png"></p><ul><li>通过两次解引用找到函数，所以效率较低</li></ul><h3 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669101373514-aba3460d-e38f-422a-ab43-67a8fc090557.png" alt="image.png"></p><h3 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669101481670-7d0e9a68-3ea5-4df7-9a49-374348c6d6c8.png" alt="image.png"><br>非虚函数部分和当前对象保持一致，虚函数部分和实际对象保持一致</p><ul><li>非虚接口：非虚函数中调用虚函数</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669102171092-59924684-73b5-4643-8f98-c48c5f537f9d.png" alt="image.png"><br>override：参数一致，返回值也要一致<br />f2中override去掉是可以的，是新定义的静态函数。和虚函数同名的静态函数，也会名空间覆盖<br />const：不能去掉，有无const<strong>不能不能类型转换</strong></p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669270166264-92b934f8-9956-46b7-8f85-8547dd98b1b1.png" alt="image.png"></p><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669270197146-22a55467-bed9-4fb0-b158-a9581381ccbc.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669270225691-ebd0984d-221b-4cde-be0c-d076a4f8596e.png" alt="image.png"></p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669270374234-a17419e7-4a70-4785-a5b8-f2412a691ed0.png" alt="image.png"></p><ul><li>**析构函数是用来换额外的内存的，不是用来还自身对象的内存的，因为申请内存时是会记录内存大小的 **所以没有申请额外内存时，就不需要自定义析构函数</li></ul><p>因为D中不会自动<code>delete name</code>，所以需要在D中自定义析构函数，所以需要确保调用该析构函数，所以需要定义为虚函数。</p><ul><li><strong>派生类析构函数完成后，自动调用基类的析构函数</strong></li></ul><h3 id="绝对不要重新定义继承而来的缺省参数值"><a href="#绝对不要重新定义继承而来的缺省参数值" class="headerlink" title="绝对不要重新定义继承而来的缺省参数值"></a>绝对不要重新定义继承而来的缺省参数值</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669271262345-5b75d5cd-a582-4fa7-87d5-5f33d78fb5a5.png" alt="image.png"></p><ul><li>默认参数值：<strong>编译时确定的</strong><ul><li><code>f()</code>将默认参数绑定在上面</li><li><code>f(x)</code>将参数<code>x</code>绑定在函数上</li></ul></li><li>根据声明类型，找到默认参数值</li></ul><p>动态调用默认参数值，需<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669271533569-42e4d663-46e0-4d5f-87d2-7129058d1805.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669271556775-59e413bd-1df4-43e0-989f-9151876b47cd.png" alt="image.png">  <br /><strong>对象中只记录虚函数的入口地址，不记录相关的参数，为了提高效率，除了虚函数其他都是静态编译完成的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">110</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">1</span>)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; in B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">75</span>)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; in C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *p_a;</span><br><span class="line">    B b;</span><br><span class="line">    p_a = &amp;b;</span><br><span class="line">    p_a-&gt;<span class="built_in">f</span>(); <span class="comment">// 110 in B</span></span><br><span class="line">    A *p_a1;</span><br><span class="line">    C c;</span><br><span class="line">    p_a1 = &amp;c;</span><br><span class="line">    p_a1-&gt;<span class="built_in">f</span>(); <span class="comment">// 110 in C</span></span><br><span class="line">    c.<span class="built_in">f</span>(); <span class="comment">// 75 in C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好的公开继承"><a href="#好的公开继承" class="headerlink" title="好的公开继承"></a>好的公开继承</h3><ul><li>确定public inheritance,是真正意义的“is_a”关系</li><li>不要定义与继承而来的非虚成员函数同名的成员函数</li><li>最弱前置条件</li><li>最强后置条件</li><li>契约式设计</li><li>派生类不是代表“特殊”，因为特殊代表性质会改变</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669272346654-2de6294b-5fb8-45f9-87f5-a542aaaba2e6.png" alt="image.png"><br><code>**assert(s.width() == s.height());**</code>不变式<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669273538285-127f0faf-fd48-4132-9b8a-ddb4f9a5947a.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669273739637-a0853c6a-d974-4e46-a167-e11c6be7b7ae.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669273851180-58caa6d5-4347-4fb1-8001-cd0e26310f9d.png" alt="image.png"><br>同一个对象，呈现了不同行为 – 名空间不同，出现错误调用</p><h3 id="明智的私有继承"><a href="#明智的私有继承" class="headerlink" title="明智的私有继承"></a>明智的私有继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CHumanBeing</span> &#123; … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStudent</span>: <span class="keyword">private</span> CHumanBeing &#123; … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> CHumanBeing&amp; h)</span></span></span><br><span class="line"><span class="function"></span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line">CHumanBeing a;  CStudent b;</span><br><span class="line"><span class="built_in">eat</span>(a);</span><br><span class="line"><span class="built_in">eat</span>(b); <span class="comment">//Error </span></span><br></pre></td></tr></table></figure><ul><li><strong>私有继承，派生类无法隐式转换为基类。不能使用基类指向派生类的场景</strong></li><li>转换由编译器完成，要求派生类能够公开访问基类的构造函数。</li></ul><p><code>Implemented-in-term-of</code></p><ol><li>需要使用<code>Base Class</code>中的<code>protected</code>成员，或重载<code>virtual function</code></li><li>不希望一个<code>Base Class</code>被<code>client</code>使用</li><li>实际上是Has-A关系</li><li>如果两个类的继承是私有的，则不能在派生类外将派生类转换成基类对象。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669274553636-5752421b-8251-4145-9ab5-33b00a99f87f.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> string&amp; msg)</span></span>;   </span><br><span class="line"><span class="comment">// 一般虚函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 非虚函数：保持所有对象的行为一致，而且不能修改，防止违反契约，</span></span><br><span class="line"><span class="comment">// 不重新定义非虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>练习</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E7%BB%83%E4%B9%A0/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668497123984-785e0d99-2c2c-4975-89cc-7af23c3a0e60.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span></span>&#123;x = px;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getX</span><span class="params">()</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> B::x;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span></span>&#123;x = <span class="number">2</span>*px;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B * pb = <span class="keyword">new</span> D;</span><br><span class="line">    pb-&gt;<span class="built_in">setX</span>(<span class="number">15</span>);</span><br><span class="line">    pb-&gt;<span class="built_in">getX</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;x&#x27; is a private member of &#x27;B&#x27; i🎇🎇🎇</span></span><br></pre></td></tr></table></figure><ul><li>使用名空间调用B.x，是不可见的，因为<strong>默认为private，所以没有using的权限，无法改变其使用权限</strong></li><li><strong>如果删掉第11行代码也是错误的，因为此处的x依然是指B中的x，虽然内存中含有，但是不可见</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span> </span>&#123;</span><br><span class="line">        x = px;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;setX in B &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    using B::x;</span></span><br><span class="line">    <span class="type">int</span> x&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">2</span> * px;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;setX in D&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">methodInD</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;methodInD&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B *pb = <span class="keyword">new</span> D;</span><br><span class="line">    pb-&gt;<span class="built_in">setX</span>(<span class="number">15</span>); <span class="comment">//set X in B</span></span><br><span class="line">    pb-&gt;<span class="built_in">getX</span>();   <span class="comment">// 15</span></span><br><span class="line">    <span class="comment">// 因为没有加virtual，同时由于编译的缘故，所以pb只能通过声明的类型去使用方法，因此pb只能</span></span><br><span class="line">    <span class="comment">// 看到基类自己的方法，而无法看到派生类的方法</span></span><br><span class="line">    pb-&gt;<span class="built_in">methodInD</span>(); <span class="comment">// 会报错: No member named &#x27;methodInD&#x27; in &#x27;B&#x27; i 🔥🔥</span></span><br><span class="line">    D *pd = <span class="keyword">new</span> D;</span><br><span class="line">    pd-&gt;<span class="built_in">setX</span>(<span class="number">10</span>); <span class="comment">// set X in D</span></span><br><span class="line">    pd-&gt;<span class="built_in">getX</span>();  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>隐藏函数？<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668497335363-9d85365e-f299-4ae6-822a-978dc204e4b6.png" alt="image.png"><br>编译正确，输出为0<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span> </span>&#123;</span><br><span class="line">        x = px;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;setX in B &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    using B::x;</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;setX in D&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> px)</span> </span>&#123; B::<span class="built_in">setX</span>(<span class="number">2</span> * px); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B *pb = <span class="keyword">new</span> D;</span><br><span class="line">    pb-&gt;<span class="built_in">setX</span>(<span class="number">15</span>); <span class="comment">// setX in B 因为pb的类型是B类型，所以调用的B中的setX函数</span></span><br><span class="line"><span class="comment">//    pb-&gt;getX();</span></span><br><span class="line">    D *pd = <span class="keyword">new</span> D;</span><br><span class="line">    pd-&gt;<span class="built_in">setX</span>(<span class="number">5</span>); <span class="comment">// setX in B 因为pd中的setX内部调用了B空间下的setX，所以改变的是B空间中的x</span></span><br><span class="line">    pd-&gt;<span class="built_in">getX</span>();  <span class="comment">// 10</span></span><br><span class="line">    pd-&gt;<span class="built_in">setX</span>(); <span class="comment">// setX in D  </span></span><br><span class="line">    pd-&gt;<span class="built_in">getX</span>(); <span class="comment">// 10 调用的依然是B空间中的getX方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七课 多继承</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%A4%9A%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%A4%9A%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669274986730-feb36fb8-60a1-489b-8fe3-5d484ecd5490.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275090314-9b2959bf-fe08-4159-85cf-823b45b922a6.png" alt="image.png"><br>名冲突：<code>weight</code>指向不确定。</p><h3 id="基类分解、菱形设计"><a href="#基类分解、菱形设计" class="headerlink" title="基类分解、菱形设计"></a>基类分解、菱形设计</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275198145-278052dd-2c68-46d7-965b-fd58e64f6e34.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275244282-a443735a-327d-4fe0-893c-debfec756664.png" alt="image.png"><br>形成了<strong>格</strong>，但仍然有名冲突问题</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275435051-efa3038c-b17d-4cde-b084-c0b225dc00b5.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275657042-7a99f6cd-e0ff-4c3d-bd09-97bca26370a8.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669275603149-bcb3c6b9-2008-4ffc-b4a4-212a1255c95f.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669276213041-4342840c-4495-4bec-8aec-6dada2097bc7.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>左值和右值</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<ul><li><p>左值：赋值操作符左边的值，是可以被赋值的，通常是一个变量</p></li><li><p>右值：<strong>赋值操作符右边的值</strong>，是一个常数、表达式、函数调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp; y = x; <span class="comment">// 可以把左值绑定在非const的引用上</span></span><br><span class="line"><span class="type">int</span> &amp; z = <span class="number">5</span>; </span><br><span class="line"><span class="comment">// 不可以把右值绑定在非const的引用上，因为右值通常是临时变量，不能</span></span><br><span class="line"><span class="comment">// 修改临时变量的值，很可能已经被销毁了</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;u = <span class="number">5</span>; <span class="comment">// 可以把右值绑定在常量引用上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;u = x;</span><br></pre></td></tr></table></figure><p>右值引用可以绑定在右值上，不可以绑定在左值上。拷贝的代价很高</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">string S = <span class="built_in">generate</span>(); <span class="comment">// 返回的是右值，无法进行拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>移动构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string::<span class="built_in">string</span>(string &amp;&amp; s):<span class="built_in">p</span>(s.p)&#123;</span><br><span class="line">s.p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接将s的指针赋值给当前对象的指针，在将原来s的指针置为空指针。因为不是</span></span><br><span class="line"><span class="comment">// 多个s指向同一个指针，所以避免了二次释放的问题</span></span><br><span class="line"><span class="comment">// 移动完后，指针要置为nullptr，不需要重新创建对象，也不需要进行</span></span><br><span class="line"><span class="comment">// 拷贝，提高了效率</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string &amp;&amp; s = <span class="built_in">generate</span>();</span><br><span class="line"><span class="comment">// 右值可以直接绑定到右值引用上</span></span><br><span class="line"><span class="comment">// 引用就是变量的别名，持有了对这块内存的访问权限，可以对右值进行修改</span></span><br><span class="line"><span class="comment">// 编译器保证持有该引用时，变量不会消亡</span></span><br></pre></td></tr></table></figure></li><li><p>没有自定义拷贝构造函数、拷贝赋值和析构函数时，会提供默认移动构造函数、移动赋值函数</p></li><li><p>移动构造函数是为了降低拷贝的代价，一旦自定义了拷贝构造，就认为有些拷贝行为需要特殊处理，不能默认。</p></li><li><p>定义了析构函数，意味着申请了额外的资源，需要如何拷贝、如何移动，编译器不知道，是不会提供默认的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第八课 多态</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%85%AB%E8%AF%BE%20%E5%A4%9A%E6%80%81/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%85%AB%E8%AF%BE%20%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669701732876-dce5c5f5-842c-46a7-a14e-e62d73da4ac5.png" alt="image.png"></p><h2 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h2><ol><li>OO程序设计 - 虚函数：是运行时的多态，是动态绑定的，具体引用只能在运行时确定</li><li>函数重载：一名多用，是静态的多态，在编译时就能确定</li><li>类属多态：通过泛型编程<code>template</code>，传入不同类型，复用同一段代码</li></ol><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669701998839-14770e03-ab97-4923-b316-2b0614d74dfd.png" alt="image.png"></p><ol><li>首先进行名空间的匹配</li><li>再进程参数匹配</li><li>所以不会进行返回值的匹配</li><li>由<code>Compiler</code>和<code>Linker</code>共同决定</li></ol><h4 id="歧义控制"><a href="#歧义控制" class="headerlink" title="歧义控制"></a>歧义控制</h4><ul><li>顺序</li><li>更好匹配</li><li>窄转换</li></ul><ol><li>参数的个数和被调函数相等</li><li>参数类型可以匹配、隐式转换</li><li>如果没有一模一样的函数签名：找到最佳匹配函数。<ol><li>参数double、float，传入的是int</li></ol></li></ol><p>有一个实参的匹配比其他参数更好，其他实参不比其他参数差</p><ul><li>完全匹配</li><li>整形提升：bool转化为int，是更好的</li><li>标准转化之前没有优劣比较，char 到unsigned char 和char 到double的匹配，一视同仁</li></ul><p>窄转换：</p><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669702437333-0f13555b-3495-4bdf-9add-be514e2db853.png" alt="image.png"><br>操作符重载就是函数重载<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669702718765-9df7c9d2-389a-4f5b-8d52-86991ca130a3.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669703230947-f32bb687-674c-4204-b949-35543af0bd52.png" alt="image.png"><br>在成员函数中，不需要强调自定义类型，因为<code>this</code>代表的就是自定义的类型<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669703911201-c8d8e5a1-e56c-40b9-98dd-513e7fb950d8.png" alt="image.png"></p><h4 id="不可重载"><a href="#不可重载" class="headerlink" title="不可重载"></a>不可重载</h4><p><code>.</code>成员访问操作符<br /><code>.*</code>成员指针访问运算符<br />防止访问成员的功能被改变<br /><code>::</code>域操作符<br /><code>?:</code>条件操作符<br />存在跳转的功能，本身是控制流程的作用，操作符重载是函数调用，进行函数调用的过程中，所有的代码都要被执行，无法实现跳转。如果重载后，和语义有偏差，因此不能重载<br /><code>sizeof</code>参数是类型，不是变量或表达式，因此不能重载</p><h3 id="双目操作符"><a href="#双目操作符" class="headerlink" title="双目操作符"></a>双目操作符</h3><h4 id="类成员函数重载"><a href="#类成员函数重载" class="headerlink" title="类成员函数重载"></a>类成员函数重载</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669705399777-0c00bc6b-e929-464b-ad5e-9340a24dc27c.png" alt="image.png"><br>第一个参数默认为<code>this</code>，必须为自定义类型</p><h4 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669705364265-8398f5ea-0c20-4bcc-ab8c-e0fd4726cabf.png" alt="image.png"><br><code>=</code>赋值运算符<code>()</code>函数调用运算符</p><ul><li><code>[]</code>下标运算符<code>-&gt;</code>间接访问操作符：有特定的顺序，先对对象进行操作，再根据对象操作参数。但是全局函数重载无法保证顺序，所以不能全局函数重载</li><li>操作符的第一个参数不是自定义类型本身</li><li>遵守交换律</li><li>单目操作符没有意义使用全局函数，单目操作符都可以作为类的成员函数进行重置</li></ul><h4 id="全局函数-x2F-成员函数的选择"><a href="#全局函数-x2F-成员函数的选择" class="headerlink" title="全局函数&#x2F;成员函数的选择"></a>全局函数&#x2F;成员函数的选择</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669706144754-84e6af3f-bd44-40b0-9972-5c1cc9157d3b.png" alt="image.png"></p><ul><li>第一个参数是自定义对象：使用成员函数</li><li>需要支持交换律：使用全局函数进行补充</li></ul><ol><li>单目运算符+只能声明为成员函数的（其他的都用全局函数）：作为类的成员函数</li><li>双目运算符：作为类的友元函数</li><li>类型转换函数、操作符修改状态时：定义为成员函数</li><li>第一个参数有隐式类型转换：定义为友元函数，因为成员函数需要精准匹配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CL</span>&#123;</span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CL</span>(<span class="type">int</span> i)&#123;...&#125;<span class="comment">//可以进行隐式类型转换</span></span><br><span class="line"><span class="keyword">friend</span> CL <span class="keyword">operator</span>+(<span class="type">int</span> i,CL&amp;a);</span><br><span class="line"><span class="keyword">friend</span> CL <span class="keyword">operator</span>+(CL&amp;a,<span class="type">int</span> i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="永远不要重载-amp-amp-和"><a href="#永远不要重载-amp-amp-和" class="headerlink" title="永远不要重载 &amp;&amp; 和 ||"></a>永远不要重载 &amp;&amp; 和 ||</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669706610099-ec843e63-a3bf-4908-8c03-bed79575b34d.png" alt="image.png"><br>第一行<code>if</code>借用了短路，如果重载，就是函数调用，如第3行和第4行<code>if</code>，两个参数都会运算，改变了短路行为，会出错</p><h4 id="不要过度追求效率？？"><a href="#不要过度追求效率？？" class="headerlink" title="不要过度追求效率？？"></a>不要过度追求效率？？</h4><p>直接返回对象的拷贝。</p><ul><li><ul><li><ul><li><ul><li>&#x2F; 直接返回对象的拷贝，效率不是很高，可以对于需要拷贝的进行<strong>返回值优化。不要一开始创建tmp对象，最后在</strong><code>**return**</code><strong>时创建tmp对象，直接返回，避免拷贝，优化代码</strong></li></ul></li></ul></li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669707418198-37aa04ec-6489-4f4f-905c-faf57fabe122.png" alt="image.png"></p><h3 id="单目操作符"><a href="#单目操作符" class="headerlink" title="单目操作符"></a>单目操作符</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669707675609-437d7c38-1a54-434f-b7ff-dffcf7ffd7fd.png" alt="image.png"><br><code>a++</code>返回的是左值a &#x3D; a + 1 <br /><code>++a</code>返回的是右值 a+1<br />如何确定重载的是a++还是++a<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669707876149-4560a6e5-31c9-4d1f-ab99-579613dbcbad.png" alt="image.png"><br><code>int</code>作用</p><ol><li>区分函数：签名不同，函数名相同才可以重载</li><li><code>int</code>是哑元，不在函数中参与运行</li></ol><p><code>return``*this</code>返回当前对象</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669705624351-75232bdc-ce71-42f7-936c-4f97f2652e20.png" alt="image.png"><br><code>&lt;&lt;</code>两个参数：双目操作符的重载<br />为什么要return <code>ostream</code>的对象？支持链式调用<code>cout &lt;&lt;d1&lt;&lt;</code></p><h2 id="特殊操作符的重载"><a href="#特殊操作符的重载" class="headerlink" title="特殊操作符的重载"></a>特殊操作符的重载</h2><h3 id="操作符-x3D-的重载"><a href="#操作符-x3D-的重载" class="headerlink" title="操作符 &#x3D; 的重载"></a>操作符 &#x3D; 的重载</h3><ol><li>默认赋值操作符重载函数</li><li>逐个成员赋值</li><li>对含有对象成员的类，该定义是递归的</li><li>赋值操作符的重载不可以被继承：因为拷贝构造，派生出来的类有一些新的部分</li><li>返回引用类型:<strong>返回*this的引用，支持链式赋值</strong></li><li>this引用应该是<strong>非常量引用</strong>，返回出来的是作为右值进行计算<ol><li>a &#x3D; b &#x3D; c:不要求非常量引用</li><li>(a &#x3D; b).f():要求非常量引用</li></ol></li><li>例一:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line">A b;</span><br><span class="line">A a = b;<span class="comment">//对a调用拷贝构造函数(更重要的是构造，在构造对象时候调用，再进行赋值)</span></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">// 第2 3 行代码等价</span></span><br><span class="line"><span class="comment">// 先调用构造函数再调用赋值操作符函数，效率比直接调用拷贝构造函数低</span></span><br><span class="line"></span><br><span class="line">A a,b; <span class="comment">// 对a调用构造函数，因为调用过构造函数了，所以不能再调用拷贝构造函数了</span></span><br><span class="line">a = b;<span class="comment">// 对a调用赋值操作符重载函数</span></span><br></pre></td></tr></table></figure>区分：<strong>判断被赋值的对象a有没有被构造过</strong></li></ol><ul><li>已经被构造过，调用赋值操作符重载函数</li><li>未被构造过，调用拷贝构造函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">operator</span> = (<span class="type">const</span> A&amp;)&#123;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 方便链式调用等号</span></span><br><span class="line">    <span class="comment">// 返回值可以做左值，也可以做右值。通过小括号改变优先级。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x,y ;</span><br><span class="line">    <span class="type">char</span> *p ; <span class="comment">// 额外申请的内存块，赋值的时候需要先释放</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">char</span> *s):<span class="built_in">x</span>(i),<span class="built_in">y</span>(j)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s)+ <span class="number">1</span> ];</span><br><span class="line">            <span class="built_in">strcpy</span>(p,s);<span class="comment">//进行拷贝，最后留一个\0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] p;</span><br><span class="line">        &#125;</span><br><span class="line">        A&amp; <span class="keyword">operator</span> = (A&amp; a) &#123;</span><br><span class="line">            <span class="comment">//赋值</span></span><br><span class="line">            x = a.x;</span><br><span class="line">            y = a.y;</span><br><span class="line">            <span class="keyword">delete</span> []p; <span class="comment">// 防止内存泄漏</span></span><br><span class="line">            <span class="comment">// 1.如果自我赋值，会出错</span></span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a.p)+<span class="number">1</span>]; <span class="comment">// 重新开辟新的内存</span></span><br><span class="line">            <span class="comment">// 2.如果资源没有了 new char 会抛出异常，对象构造失败了，但是p已经被</span></span><br><span class="line">            <span class="comment">// 删掉了，对象本身存在，但是p被delete调了。</span></span><br><span class="line">            <span class="comment">// 指针还在，指针的内存已经没了，出现指针悬垂问题</span></span><br><span class="line">            <span class="built_in">strcpy</span>(p,a.p);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//也会出现悬垂</span></span><br><span class="line">        &#125;<span class="comment">//还有问题，就是赋值自身会出现问题</span></span><br><span class="line">&#125;;</span><br><span class="line">A a, b;</span><br><span class="line">a = b;<span class="comment">//调用自己的复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//idle pointer，B被析构的时候会将p释放掉，导致p指向已经被释放掉的指针</span></span><br><span class="line"><span class="comment">//Memory leak,A申请的区域可能没有办法被释放</span></span><br></pre></td></tr></table></figure>资源拷贝：<strong>先申请，再删除</strong><br /><strong>解决方法：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更安全的拷贝，先new再delete</span></span><br><span class="line"><span class="type">char</span> *pOrig = p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">char</span> ...</span><br><span class="line"><span class="built_in">strcpy</span>();</span><br><span class="line"><span class="keyword">delete</span> pOrig;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//自我赋值可以吗？可以，换了一块内存空间，没有内存泄露</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>注意:避免自我赋值(因为是相同的内存地址)<ol><li>Sample: class string</li><li>s &#x3D; s<ol><li><code>class &#123;... A void f(A&amp; a);...&#125;</code></li><li><code>void f (A&amp; a1, A&amp; a2)</code></li><li><code>int f2(Derived &amp;rd,Base&amp; rb);</code></li></ol></li></ol></li></ol><p>额外检测：<strong>证同测试</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;a)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 不需要赋值了</span></span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//48min - 50min</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Object identity<ol><li>Content</li><li>Same memory location</li><li>Object identifier<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ObjectID <span class="title">identity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;; </span><br><span class="line">A *p1,*p2; </span><br><span class="line">p1-&gt; <span class="built_in">identity</span>() == p2-&gt; <span class="built_in">identity</span>()</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="操作符-的重载"><a href="#操作符-的重载" class="headerlink" title="操作符[]的重载"></a>操作符[]的重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">string</span>(<span class="type">char</span> *p1)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span> [<span class="built_in">strlen</span>(p1)+ <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(p,p1);<span class="comment">//#pragma warning(disable:4996)来屏蔽问题</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 参数是this、i</span></span><br><span class="line">        <span class="type">char</span>&amp; <span class="keyword">operator</span>[] (<span class="type">int</span> i)&#123; <span class="comment">// 可以声明为常成员函数：兼容常量类型string</span></span><br><span class="line">            <span class="keyword">return</span> p[i];  <span class="comment">//p[i] = *(p+i)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 精确匹配高于类型转化</span></span><br><span class="line"><span class="comment">// 参数是 const this、i</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以用两个重载函数吗?是可以的</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">string</span>() &#123; <span class="keyword">delete</span>[] p ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;aacd&quot;</span>)</span></span>;</span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span> ; <span class="comment">// 是可以的，只会调用第一个，因为是精确匹配的</span></span><br><span class="line"><span class="comment">//第一个重载加上const可以使得const或者非const对象都可以调用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">cs</span><span class="params">(<span class="string">&#x27;const&#x27;</span>)</span></span>; <span class="comment">//只能调用常成员函数</span></span><br><span class="line">cout &lt;&lt; cs[<span class="number">0</span>];</span><br><span class="line">cs[<span class="number">0</span>] = <span class="string">&#x27;D&#x27;</span>; <span class="comment">// 如果没有第二个重载，则无法阻止这一行为</span></span><br><span class="line"><span class="comment">//const 版本不想被赋值(返回const的)，</span></span><br><span class="line"><span class="comment">// 非const版本想要被赋值，之后再进行重载的时候就需要同时重载两个</span></span><br></pre></td></tr></table></figure><h4 id="多维数组-class-Array2D"><a href="#多维数组-class-Array2D" class="headerlink" title="多维数组 class Array2D"></a>多维数组 class Array2D</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array2D</span>(<span class="type">int</span> l, <span class="type">int</span> c):<span class="built_in">n1</span>(l),<span class="built_in">n2</span>(c)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">int</span>[n1*n2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123; <span class="keyword">delete</span>[] p; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp; <span class="title">Array2D::getElem</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">//上面是实现高维数组</span></span><br><span class="line"><span class="function">Array2D <span class="title">data</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">data.<span class="built_in">getElem</span>(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//target -&gt; data[1][2]</span></span><br><span class="line"><span class="comment">//想法:化解为两次调用</span></span><br><span class="line">data.<span class="keyword">operator</span>[](<span class="number">1</span>)[<span class="number">2</span>];<span class="comment">//int *operator[](int i) 一次偏移一行，转化成Array1D</span></span><br><span class="line">data.<span class="keyword">operator</span>[](<span class="number">1</span>).<span class="keyword">operator</span>[](<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">//问题:三维数组重载问题:重载一次降维一次，3D-&gt;2D等等，多个依次进行重载，重载之后返回对象</span></span><br><span class="line"><span class="comment">//代理对象:Array1D</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Array1D</span>&#123;</span><br><span class="line">    <span class="type">int</span> *q;<span class="comment">//一维降低到int *就行</span></span><br><span class="line">    <span class="built_in">Array1D</span>(<span class="type">int</span> *p)&#123; q = p; &#125;</span><br><span class="line">    <span class="type">int</span>&amp;  <span class="keyword">operator</span>[](j)&#123;</span><br><span class="line">        <span class="keyword">return</span> q[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data[1][3]</code></p><ul><li>使用二级指针：浪费空间，多次寻址</li><li>先解析第一个<code>[]</code>：告诉量的偏移应该是如何的。再解析第二个<code>[]</code></li></ul><p><code>int *operator[](int i)</code>是有默认定义的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Array1D</span>&#123;<span class="comment">//Surrogate 多维，proxy class 访问代理类，对于其他外部类没有作用</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="built_in">Array1D</span>(<span class="type">int</span> *p) &#123; <span class="keyword">this</span>-&gt;p = p; &#125; </span><br><span class="line"><span class="comment">// 构造函数中只有一个参数，可以允许该参数类型转化到该类</span></span><br><span class="line">                <span class="type">int</span>&amp; <span class="keyword">operator</span>[] (<span class="type">int</span> index) &#123; <span class="keyword">return</span> p[index]; &#125;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> <span class="keyword">operator</span>[ ] (<span class="type">int</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> p[index]; &#125;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">Array2D</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">int</span>[n1 * n2];</span><br><span class="line">            num1 = n1;</span><br><span class="line">            num2 = n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] p;</span><br><span class="line">        &#125;</span><br><span class="line">        Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">return</span> p + index * num2; <span class="comment">//通过偏移量寻找</span></span><br><span class="line">            <span class="comment">//return的值和int*相同，构造函数不能声明成显式构造函数。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里为什么是array1D?通过构造函数进行类型转换</span></span><br><span class="line">        <span class="type">const</span> Array1D <span class="keyword">operator</span>[] (<span class="type">int</span> index) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p+index*num2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>explicit</code>不能执行隐式类型转化，只能显式调用</li></ul><h3 id="操作符（）的重载"><a href="#操作符（）的重载" class="headerlink" title="操作符（）的重载"></a>操作符（）的重载</h3><ul><li><p>函数调用</p></li><li><p>类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    <span class="type">double</span> para;</span><br><span class="line">    <span class="type">int</span> lowerBound , upperBound ;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Func f; <span class="comment">// 函数对象：可以作为参数传递到其他函数</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2.4</span>, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array2D</span>(<span class="type">int</span> l, <span class="type">int</span> c):<span class="built_in">n1</span>(l),<span class="built_in">n2</span>(c)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">int</span>[n1*n2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (p+i*n2)[j];<span class="comment">//优化getElement</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>函数指针：在没有全局变量下，给定一个参数，返回值是确定的</p></li><li><p>函数对象：对象是有状态的，可以作为泛型算法的实参</p></li></ul><h3 id="类型转换运算符-重载"><a href="#类型转换运算符-重载" class="headerlink" title="类型转换运算符()重载"></a>类型转换运算符()重载</h3><ol><li>基本数据类型</li><li>自定义类</li></ol><p>减少自定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="built_in">Rational</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) &#123;</span><br><span class="line">        n = n1;</span><br><span class="line">        d = n2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 由类型名称决定返回值类型，从而区分函数调用操作符</span></span><br><span class="line"><span class="comment">// 类型转化不能作为全局函数 -- 主体是本类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123;  <span class="comment">//类型转换操作符，语法特殊。</span></span><br><span class="line">        <span class="comment">// 不能使用哑元，因为函数调用的参数个数是不确定的</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)n/d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> n, d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减少混合计算中需要定义的操作符重载函数的数量</span></span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> x = r;</span><br><span class="line">x = x + r;<span class="comment">//避免的double 和 rational 的全局函数重载，会自动全部转换为double</span></span><br></pre></td></tr></table></figure><ul><li><code>=</code>不能全局重载，<strong>由于优先在类内匹配，首先匹配到的是编译器提供的默认版本</strong></li><li><code>[]</code>不能全局重载</li><li>类型转化不能全局重载<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//48min</span></span><br><span class="line"><span class="function">ostream <span class="title">f</span><span class="params">(<span class="string">&quot;abc.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="comment">//重载  数值型：如 int</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="gt-指针间接引用操作符重载"><a href="#gt-指针间接引用操作符重载" class="headerlink" title="-&gt; 指针间接引用操作符重载"></a>-&gt; 指针间接引用操作符重载</h3><p>箭头操作符一般声明为const成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.<span class="built_in">f</span>();</span><br><span class="line">a-&gt;<span class="built_in">f</span>();</span><br><span class="line">a.<span class="keyword">operator</span>-&gt;(f)</span><br><span class="line">a.<span class="keyword">operator</span>-&gt;()-&gt;<span class="built_in">f</span>() </span><br><span class="line">    <span class="comment">//重载时按一元操作符重载描述,这时，</span></span><br><span class="line">    <span class="comment">// a.operator-&gt;() 返回一个指针(或者是已经重定义过-&gt;的对象)</span></span><br><span class="line">    <span class="comment">// 返回支持箭头操作符的值</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPen</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_color;</span><br><span class="line">    <span class="type">int</span> m_width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">int</span> c)</span></span>&#123; m_color = c;&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m_width; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPanel</span> &#123;</span><br><span class="line">    CPen m_pen;</span><br><span class="line">    <span class="type">int</span> m_bkColor;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">CPen* <span class="title">getPen</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> &amp;m_pen;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setBkColor</span><span class="params">(<span class="type">int</span> c)</span></span>&#123; m_bkColor =c;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">CPanel c;</span><br><span class="line">c.<span class="built_in">getPen</span>()-&gt;<span class="built_in">setColor</span>(<span class="number">16</span>); <span class="comment">// 按照名称获得成员变量</span></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//简单修改，可以返回一个对象内部对象的指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPen</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_color;</span><br><span class="line">    <span class="type">int</span> m_width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">int</span> c)</span></span>&#123; m_color = c;&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_width; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPanel</span> &#123;</span><br><span class="line">    CPen m_pen;</span><br><span class="line">    <span class="type">int</span> m_bkColor;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CPen* <span class="keyword">operator</span> -&gt;()&#123; <span class="keyword">return</span> &amp;m_pen;&#125;</span><br><span class="line">        <span class="function">CPen* <span class="title">getPen</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> &amp;m_pen;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setBkColor</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123; m_bkColor =c;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">CPanel c;</span><br><span class="line">c-&gt;<span class="built_in">setColor</span>(<span class="number">16</span>); <span class="comment">// 可以当成CPen指针使用</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//c.operator-&gt;()-&gt;setColor(16);</span></span><br><span class="line"><span class="comment">//c.m_pen.setColor(16)</span></span><br><span class="line">c-&gt;<span class="built_in">getWidth</span>();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//c.operator-&gt;()-&gt;getWidth();</span></span><br><span class="line"><span class="comment">//c.m_pen.getWidth()</span></span><br><span class="line">CPanel *p=&amp;c;</span><br><span class="line">p-&gt;<span class="built_in">setBkColor</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>名称是不能重载的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">if</span>(...)&#123;<span class="keyword">return</span> ...&#125;</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();<span class="comment">//如果出错可能会导致问题</span></span><br><span class="line">    p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);<span class="comment">//返回值</span></span><br><span class="line">    p-&gt;<span class="built_in">h</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 不一定会执行到该处，是多出口函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//更好的管理A对象，不用在任何退出的地方写delete p</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">AWrapper <span class="title">p</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();<span class="comment">//如果出错可能会导致问题</span></span><br><span class="line">    p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);<span class="comment">//返回值</span></span><br><span class="line">    p-&gt;<span class="built_in">h</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="comment">// 对象的消亡就是资源的释放，资源和栈上的对象同声明周期了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//须符合compiler控制的生命周期</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AWrapper</span>&#123;<span class="comment">//不包含逻辑</span></span><br><span class="line">    A* p;<span class="comment">// ? T p; 支持多个类型</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AWrapper</span>(A *p) &#123; <span class="keyword">this</span>-&gt;p = p;&#125;</span><br><span class="line">        ~<span class="built_in">AWrapper</span>() &#123; <span class="keyword">delete</span> p;&#125;</span><br><span class="line">        A*<span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> p;&#125; <span class="comment">// 不需要管是对象还是指针了</span></span><br><span class="line">&#125;;<span class="comment">//RAII 资源获取及初始化</span></span><br><span class="line"><span class="comment">//函数返回，销毁局部指针的时候会直接删除</span></span><br></pre></td></tr></table></figure>RAII：资源和对象绑定</li></ul><ol><li>是可控的管理：申请资源和释放资源的时间点都是确定的</li><li>让资源和栈上的对象同生命周期，确保资源释放且只被释放一次</li></ol><p>重载指针可以让对象p看起来和裸指针一样，不需要管是对象还是指针了<br />局限性：封装的资源必须和函数同生命周期了</p><h3 id="new-x2F-delete-的重载"><a href="#new-x2F-delete-的重载" class="headerlink" title="new&#x2F;delete 的重载"></a>new&#x2F;delete 的重载<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670482300611-eb3bf5ed-0e63-4197-b3dd-c700e0a9fffd.png" alt="image.png"></h3><h4 id="重载-new"><a href="#重载-new" class="headerlink" title="重载 new"></a>重载 new</h4><ol><li><code>void *operator new (size_t size, s...)</code></li><li>名:<code>operator new</code></li><li>返回类型:void *</li><li>第一个参数:<code>size_t(unsigned int)</code><ul><li>系统自动计算对象的大小，并传值给size</li></ul></li><li>其他参数:可有可无<ul><li><code>A *p = new (...) A</code>，表示传给new的</li></ul></li><li>new的重载可以有多种</li><li>如果重载一个new，那么通过new动态创建该类的对象时将不再调用内置的(预定义的)new</li><li>允许进行全局重载，但是不推荐使用全局重载</li></ol><p>![F)5I%]Q@IEKC~F%{M_KG12A.png](<a href="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670483573949-3fd16832-b4ce-4941-b674-d9abe3ab2a36.png">https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670483573949-3fd16832-b4ce-4941-b674-d9abe3ab2a36.png</a>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(base))</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span> (size);</span><br><span class="line"><span class="comment">//调用全局标准库的new进行size的分配，标准库的new永远是可以使用的</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> [];</span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size, <span class="type">void</span>*)</span><span class="comment">//是不可以被重载的，标准库版本，指定了对象创建的位置</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size, ostream &amp; log)</span></span>;<span class="comment">//可以同时写入到日志</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size, <span class="type">void</span> * pointer)</span></span>;</span><br><span class="line"><span class="comment">//定位new，placement new，被调用的时候，在指针给定的地方的进行new(可能预先已经分配好的)，</span></span><br><span class="line">分配比较快，长时间运行不被打断(不会导致内存不足)</span><br></pre></td></tr></table></figure><p>定位new <code>placement new</code>：控制了内存的分配<code>malloc</code></p><h4 id="重载-delete"><a href="#重载-delete" class="headerlink" title="重载 delete"></a>重载 delete</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670483765273-27d85d17-0cbe-41f1-864c-f68fcf6cd2ef.png" alt="image.png"></p><h3 id="返回值总结"><a href="#返回值总结" class="headerlink" title="返回值总结"></a>返回值总结</h3><ul><li>返回值是右值的按值传递</li><li>返回值是左值的按引用传递</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vector的使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Vector%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Vector%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>erase(pos)</td><td><strong>删除 vector 容器中 pos 迭代器指定位置处的元素</strong>，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>swap(beg)、pop_back()</td><td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。</td></tr><tr><td>erase(beg,end)</td><td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向<br /><strong>被删除区域下一个位置元素的迭代器</strong>。该容器的大小（size）会减小，但容量（capacity）不会发生改变。</td></tr><tr><td>remove()</td><td>删除容器中<strong>所有和指定元素值相等的元素</strong>，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</td></tr><tr><td>clear()</td><td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</td></tr></tbody></table><ul><li>通过 <strong>remove() 函数</strong>删除掉 demo 容器中的多个指定元素，该容器的大小和容量都没有改变，其剩余位置还保留了之前存储的元素。我们可以<strong>使用 erase() 成员函数删掉这些 “无用” 的元素</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">demo.<span class="built_in">erase</span>(iter, demo.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><ul><li>vector():创建一个空vector</li><li>vector(int nSize):创建一个vector,元素个数为nSize</li><li>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</li><li>vector(const vector&amp;):复制构造函数</li><li>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</li></ul><h3 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h3><ul><li>void push_back(const T&amp; x):向量尾部增加一个元素X</li><li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li><li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li><li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li></ul><h3 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h3><ul><li>iterator erase(iterator it):删除向量中迭代器指向元素</li><li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li><li>void pop_back():删除向量中最后一个元素</li><li>void clear():清空向量中所有元素</li></ul><h3 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h3><ul><li>reference at(int pos):返回pos位置元素的引用</li><li>reference front():返回首元素的引用</li><li>reference back():返回尾元素的引用</li><li>iterator begin():返回向量头指针，指向第一个元素</li><li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li><li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li><li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li></ul><h3 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h3><ul><li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li></ul><h3 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h3><ul><li>int size() const:返回向量中元素的个数</li><li>int capacity() const:返回当前向量所能容纳的最大元素值</li><li>int max_size() const:返回最大可允许的vector元素数量值</li></ul><h3 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h3><ul><li>void swap(vector&amp;):交换两个同类型向量的数据</li><li>void assign(int n,const T&amp; x):设置向量中前n个元素的值为x</li><li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li></ul><h3 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h3><p><em>1.push_back 在数组的最后添加一个数据</em><br /><em>2.pop_back 去掉数组的最后一个数据</em><br /><em>3.at 得到编号位置的数据</em><br /><em>4.begin 得到数组头的指针</em><br /><em>5.end 得到数组的最后一个单元+1的指针</em><br /><em>6．front 得到数组头的引用</em><br /><em>7.back 得到数组的最后一个单元的引用</em><br /><em>8.max_size 得到vector最大可以是多大</em><br /><em>9.capacity 当前vector分配的大小</em><br /><em>10.size 当前使用数据的大小</em><br /><em>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</em><br /><em>12.reserve 改变当前vecotr所分配空间的大小</em><br /><em>13.erase 删除指针指向的数据项</em><br /><em>14.clear 清空当前的vector</em><br /><em>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</em><br /><em>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</em><br /><em>17.empty 判断vector是否为空</em><br /><em>18.swap 与另一个vector交换数据</em></p><ul><li>sort(obj.begin(),obj.end());&#x2F;&#x2F;从小到大</li><li>reverse(obj.begin(),obj.end());&#x2F;&#x2F;从大到小</li></ul><p>1.注意 sort 需要头文件 <strong>#include <algorithm></strong><br />2.如果想 sort 来降序，可重写 sort<br />bool compare(int a,int b)  {      return a&lt; b; &#x2F;&#x2F;升序排列，如果改为return a&gt;b，则为降序  }  int a[20]&#x3D;{2,4,1,23,5,76,0,43,24,65},i;  for(i&#x3D;0;i&lt;20;i++)      cout&lt;&lt; a[i]&lt;&lt; endl;  sort(a,a+20,compare);</p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Set的使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Set%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Set%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span> &gt; seta; <span class="comment">//默认是小于比较器less&lt;int&gt;的set</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; setb; <span class="comment">//创建一个带大于比较器的set，需包含头文件functional</span></span><br><span class="line"></span><br><span class="line">set&lt;Food*,compare&gt; foodList; <span class="comment">//创建一个自定义排序方式的set</span></span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>set 是一个内部<strong>自动有序</strong>且不含重复元素的容器。</li><li>set 最主要的作用就是<strong>自动去重并按升序排序</strong>，适用于需要去重但是又不方便直接开数组的情况。</li><li>set 中的元素是唯一的，其内部采用“红黑树”实现。</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669900802886-60956efd-949a-48e1-b9b1-9a4c3680abf4.png" alt="image.png"></p><h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><ol><li><p>当<code>set</code>中存储的是对象指针时，不能使用重载<code>operator &lt;</code> 的方式实现，因为重载时需要使用的参数是引用，而不是指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Food&amp; ptr1,<span class="type">const</span> Food&amp; ptr2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr1.rating == ptr2.rating)&#123;</span><br><span class="line">            <span class="keyword">return</span> ptr1.foodName &lt; ptr2.foodName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1.rating &gt; ptr2.rating;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 无法对装入指针的容器起效</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重载运算符</strong><code>**()**</code><strong>，利用结构体</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">compare</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Food* ptr1,Food* ptr2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr1-&gt;rating == ptr2-&gt;rating)&#123;</span><br><span class="line">            <span class="keyword">return</span> ptr1-&gt;foodName &lt; ptr2-&gt;foodName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1-&gt;rating &gt; ptr2-&gt;rating;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">highestRated</span><span class="params">(string cuisine)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化set时，需要把比较运算符也作为参数</span></span><br><span class="line">    set&lt;Food*,compare&gt; foodList = cuisineToFood[cuisine];</span><br><span class="line">    <span class="keyword">return</span> (*foodList.<span class="built_in">begin</span>())-&gt;foodName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="返回最值"><a href="#返回最值" class="headerlink" title="返回最值"></a>返回最值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s的最小值:&quot;</span>&lt;&lt;*s.<span class="built_in">begin</span>()&lt;&lt;endl;<span class="comment">//第一个数值（最小值）的函数为*s.begin();</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s的最大值为:&quot;</span>&lt;&lt;*s.<span class="built_in">rbegin</span>()&lt;&lt;endl;<span class="comment">//最后一个数值（最大值）的函数为*s.rbegin();</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>注：*s.end()返回的是set容器的最后一个元素(应该是s的长度)，而不是s队列中的最后一个元素，就是说返回的不是最大值。</li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><code>s.lower_bound()</code> 返回第一个<strong>大于或等于</strong>给定关键值的元素<br /><code>s.upper_bound()</code> 返回第一个<strong>大于</strong>给定关键值的元素<br /><code>s.equal_range() </code>返回一对定位器，分别表示 第一个大于或等于给定关键值的元素 和 第一个大于给定关键值的元素，这个返回值是一个pair类型，如果这一对定位器中哪个返回失败，就会等于s.end()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower_bound &amp; upper_bound test:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于或等于3的元素: &quot;</span> &lt;&lt; *s.<span class="built_in">lower_bound</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于或等于2的元素: &quot;</span> &lt;&lt;*s.<span class="built_in">lower_bound</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于2的元素: &quot;</span> &lt;&lt;*s.<span class="built_in">upper_bound</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;equal_range test:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于或等于2的元素: &quot;</span> &lt;&lt;  *s.<span class="built_in">equal_range</span>(<span class="number">2</span>).first &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个大于2的元素: &quot;</span> &lt;&lt; *s.<span class="built_in">equal_range</span>(<span class="number">2</span>).second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Priority_queue的使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B/Priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>排序思路不同<code>&lt;</code>代表的是大顶堆，<strong>因为如果小于为true，则代表小的元素会下浮</strong>，那么大的就会在堆顶，而<code>&gt;</code>代表的是小顶堆，是因为<strong>大的元素下浮了</strong> </li><li>C++中，使用优先级队列需要包含头文件<queue></li><li>不会自动排序。如果修改了优先级队列中某元素的值，则需要重新排序。因此，需要删除特定元素时，使用<code>set</code>更好</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>priority_queue&lt;typename, container, functional&gt;</code></p><ul><li>typename是数据的类型；</li><li>container是容器类型，可以是vector,queue等用数组实现的容器，不能是list，默认可以用vector；</li><li>functional是比较的方式，默认是大顶堆（就是元素值越大，优先级越高）；如果使用C++基本数据类型，可以直接使用自带的less和greater这两个仿函数（默认使用的是less，就是构造大顶堆，元素小于当前节点时下沉）。使用自定义的数据类型的时候，可以重写比较函数，也可以进行运算符重载（less重载小于“&lt;”运算符，构造大顶堆；greater重载大于“&gt;”运算符，构造小顶堆）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个大顶堆，堆中小于当前节点的元素需要下沉，因此使用less</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; priQueMaxFirst;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造一个小顶堆，堆中大于当前节点的元素需要下沉，因此使用greater</span></span><br><span class="line">priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt; priQueMinFirst;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><ol><li><p>重载运算符<code>()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义数据类型，Data类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>(<span class="type">int</span> i, <span class="type">int</span> d) :<span class="built_in">id</span>(i), <span class="built_in">data</span>(d) &#123;&#125;</span><br><span class="line">~<span class="built_in">Data</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重写仿函数，完成less的功能，也可以用class定义类，此时需要将运算符重载函数设为public</span></span><br><span class="line"><span class="comment">//结构体struct中默认是访问类型是public</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>    </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( Data &amp;a, Data &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.<span class="built_in">getId</span>() &lt; b.<span class="built_in">getId</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;Data, vector&lt;Data&gt;, cmp &gt; priQueMaxFirst;<span class="comment">//该优先级队列维护一个大顶堆，因此最大的元素最先出队</span></span><br><span class="line">    ...<span class="comment">//一系列操作</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>重载运算符<code>&lt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载“&lt;”运算符，仿函数less中需要使用</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Data &amp;a, <span class="type">const</span> Data &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;Data, vector&lt;Data&gt;, less&lt;Data&gt; &gt; priQueMaxFirst;<span class="comment">//该优先级队列维护一个大顶堆，因此最大的元素最先出队</span></span><br><span class="line">    ...<span class="comment">//一系列操作</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><p>优先级队列的基本操作与普通队列类似，不同的是每次获得队内的元素是优先级最高的元素（要从堆的顶部开始），因此使用的是top()方法，而不是front()方法。如下：</p><ul><li>push() ：入队。向队列添加一个元素，无返回值；</li><li>pop() ：将队列中优先级最高的元素出队。将队列中优先级最高的元素删除（出队），<strong>无返回值</strong>；</li><li>top() ：获得队列优先级最高的元素。此函数返回值为队列中优先级最高的元素，常与pop()函数一起，先通过top()获得队列中优先级最高的元素，然后将其从队列中删除；</li><li>size() ：获得队列大小。此函数返回队列的大小，返回值是“size_t”类型的数据，“size_t”是“unsigned int”的别名。</li><li>empty() ：判断队列是否为空。此函数返回队列是否为空，返回值是bool类型。队列空：返回true；不空：返回false</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第九课 模板</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B9%9D%E8%AF%BE%20%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E4%B9%9D%E8%AF%BE%20%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="类属函数-templat-function"><a href="#类属函数-templat-function" class="headerlink" title="类属函数 templat function"></a>类属函数 templat function</h2><ol><li>同一函数对不同类型的数据完成相同的操作</li><li>宏实现:<ol><li>#define max(a,b) ((a)&gt;(b)?(a):(b))</li><li>缺陷:<ol><li>只能实现简单的功能</li><li>没有类型检查</li></ol></li></ol></li></ol><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">max</span><span class="params">(A,A)</span> </span>;</span><br></pre></td></tr></table></figure><ol><li>缺陷:<ol><li>需要定义的重载函数太多</li><li>定义不全</li></ol></li><li>不可以只有返回值不同</li></ol><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">void</span> * , <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">int</span> (* cmp) (<span class="type">void</span> *, <span class="type">void</span> *) )</span></span></span><br></pre></td></tr></table></figure><ol><li>缺陷:<ol><li>需要定义额外参数</li><li>大量指针运算</li><li>实现起来复杂</li><li>可读性差</li></ol></li><li>template更加结构清晰，实现简单</li></ol><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int和double都可以使用，编译器编译的并不是之下的代码，而是T转化成具体代码，然后分别编译</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> A[], <span class="type">unsigned</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt; num - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>  (A[j] &gt; A[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                T t = A[j];</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;...&#125;</span><br><span class="line">C a[<span class="number">300</span>];</span><br><span class="line"><span class="built_in">sort</span>(a, <span class="number">300</span>);<span class="comment">//没有重载&gt;</span></span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>必须重载操作符 &gt;</li><li>函数模板定义了一类重载的函数</li><li>函数模板的实例化:<ol><li><strong>隐式实现</strong></li><li>根据具体模板函数调用</li></ol></li><li>函数模板的参数<ol><li>可有多个类型参数，用逗号分隔</li><li>可带普通参数<ul><li><strong>必须列在类型参数之后</strong></li><li>调用时需显式实例化，使用默认参数值可以不显式实例化</li><li>可以有默认值</li></ul></li></ol></li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670912436040-4e4ba3c9-1c05-474b-a92d-8c4f2a23ee23.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T1 a, T2 b)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a)</span> </span>&#123;T temp[size];&#125;</span><br><span class="line"><span class="built_in">f</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol><li>函数模板与函数重载配合使用(编译器优先使用没有使用模板的函数)</li><li>优先匹配重载函数，再继续调用函数的显式、具体化的版本、再调用函数模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"><span class="type">double</span> l, m, n;</span><br><span class="line">z = <span class="built_in">max</span>(x,y);</span><br><span class="line">l = <span class="built_in">max</span>(m,n);</span><br><span class="line"><span class="comment">//为了解决max(x,m)我们使用函数重载更新，优先调用</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="类属类"><a href="#类属类" class="headerlink" title="类属类"></a>类属类</h2><p><code>min</code></p><ol><li><p>类定义带有类型参数，类属类需要显式实例化</p></li><li><p>类模板中的静态成员属于实例化后的类</p></li><li><p>类模板的实例化:创建对象时显式指定，指明类型参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="type">int</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span>  x)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::pop</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">Stack st1;</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    T buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( T x)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明T是类型参数 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">// &lt;T&gt; 用一个具体类型去实例化的stack，&lt;&gt;是用来区分不同类型的</span></span><br><span class="line"><span class="type">void</span> Stack &lt;T&gt; ::<span class="built_in">push</span>(T x) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装double的push和装int的push不是同一个push</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Stack &lt;T&gt; ::<span class="built_in">pop</span>() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如下是显式实例化</span></span><br><span class="line">Stack &lt;<span class="type">int</span>&gt; st1;</span><br><span class="line">Stack &lt;<span class="type">double</span>&gt; st2;</span><br></pre></td></tr></table></figure><p>类模板中的静态成员属于实例化后的类，不是属于模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    T buffer[size];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T x)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="type">void</span> Stack &lt;T, size&gt;::<span class="built_in">push</span>(T x) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line">T Stack &lt;T, size&gt;::<span class="built_in">pop</span>() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">Stack &lt;<span class="type">int</span>, <span class="number">100</span> &gt; st1 ;</span><br><span class="line"><span class="comment">//上面改为template&lt;class T = int,int size = 100&gt;</span></span><br><span class="line"><span class="comment">// 这里可以改成stack&lt;&gt; st1用来显示实例化</span></span><br><span class="line">Stack &lt;<span class="type">double</span>, <span class="number">200</span> &gt; st2 ;</span><br></pre></td></tr></table></figure></li><li><p>类型参数也可以给出初始值，模板类如果不按照从右往左指定默认值参数，会导致编译错误</p></li><li><p>函数模板的默认值不一定是从右向左的，C++11之后函数模板才接受默认值参数。</p></li><li><p>总而言之从右向左给出默认值总是没有问题的</p></li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670913607590-d14aeb1e-9ee2-4089-8cc9-7ef73da0e621.png" alt="image.png"></p><ol><li>如果在模块A中要使用模块B中定义的某模板的实例，而在B中未使用这个实例，则模板无法使用这个实例</li><li>为什么<strong>C++中模板的完整定义常常出现在头文件中</strong>?<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    T a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file1.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> S&lt;T&gt;::<span class="built_in">f</span>()&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, T y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">max</span>(a,b);<span class="comment">//实例化函数模板</span></span><br><span class="line">    S&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">    x.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file1.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">max</span>(<span class="number">1.1</span>,<span class="number">2.2</span>);<span class="comment">//error</span></span><br><span class="line">    S&lt;<span class="type">float</span>&gt; x;</span><br><span class="line">    x.<span class="built_in">f</span>();<span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不能通过编译，为什么？file2.cpp找不到max定义，也找不到完整的S代码</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>因为编译器使用模板时，没有分配存储空间。只有实例化时，才会分配模板空间。所以，因为file1中没有实例化<code>float</code>的模板，因此<code>file2</code>中找不到。尝试自己实例化模板代码</li><li>但是，<code>file1</code>中只有声明，没有实现，因此无法实例化代码</li><li>所以<strong>C++中模板的完整定义常常出现在头文件中</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670914119949-75729499-ed11-49fd-b264-ff21204a92e7.png" alt="image.png"></p><h2 id="Template-MetaProgramming-元编程"><a href="#Template-MetaProgramming-元编程" class="headerlink" title="Template MetaProgramming 元编程"></a>Template MetaProgramming 元编程</h2><ol><li>元程序就是编写一些直接可以生成或者操作其他程序的程序，要在更高层次上。</li><li>编写元程序就是元编程(两级编程)，在编译的时候就已经完成编程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> &#123; value = Fib&lt;N - <span class="number">1</span>&gt;::value + Fib&lt;N - <span class="number">2</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板显式实例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;  <span class="comment">// 需要一个template&lt;&gt; 标明是特殊实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>&lt;<span class="number">1</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Fib&lt;<span class="number">8</span>&gt;::value &lt;&lt; endl;<span class="comment">// calculated at compile time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="易错"><a href="#易错" class="headerlink" title="易错"></a>易错</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i </span>= <span class="number">0</span>, <span class="keyword">typename</span> T = <span class="type">double</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">DefFunc2</span>(T a) &#123;</span><br><span class="line">    cout &lt;&lt; a + i &lt;&lt; endl;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DefFunc2</span>&lt;<span class="number">10</span>,<span class="type">double</span>&gt;(<span class="number">5.555</span>); <span class="comment">// 15.555</span></span><br><span class="line">    <span class="built_in">DefFunc2</span>(<span class="number">5</span>); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">DefFunc2</span>&lt;<span class="number">10</span>&gt;(<span class="number">5.6</span>); <span class="comment">// 5.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尖括号中的代表的是<strong>模板参数</strong>，圆括号中代表的是<strong>函数参数</strong></li><li>模板参数中，可以提供类型参数<code>typename T</code>，对类型<code>T</code>进行默认类型的指定<code>T = double</code>，也可以提供实际的参数<code>i</code>，提供默认值<code>i = 0</code></li></ul><hr><p>类模板：通用的类描述（使用泛型来定义类），进行实例化时，其中的泛型再用具体的类型替换。<br />函数模板：通用的函数描述（使用泛型来定义函数），进行实例化时，其中的泛型再用具体的类型替换。<br /><strong>如果能够从函数实参中推导出类型的话，那么默认模板参数就不会被使用，反之，默认模板参数则可能会被使用。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span> = <span class="type">double</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">f</span>(T t = <span class="number">0</span>, U u = <span class="number">0</span>) &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>); <span class="comment">// f&lt;int, char&gt;(1, &#x27;c&#x27;) 根据实参类型推出模板参数中T U分别代表了什么类型</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>);      <span class="comment">// f&lt;int, double&gt;(1, 0), 使用了默认模板参数double</span></span><br><span class="line">    <span class="built_in">f</span>();       <span class="comment">// 错误: T无法被推导出来</span></span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;();  <span class="comment">// f&lt;int, double&gt;(0, 0), 使用了默认模板参数double</span></span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;(); <span class="comment">// f&lt;int, char&gt;(0, 0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个函数模板<code>f</code>，<code>f</code>同时使用了默认模板参数和默认函数参数。<br />可以看到，由于<strong>函数的模板参数可以由函数的实参推导而出</strong>:<br />在f(1)这个函数调用中，实例化出了模板函数的调用应该为f&lt;int, double&gt;(1, 0)，其中，第二个类型参数U使用了默认的模板类型参数double，而函数实参则为默认值0。<br />类似地，f<int>()实例化出的模板函数第二参数类型为double，值为0。<br />而表达式f()由于第一类型参数T的无法推导，从而导致了编译的失败。<br />而通过这个例子也可以看到，默认模板参数通常是需要跟默认函数参数一起使用的。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="type">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R <span class="built_in">func</span>(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><code>func(97)</code>是根据函数的实参得出，val &#x3D; 97，因此<code>U</code>就是<code>int</code>，所以<code>R</code>就是默认值<code>int</code></li><li>此处同理可得<code>U</code>是<code>int</code>，但<code>&lt;&gt;</code>中有显式地指明了<code>char</code>，所以<code>R</code>就是<code>char</code>而不是默认值<code>int</code></li></ol><h3 id="报错1"><a href="#报错1" class="headerlink" title="报错1"></a>报错1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefFunc2</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a + i &lt;&lt; endl;</span><br><span class="line">&#125;;  <span class="comment">// OK 函数模板不用遵循“由右往左”的规则</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DefFunc2</span>&lt;<span class="number">10</span>,<span class="type">double</span>&gt;(<span class="number">5.555</span>); <span class="comment">// 15.555</span></span><br><span class="line">    <span class="built_in">DefFunc2</span>(<span class="number">5</span>); <span class="comment">// 报错了</span></span><br><span class="line">    <span class="built_in">DefFunc2</span>&lt;<span class="number">10</span>&gt;(<span class="number">5.6</span>); <span class="comment">// 5.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处第8行会报错，因为模板参数中<code>i</code>没有提供默认值了，所以需要显式的给出<code>i</code>的值</p><h3 id="报错2"><a href="#报错2" class="headerlink" title="报错2"></a>报错2</h3><p>类模板在为多个默认模板参数声明指定默认值时，必须遵照<strong>“从右往左”</strong>的规则进行指定。<br />而这个规则对函数模板来说并不是必须的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> DefClass1 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1 = <span class="type">int</span>, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> DefClass2 &#123;&#125;;  <span class="comment">// ERROR: 无法通过编译：因为模板参数的默认值没有遵循“由右往左”的规则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> i = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> DefClass3 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> i = <span class="number">0</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> DefClass4 &#123;&#125;;  <span class="comment">// ERROR: 无法通过编译：因为模板参数的默认值没有遵循“由右往左”的规则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1 = <span class="type">int</span>, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">DefFunc1</span>(T1 a, T2 b) &#123;&#125;; <span class="comment">// OK 函数模板不用遵循“由右往左”的规则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> i = <span class="number">0</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">DefFunc2</span>(T a) &#123;&#125;;  <span class="comment">// OK 函数模板不用遵循“由右往左”的规则</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1 </span>= <span class="type">int</span>, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefFunc3</span><span class="params">(T1 a = <span class="number">10</span>, T2 b)</span> </span>&#123;&#125;; <span class="comment">// ERROR: 函数参数需要遵循“由右往左”的规则</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="报错3"><a href="#报错3" class="headerlink" title="报错3"></a>报错3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="type">int</span> size = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line">T buffer[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> point;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Stack</span>() : <span class="built_in">point</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> size = <span class="number">0</span>&gt; <span class="comment">// 报错了</span></span><br><span class="line"><span class="type">void</span> Stack&lt;T, size&gt;::<span class="built_in">push</span>(T val) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="type">int</span> size&gt; <span class="comment">// 报错了</span></span><br><span class="line"><span class="type">void</span> Stack&lt;T, size&gt;::<span class="built_in">push</span>(T val) &#123;...&#125;</span><br></pre></td></tr></table></figure><ol><li>在类模板的<strong>外部定义</strong>类中的成员时template 后的形参表应**省略默认的形参类型 **<code>template&lt;typename T = int, int size&gt;</code></li><li>在类模板的<strong>外部定义</strong>类中的成员时template 后的形参表应<strong>省略默认的参数值</strong><code>template&lt;typename T, int size = 0&gt;</code></li></ol><p>正确的是<code>template&lt;typename T,int size&gt;</code></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>函数自身的默认参数需要遵循<strong>从右往左</strong>的原则</li><li>模板类中提供的默认参数需要遵循<strong>从右往左</strong>的原则</li><li>模板参数中提供的默认参数<strong>不需要</strong>遵循从右往左的原则</li><li>在类模板的<strong>外部定义</strong>类中的成员时template 后的形参表应<strong>省略默认的形参类型</strong></li><li>在类模板的<strong>外部定义</strong>类中的成员时template 后的形参表应<strong>省略默认的参数值</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十课 异常</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%8D%81%E8%AF%BE%20%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%8D%81%E8%AF%BE%20%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<ol><li>错误<ol><li>语法错误:编译系统</li><li>逻辑错误:测试</li></ol></li><li>异常 Exception<ol><li>运行环境造成:内存不足、文件操作失败等</li><li>异常处理:错误提示信息等</li></ol></li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li><p>特征：</p><ol><li>可以预见</li><li>无法避免</li></ol></li><li><p>作用:提高程序鲁棒性(Bobustness)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;<span class="comment">//str可能是用户的一个输入</span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    file &gt;&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>问题:发现异常之处与处理异常之处不一致，怎么处理?函数中的异常要告知调用者</p></li><li><p>常见处理方式:</p><ol><li>函数参数:<ul><li>返回值(特殊的，0或者1)</li><li>引用参数(存放一些特定的信息)</li></ul></li><li>逐层返回</li></ol></li><li><p>缺陷:</p><ol><li><strong>程序结构不清楚 什么时候是异常的返回值、什么时候是正常的返回值</strong></li><li>相同的异常，不同的地方，需要编写相同的处理了逻辑是不合理的</li><li>希望对异常进行集中的处理</li></ol></li><li><p>传统异常处理方式不能处理<strong>构造函数出现的异常   需要创建资源，会出现异常，但是没有返回值</strong></p></li></ol><br /><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><ol><li>C++异常处理机制是，一种专门、清晰描述异常处理过程的机制</li><li>try：监控</li><li>throw：抛掷异常对象，不处理</li><li>catch：捕获并处理</li></ol><p>关键点：<br />（1）throw是将抛出的表达式的值拷贝到“异常对象”中，catch则是根据异常对象进行参数匹配并处理异常；<br />（2）throw可<strong>一次性跳出多层函数调用</strong>，直到最近一层的try语句，称为<strong>“栈展开”</strong>；<br />（3）catch捕获时是将异常对象与catch参数的进行** 类型比较<strong>，而</strong>不是值比较**，所以只要类型相同，就可以进入catch中处理。（例如throw抛出一个int类型的值，catch(int &amp;i)就可以对其进行处理；或者throw抛出一个类对象，catch(Base&amp; b)也可成功匹配）<br />所谓 “try”，就是 “尝试着执行一下”，如果有异常，则通过throw向外抛出，随后在外部通过catch捕获并处理异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//&lt;语句序列&gt;</span></span><br><span class="line">    <span class="comment">//监控</span></span><br><span class="line">&#125;<span class="keyword">throw</span> &lt;表达式&gt;</span><br><span class="line">    <span class="comment">// 异常可以是基本类型，有表达式计算得到</span></span><br><span class="line">    <span class="comment">// throw 一个异常对象，会调用拷贝构造函数。所以需要能看到该对象的完成调用</span></span><br><span class="line">    <span class="comment">// 可以是基本类型，拷贝构造函数用来拷贝类</span></span><br><span class="line"><span class="built_in">catch</span>(&lt;类型&gt;[&lt;变量&gt;])&#123;</span><br><span class="line">    <span class="comment">//变量不重要可以省略</span></span><br><span class="line">    <span class="comment">//&lt;语句序列&gt; 捕获并处理</span></span><br><span class="line">    <span class="comment">//依次退出，不要抛出指向局部变量的指针，解决:直接抛出对象，自动进行拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要抛出指出局部对象的引用或者指针，直接抛出一个对象</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670916158841-7a0d5595-de36-442c-82f2-5126fb36eb2f.png" alt="image.png"></p><ul><li><code>catch</code>试图精确匹配，允许从<strong>非常量到常量的转换、从派生类到基类的转换、从数组和函数到指针的转换，但不能匹配到</strong><code>**int**</code><strong>转</strong><code>**double**</code><strong>。</strong></li></ul><h4 id="throw的处理过程：（栈展开）"><a href="#throw的处理过程：（栈展开）" class="headerlink" title="throw的处理过程：（栈展开）"></a>throw的处理过程：（栈展开）</h4><p>throw语句一般位于try语句块内，当throw抛出一个异常时，程序暂停当前函数的执行过程，并寻找与try语句块关联的catch语句（类似 switch…case…），<br />如果这一步没找到匹配的catch，且这一层的try语句外部又包含着另一层try，则在外层try中继续寻找匹配的catch，如果找不到，则退出当前函数，在当前函数的外层函数中继续寻找匹配的try与catch。<br />上述过程被称为“栈展开”（stack unwinding）过程。<br />栈展开 过程沿着嵌套函数的调用链不断查找，直到找到匹配的catch 子句为止；<br />或者一直没有找到匹配的catch，则退出主函数终止查找过程（调用标准库函数terminate）。<br />如果找到了一个匹配的catch子句，则程序进入该子句并执行其中的代码，执行完成后回到到这个 try…catch… 的最后一个catch之后的位置继续向下执行。</p><h4 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h4><p>在编译器的管理空间中，会维护一种“异常对象”，专门用于抛出异常时使用。<br />当发生异常时，编译器会用throw 抛出的表达式的值 对 “异常对象” 进行拷贝初始化，当异常处理完毕后，编译器会将“异常对象”销毁。<br />所以，基于 异常对象 的这种处理机制，对抛出异常的处理有几点限制：<br />① 如果throw抛出的表达式是类类型，则此类必须要有<strong>可访问的拷贝构造函数和析构函数</strong>；（因为对 异常对象 进行拷贝初始化 以及 释放 异常对象的时候需要调用）<br />② throw抛出的异常对象<strong>不能是指向局部对象的指针</strong>；<strong>（因为throw退出作用域后，局部对象随之被释放掉，抛出指针到外层后将无法访问所指向的局部对象）</strong><br />③ throw抛出的表达式为此表达式的静态编译类型，<strong>如果抛出的是一个指向类对象的基类指针，则派生类部分将被截断，只有基类部分被抛出。</strong></p><h4 id="析构函数与异常："><a href="#析构函数与异常：" class="headerlink" title="析构函数与异常："></a>析构函数与异常：</h4><p>当异常发生调用throw，后面的语句将不会被执行，退出作用域时，作用域的局部对象都将会被释放，对于类对象，退出作用域时将自动调用它的析构函数。<br />因此，如果析构函数中有抛出异常的流程，应该要在析构函数内部try捕获，并在析构函数内部得到处理。</p><h4 id="初始化列表与异常"><a href="#初始化列表与异常" class="headerlink" title="初始化列表与异常"></a>初始化列表与异常</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob::<span class="built_in">Bob</span>(string i1) <span class="keyword">try</span> : <span class="built_in">data</span>(i1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">catch</span>(<span class="type">const</span> bad_alloc &amp;e) &#123; <span class="built_in">handle_out_of_memory</span>(e); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="函数参数与异常"><a href="#函数参数与异常" class="headerlink" title="函数参数与异常"></a>函数参数与异常</h4><p>通过对函数调用进行处理</p><h4 id="构造函数与异常"><a href="#构造函数与异常" class="headerlink" title="构造函数与异常"></a>构造函数与异常</h4><p>参数部分：通过对<code>new</code>进行处理</p><h3 id="异常处理嵌套"><a href="#异常处理嵌套" class="headerlink" title="异常处理嵌套"></a>异常处理嵌套</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">g</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">     &#123; … &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">char</span> *) <span class="comment">//捕获char*的对象</span></span><br><span class="line">    &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">g</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">h</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">int</span>) <span class="comment">// 不能捕获char*类型的对象</span></span><br><span class="line">    &#123; …  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">h</span>()&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">1</span>;   <span class="comment">//由g捕获并处理</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;abcd&quot;</span>; <span class="comment">//由f捕获并处理</span></span><br><span class="line">&#125; <span class="comment">// 最终被终止程序所捕获</span></span><br><span class="line"><span class="comment">// 如所抛掷的异常对象在调用链上未被捕获，则由系统的abort处理</span></span><br></pre></td></tr></table></figure><h3 id="catch块排列顺序"><a href="#catch块排列顺序" class="headerlink" title="catch块排列顺序"></a>catch块排列顺序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileErrors</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonExist</span>:<span class="keyword">public</span> FileErrors &#123; &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WrongFormat</span>:<span class="keyword">public</span> FileErrors &#123; &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiskSeekError</span>:<span class="keyword">public</span> FileErrors &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        WrongFormat wf;</span><br><span class="line">        <span class="keyword">throw</span> wf;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(NonExists&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(DiskSeekError&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(FileErrors)&#123;...&#125;<span class="comment">//最后一个可以接住，派生类像基类转换是允许的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        WrongFormat wf;</span><br><span class="line">        <span class="keyword">throw</span> wf;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(FileErrors)&#123;...&#125;<span class="comment">//这样子底下都捕获不到</span></span><br><span class="line">    <span class="built_in">catch</span>(NonExists&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(DiskSeekError&amp;)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Catch exceptions by reference</span></span><br><span class="line"><span class="comment">//尝试多继承，而不是拷贝，避免冗余</span></span><br></pre></td></tr></table></figure><ul><li><code>Catch exceptions by reference</code>不使用引用，会发生对象的拷贝。使用引用，也可以直接对该对象处理，而不用对临时对象进行操作</li></ul><h4 id="例题？？"><a href="#例题？？" class="headerlink" title="例题？？"></a>例题？？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionBase</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionDerived</span>: <span class="keyword">public</span> MyExceptionBase &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(MyExceptionBase&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;<span class="comment">//调用拷贝构造函数。 由静态编译的类型确定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyExceptionDerived e;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">f</span>(e);</span><br><span class="line">    &#125;<span class="built_in">catch</span>(MyExceptionDerived&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionDerived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(MyExceptionBase&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionBase&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:MyExceptionBase，为什么?调用了拷贝构造函数，拷贝构造的结果是MyExceptionBase类型的对象</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670917155781-81d74cba-9468-4aed-ae89-5c53567ab922.png" alt="image.png"><br><code>catch(...)</code>：捕获所有异常</p><h3 id="多出口引发的处理碎片"><a href="#多出口引发的处理碎片" class="headerlink" title="多出口引发的处理碎片"></a>多出口引发的处理碎片</h3><p>一个语句块，可以以<code>throw</code>、<code>return</code>作为出口，因此会导致有多个出口</p><ul><li><code>Java：finally</code>：用来处理多出口，最后都会执行，用来释放资源。</li><li><code>c++</code>中没有<code>finally</code><ul><li>异常处理器</li><li>析构函数<code>raii</code>：将资源初始化为对象，由析构函数进行资源清理。即使是多出口，也可以通过析构函数进行处理。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十一课 IO处理</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20IO%E5%A4%84%E7%90%86/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20IO%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671516582458-6e78ee6b-cee6-4d79-aac8-2b1cff8ce4bc.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671516710451-02c3cf96-313f-477b-8b50-e70b2f00b191.png" alt="image.png"></p><ul><li><code>cout</code>是带缓冲的，可以进行重定向</li><li><code>cerr</code>不带缓冲的，用来打印错误信息</li><li><code>clog</code>是带缓冲的</li></ul><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span> <span class="params">(<span class="string">&quot;in. txt&quot;</span>)</span></span>;</span><br><span class="line">streambuf * cinbuf = cin. <span class="built_in">rdbuf</span> ();<span class="comment">//save old buf</span></span><br><span class="line">cin. <span class="built_in">rdbuf</span> ( in. <span class="built_in">rdbuf</span> ());<span class="comment">//redirect cin to in. txt !</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span> <span class="params">(<span class="string">&quot; out. txt &quot;</span>)</span></span>;</span><br><span class="line">streambuf * coutbuf = cout. <span class="built_in">rdbuf</span> (); <span class="comment">//save old buf</span></span><br><span class="line">cout. <span class="built_in">rdbuf</span> ( out. <span class="built_in">rdbuf</span> ()); <span class="comment">//redirect cout to out. txt !</span></span><br><span class="line">string word;</span><br><span class="line">cin &gt;&gt; word; <span class="comment">//input from the file in. txt </span></span><br><span class="line">cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//output to the file out. txt</span></span><br><span class="line">cin. <span class="built_in">rdbuf</span> ( cinbuf );<span class="comment">//reset to standard input again</span></span><br><span class="line">cout. <span class="built_in">rdbuf</span> ( coutbuf ); <span class="comment">//reset to standard output again</span></span><br><span class="line">cin &gt;&gt; word; <span class="comment">//input from the standard input</span></span><br><span class="line">cout &lt;&lt; word; <span class="comment">//output to the standard input</span></span><br></pre></td></tr></table></figure><h2 id="I-x2F-O处理"><a href="#I-x2F-O处理" class="headerlink" title="I&#x2F;O处理"></a>I&#x2F;O处理</h2><p>对输出操作符&lt;&lt;进行重载，只能采用友元函数的形式进行，而不能将operator&lt;&lt;()申明为ostream类的成员函数。这是因为<strong>ostream是在C++标准中定义的类，不允许用户随便修改。</strong>所以，要将类someClass的对象输出到标准输出对象，只能采用将operator&lt;&lt;()重载为全局函数，申明为someClass类的友元的形式进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp;, CPoint2D &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数：传入一个ostream对象和一个自定义对象</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint2D&amp; a)&#123;<span class="comment">//引用类型保证能连续输出</span></span><br><span class="line">    out &lt;&lt; a.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.y &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">CPoint2D a;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;   <span class="type">double</span> z;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">CPoint3D b;</span><br><span class="line">cout &lt;&lt; b;<span class="comment">//只显示b.x和b.y，而没显示b.z</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;   <span class="type">double</span> z;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;, CPoint3D &amp;);</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint3D &amp; b)&#123;</span><br><span class="line">    out &lt;&lt; b.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b.y &lt;&lt;<span class="string">&quot;,&quot;</span>  &lt;&lt; b.z &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题:3D对象被2D指针指向，cout调用了2D的版本，解决:虚化</span></span><br></pre></td></tr></table></figure><p>虚化：<strong>虚化非成员函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span></span><br><span class="line">&#123;       <span class="type">double</span>  x,  y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">         …</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span></span><br><span class="line"><span class="function">  </span>&#123;   out &lt;&lt; x &lt;&lt; ‘,’ &lt;&lt; y &lt;&lt; endl;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 针对基类进行操作符重载</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint2D &amp;a)</span><br><span class="line">&#123; </span><br><span class="line">    a.<span class="built_in">display</span>(out); <span class="comment">// 调用方法，虚函数，调用实际类型</span></span><br><span class="line"> <span class="keyword">return</span> out;  </span><br><span class="line">    <span class="comment">// 和虚函数的作用一样 -- 让一个全局函数针对不同派生类型，进行不同处理，定义一个</span></span><br><span class="line">    <span class="comment">// 虚函数，直接调用对象的虚函数，全局函数是一个非虚接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;      <span class="type">double</span>  z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       …</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span></span><br><span class="line"><span class="function">       </span>&#123;    CPoint2D::<span class="built_in">display</span>();   out &lt;&lt; ‘,’&lt;&lt; z &lt;&lt; endl;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="虚拟化构造器"><a href="#虚拟化构造器" class="headerlink" title="虚拟化构造器"></a>虚拟化构造器</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671518786205-45aafc9c-58fe-4857-81b2-efe92d6759ff.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671518008925-3dcf432c-0365-4c46-90d5-af4df1deef5a.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> :<span class="keyword">public</span> NLComponent &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span> :<span class="keyword">public</span> NLComponent &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsLetter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NewsLetter</span>(istream&amp; str)&#123;</span><br><span class="line">            <span class="keyword">while</span> (str)</span><br><span class="line">                components.<span class="built_in">push_back</span>(<span class="built_in">readComponent</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> NLComponent * <span class="title">readComponent</span><span class="params">(istream&amp; str)</span></span>;</span><br><span class="line">        <span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">            <span class="keyword">for</span> (list&lt;NLComponent *&gt;::iterator it=rhs.component.<span class="built_in">begin</span>();it != rhs.component.<span class="built_in">end</span>(); ++it )</span><br><span class="line">                <span class="comment">//期望有一个虚函数可以拷贝自己，不希望进行的是浅拷贝</span></span><br><span class="line">                component.<span class="built_in">push_back</span>();<span class="comment">//new TextBlock? Graphic?</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    list&lt;NLComponent *&gt; components;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚化构造器，因为构造函数不能是虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> NLComponent *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，代表一个接口</span></span><br><span class="line"><span class="comment">//原型模式:添加clone，使得构造也具有多态的行为</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> TextBlock *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="comment">// 构造器本身是一个成员函数，不需要全局</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Graphic  *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>( <span class="type">const</span> NewsLetter&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">for</span> ( list&lt;NLComponent *&gt;::iterator it=rhs.component.<span class="built_in">begin</span>();</span><br><span class="line">it != rhs.component.<span class="built_in">end</span>(); ++it )</span><br><span class="line">        component.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//typeid(*it)==typeid(TextBlock)判断对象的类型，必须带有虚函数。</span></span><br><span class="line"><span class="comment">// 如果不带有虚函数，只会得到参数的类型。所以可以创建一个虚的构造器RTTI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Question</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BalancedBST</span>: <span class="keyword">public</span> BST &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s, <span class="type">const</span> BST array[], <span class="type">int</span> numElements)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; numElements; i++)</span><br><span class="line">        s &lt;&lt; array[i];</span><br><span class="line">&#125;</span><br><span class="line">BalancedBST bBSTArray[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, bBSTArray, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//问题是?array[i]是指针算法的缩写，数组每次偏移地址是sizeof(BST)，而不是sizeof(BalancedBST)，会出现问题。</span></span><br></pre></td></tr></table></figure><h2 id="C11新特性"><a href="#C11新特性" class="headerlink" title="C11新特性"></a>C11新特性</h2><h3 id="右值引用-R-value-Reference"><a href="#右值引用-R-value-Reference" class="headerlink" title="右值引用 R-value Reference"></a>右值引用 R-value Reference</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671519743559-e08d485b-3a47-4c56-8c84-55f393bfeebf.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671519795433-41c05e6d-f488-402f-bb9d-197fea72ce58.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671519968056-838be8bd-a365-4e98-8e75-766b2c047593.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> *arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyArray</span>():<span class="built_in">size</span>(<span class="number">0</span>),<span class="built_in">arr</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">int</span> sz):</span><br><span class="line">        <span class="built_in">size</span>(sz),<span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[sz]) &#123;</span><br><span class="line">        <span class="comment">//init array here…</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp;other):</span><br><span class="line">        <span class="built_in">size</span>(other.size), </span><br><span class="line">        <span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = other.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//main函数中第三种声明方式的移动构造</span></span><br><span class="line">    <span class="built_in">MyArray</span> (MyArray &amp;&amp;other):</span><br><span class="line">        <span class="built_in">size</span>(other.size), <span class="built_in">arr</span>(other.arr) &#123;</span><br><span class="line">        other.arr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ <span class="built_in">MyArray</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MyArray <span class="title">change_aw</span><span class="params">(<span class="type">const</span> MyArray &amp;other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">aw</span><span class="params">(other.get_size())</span></span>;</span><br><span class="line">    <span class="comment">//Do some change to aw.</span></span><br><span class="line">    <span class="comment">//….</span></span><br><span class="line">    <span class="keyword">return</span> aw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">myArr</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    MyArray myArr2 = <span class="built_in">change_aw</span>(myArr);<span class="comment">//调用了两次拷贝，先将myArr传入的时候进行一次拷贝，返回之后再次进行拷贝，比较大的开销</span></span><br><span class="line">    MyArray &amp;&amp;myArr2 = <span class="built_in">change_aw</span>(myArr);<span class="comment">//右值函数，直接用移动构造函数，右值引用造成的维护困难</span></span><br><span class="line">    MyArray myArr2 = <span class="built_in">change_aw</span>(myArr);<span class="comment">//有了新的移动构造函数,自动适配，15min，提高拷贝速度在C++中使用移动构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    MyArray &amp;<span class="keyword">operator</span>=(<span class="type">const</span></span><br><span class="line">        MyArray &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr) &#123;<span class="keyword">delete</span>[] arr;arr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = other.size;</span><br><span class="line">        <span class="built_in">memcpy</span>(arr, other.arr, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyArray &amp;<span class="keyword">operator</span>=(ArrayWrapper &amp;&amp;other) &#123; <span class="comment">// 匹配移动赋值操作符的重载</span></span><br><span class="line">        size = other.size;</span><br><span class="line">        arr = other.arr;</span><br><span class="line">        other.arr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">// 赋值操作符重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyArray myArr;</span><br><span class="line">    myArr = <span class="built_in">MyArr</span>(<span class="number">5</span>);<span class="comment">//MyArr是临时对象，无法直接进行使用，可以直接移动过去。19min的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝构造、拷贝赋值、移动构造、移动赋值、析构函数<br />重定义其中一个，另外四个都不再默认生成</p><h3 id="外部模板-Extern-Templates"><a href="#外部模板-Extern-Templates" class="headerlink" title="外部模板 Extern Templates"></a>外部模板 Extern Templates</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myfunc.h</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">myfunc</span><span class="params">(T t)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfunc.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">myfunc</span>(<span class="number">1</span>); <span class="comment">// 在链接的过程中，会进行实例化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfunc.h&quot;</span></span></span><br><span class="line"><span class="comment">//如果没有以下的模板，那么编译器会先去实例化模板，新的方式外部模板可以避免多次实例化的问题</span></span><br><span class="line"><span class="comment">/*Tell compiler: this instance has been</span></span><br><span class="line"><span class="comment">instantiated in another module!*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">myfunc</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>); <span class="comment">// 已经被实例化了且会被链接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myfunc</span>(<span class="number">1</span>); <span class="comment">// 就不会重复实例化了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量表达式-Constant-Expression"><a href="#常量表达式-Constant-Expression" class="headerlink" title="常量表达式 Constant Expression"></a>常量表达式 Constant Expression</h3><ol><li><p>提供了更一般的常量表达式</p></li><li><p>允许常量表达式使用用户自定义类型</p></li><li><p>提供一种方法来确保在编译时完成初始化</p></li><li><p><strong>必须在编译的时候可以确定常量表达式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Flags</span> &#123; GOOD=<span class="number">0</span>, FAIL=<span class="number">1</span>, BAD=<span class="number">2</span>, EOF=<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="keyword">operator</span>| (Flags f1, Flags f2)  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Flags</span>(<span class="built_in">int</span>(f1)|<span class="built_in">int</span>(f2));</span><br><span class="line">&#125;<span class="comment">//如果不加constexpr则结果被认为是变量不能使用在case中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Flags x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> BAD: <span class="comment">/* ... */</span><span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EOF: <span class="comment">/* ... */</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BAD|EOF: <span class="comment">/* ... */</span> <span class="keyword">break</span>;<span class="comment">//OK，必须是简单的确认的值</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* ... */</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Flags x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">bad_c</span><span class="params">()</span>: /* ... */break;</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">eof_c</span><span class="params">()</span>: /* ... */ break;</span></span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">be_c</span><span class="params">()</span>: /* ... */ break;</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* ... */</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">bad_c</span><span class="params">()</span></span>; <span class="comment">// 只要函数的返回值永远是一个常量</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">eof_c</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">be_c</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">int</span> xx, <span class="type">int</span> yy)</span> : x(xx), y(yy) &#123;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// const对象 -- 对象是不能通过接口修改的</span></span><br><span class="line">    <span class="comment">// constexpr -- 对象的值是可以在编译时确定的，同时也是一个const</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Point <span class="title">origo</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="comment">//完全常量，在常量表上</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> z = origo.x;</span><br><span class="line"><span class="comment">// 相当于对象都是一组值，不需要重复开辟空间</span></span><br><span class="line">    <span class="keyword">constexpr</span> Point a[] = &#123;<span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">Point</span>(<span class="number">1</span>,<span class="number">1</span>), <span class="built_in">Point</span>(<span class="number">2</span>,<span class="number">2</span>) &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> x = a[<span class="number">1</span>].x; <span class="comment">// x becomes 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所有评估都可以在编译时完成，所有对象都可以看做一组值。 因此，提高了运行时间效率。</p></li><li><p>编译时确定的</p></li></ol><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpInt</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CmpInt</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125; <span class="comment">// 函数调用操作符重载</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; items &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), cmpInt); <span class="comment">//Function Pointer 函数指针</span></span><br><span class="line">    std::<span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), <span class="built_in">CmpInt</span>()); <span class="comment">//Function Object (Functor) 函数对象</span></span><br><span class="line">    std::<span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), <span class="comment">// [] 代表 lambda函数</span></span><br><span class="line">        [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125; <span class="comment">//Lambda Function</span></span><br><span class="line">    );  <span class="comment">// 实例化成std::function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">comp</span>(*it1, *it2) )</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::function 是C++对所有可调用的函数的封装：使用函数、函数对象、lambda函数</span></span><br><span class="line"><span class="function">std::function&lt;<span class="title">bool</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">f1</span><span class="params">(cmpInt)</span></span>;</span><br><span class="line"><span class="function">std::function&lt;<span class="title">bool</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">f2</span><span class="params">(CmpInt)</span></span>;</span><br><span class="line"><span class="function">std::function&lt;<span class="title">bool</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">f3</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b;&#125; )</span></span>;</span><br><span class="line"><span class="comment">// 1.不需要特别实例化   2.lambda表达式可以统一实例化为std::function对象</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">str_filter</span><span class="params">(vector&lt;string&gt; &amp;vec, function&lt;<span class="type">bool</span>(string &amp;)&gt; matched)</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (string tmp : vec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">matched</span>(tmp))</span><br><span class="line">            result.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以会用局部变量，40min</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec = &#123;<span class="string">&quot;www.baidu.com&quot;</span>, <span class="string">&quot;www.kernel.org&quot;</span>, <span class="string">&quot;www.google.com&quot;</span>&#125;;</span><br><span class="line">    string pattern = <span class="string">&quot;.com&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; filterd = <span class="built_in">str_filter</span>(vec,</span><br><span class="line">        [&amp;](string &amp;str) &#123;  <span class="comment">// [&amp;]:以引用的方式，捕获有效变量，不需要传入新的参数</span></span><br><span class="line">            <span class="keyword">if</span> (str.<span class="built_in">find</span>(pattern) != string::npos) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>符号</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>[]</td><td>Capture nothing</td></tr><tr><td>[&amp;]</td><td>Capture any referenced variable by reference</td></tr><tr><td>[&#x3D;]</td><td>Capture any referenced variable by making a copy 以值拷贝的方式传入，不会产生副作用</td></tr><tr><td>[&#x3D;, &amp;foo]</td><td>Capture any referenced variable by making a copy, but capture variable foo by reference</td></tr><tr><td>[bar]</td><td>Capture bar by making a copy; don’t copy anything else</td></tr></tbody></table><h3 id="Delegating-Constructor-委托构造函数"><a href="#Delegating-Constructor-委托构造函数" class="headerlink" title="Delegating Constructor 委托构造函数"></a>Delegating Constructor 委托构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 256</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">validate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">if</span> (<span class="number">0</span>&lt;x &amp;&amp; x&lt;=MAX) a=x; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">bad_X</span>(x); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> x) &#123; <span class="built_in">validate</span>(x); &#125;</span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">validate</span>(<span class="number">42</span>); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> x) &#123; <span class="keyword">if</span> (<span class="number">0</span>&lt;x &amp;&amp; x&lt;=max) a=x; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">bad_X</span>(x); &#125;</span><br><span class="line">    <span class="built_in">X</span>() :<span class="built_in">X</span>(<span class="number">42</span>) &#123; &#125; <span class="comment">// 在一个构造函数中，委托另外一个构造函数。默认构造函数可以委托另外一个构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">X</span>(<span class="type">int</span> x = <span class="number">42</span>) ? <span class="comment">// 默认参数是有参数的，和无参默认构造函数是不同的</span></span><br></pre></td></tr></table></figure><h3 id="Uniform-Initialization-统一初始化"><a href="#Uniform-Initialization-统一初始化" class="headerlink" title="Uniform Initialization 统一初始化"></a>Uniform Initialization 统一初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Old style initialization</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//…</span></span><br><span class="line"><span class="comment">//New style initialization</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//Compiler will translate &#123;&#125; as initializer_list&lt;int&gt; 新的初始化表</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">vector</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="built_in">vector</span>(initializer_list&lt;T&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            <span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//OK</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line">A a= &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="comment">//Default generated by compiler</span></span><br><span class="line">    <span class="built_in">A</span>(initializer_list&lt;<span class="type">int</span>&gt; list) &#123; <span class="comment">// 接受初始化列表参数</span></span><br><span class="line">        <span class="keyword">auto</span> it = list.<span class="built_in">begin</span>();</span><br><span class="line">        x = *it++;</span><br><span class="line">        y = *it++;</span><br><span class="line">        z = *it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Uniform Initialization achieved!</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">A  a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 都可以通过初始化列表的方式进行初始化</span></span><br></pre></td></tr></table></figure><h3 id="nullptr-空指针"><a href="#nullptr-空指针" class="headerlink" title="nullptr 空指针"></a>nullptr 空指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//f(0) 两者都可以解释</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版本</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);         <span class="comment">// call f(int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);   <span class="comment">// call f(char*)</span></span><br><span class="line"><span class="comment">// 原来的NULL就是0</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">// call f(int)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 课程内容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常量指针和指针常量</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在C++学习使用过程中，每个人都不可避免地使用指针，而且都或多或少的接触过常量指针或指针常量，但是对这两个概念还是很容易搞糊涂的。<br />本文即是简单描述指针常量和常量指针的区别。</p><h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><p>定义：<br /><del>又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。</del><br />通俗理解：<strong>指向常量</strong>（定语）的指针（主语）。</p><ol><li>指向常量：代表不能通过该指针来修改对应对象的值</li><li>但是可以通过原来的声明修改相应的值</li><li><strong>指针是一个变量</strong></li></ol><p>关键点：</p><ol><li>常量指针指向的对象不能通过这个指针来修改，可是<strong>仍然可以通过原来的声明修改</strong>；</li><li>常量指针可以被赋值为变量的地址，之所以叫常量指针，是<strong>限制了通过这个指针修改变量的值</strong>；</li><li>指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；</li></ol><p>代码形式：<br /><code>int const* p;  const int* p;</code></p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>** <strong>定义：<br />~~本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。 ~~<br />通俗理解：是一个指针（定语）的常量（主语）。根据定语表示性质可知，该常量是一个指针，而常量代表着值无法改变，也就是说</strong>指针的值无法改变<strong>，也就是</strong>指针指向的地址不能变化<strong>。但是</strong>指向的地址所对应的内容可以变化。**<br />关键点：</p><ol><li>它是个常量</li><li>指针本身是常量，指向的地址不可以变化,但是<strong>指向的地址所对应的内容可以变化</strong>；</li></ol><p>代码形式：<br /> <code>int* const p;</code></p><h2 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a>指向常量的常指针</h2><p>定义：<br />指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。<br />关键点：<br />1.一个指针常量，指向的是一个指针对象；<br />2.它指向的指针对象且是一个常量，即它指向的对象不能变化；<br />代码形式：<br /><code>const int* const p;</code></p><h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><p>那如何区分这几类呢? 带两个const的肯定是指向常量的常指针，很容易理解，主要是如何区分常量指针和指针常量:<br />一种方式是看** * 和 const 的排列顺序<em><em>，比如<br />     int const</em> p; &#x2F;&#x2F;const * 即常量指针<br />     const int</em> p; &#x2F;&#x2F;const * 即常量指针<br />     int* const p; &#x2F;&#x2F;* const 即指针常量<br />还一种方式是<strong>看const离谁近，即从右往左看</strong>，比如<br />     int const* p; &#x2F;&#x2F;const修饰的是<em>p，即</em>p的内容不可通过p改变，但p不是const，p可以修改，<em>p不可修改；<br />     const int</em> p; &#x2F;&#x2F;同上<br />     int* const p; &#x2F;&#x2F;const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------常量指针-------</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;a;</span><br><span class="line">a = <span class="number">300</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="comment">//*p1 = 56;  //Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针常量-------//</span></span><br><span class="line"><span class="type">int</span>*  <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line"><span class="comment">//p2 = &amp;b;     //Error,因为p2是const 指针，因此不能改变p2指向的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指向常量的常量指针-------//</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//*p3 = 1;    //Error</span></span><br><span class="line"><span class="comment">//p3 = &amp;b;    //Error</span></span><br><span class="line">a = <span class="number">5000</span>;    <span class="comment">//OK,仍然可以通过原来的声明修改值</span></span><br></pre></td></tr></table></figure><p><strong>常量指针中的值不可以通过指针修改，但是可以通过原来的声明修改</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">const</span> <span class="type">int</span>  x = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//    int * p1 = &amp;x;</span></span><br><span class="line"><span class="comment">// Cannot initialize a variable of type &#x27;int *&#x27; with an rvalue of type &#x27;const int *&#x27;</span></span><br></pre></td></tr></table></figure><p><code>**const**</code><strong>本身也是一个类型，因此必须要用</strong><code>**const int ***</code><strong>常量指针来指向，而不能用普通的指针</strong><br />在实际应用中，常量指针要比指针常量用的多，比如常量指针经常用在函数传参中，以避免函数内部修改内容。<br />size_t strlen(const char* src); &#x2F;&#x2F;常量指针，src的值不可改变；<br />char a[] &#x3D; “hello”;<br />char b[] &#x3D; “world”;<br />size_t a1 &#x3D; strlen(a);<br />size_t b1 &#x3D; strlen(b);<br />虽然a、b是可以修改的，但是可以保证在strlen函数内部不会修改a、b的内容。</p><h2 id="指针问题"><a href="#指针问题" class="headerlink" title="指针问题"></a>指针问题</h2><p>既然讲到了指针，那顺便说一下空指针、野指针的问题。<br />空指针就是保存地址为空的指针，使用指针时必须先判断是否空指针，很多问题都是这一步导致的。<br />野指针是在delete掉指针之后，没有置0，导致指针随意指向了一个内存地址，如果继续使用，会造成不可预知的内存错误。<br />另外指针的误用很容易造成BUG或者内存泄漏。<br />看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------空指针-------//</span></span><br><span class="line"><span class="type">int</span> *p4 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;,*p4); //运行Error，使用指针时必须先判断是否空指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------野指针（悬浮、迷途指针）-------//</span></span><br><span class="line"><span class="type">int</span> *p5 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">delete</span> p5;</span><br><span class="line">p5 = <span class="literal">NULL</span>; <span class="comment">//一定要有这一步</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p5);  <span class="comment">//隐藏bug，delete掉指针后一定要置0，不然指针指向位置不可控，运行中可导致系统挂掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针的内存泄漏-------//</span></span><br><span class="line"><span class="type">int</span> *p6 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">6</span>);</span><br><span class="line">p6 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">7</span>); <span class="comment">//p6原本指向的那块内存尚未释放，结果p6又指向了别处，原来new的内存无法访问，也无法delete了，造成memory leak</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拷贝构造函数和操作符=的重载</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6=%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6=%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>首先要说明的是，若用户没有定义，C++隐式声明一个拷贝构造函数和一个赋值运算符（完成按数据成员复制的动作）。二者很像，但是在下边这点上有很大的不同：<br />拷贝构造函数是只在<strong>对象实例化时</strong>才会被调用，也就是说，在拷贝构造函数调用期间，这个对象处于一个未决状态（直到拷贝构造函数被成功调用），另外拷贝构造函数不返回任何值，void都没有。<br /><a href="https://so.csdn.net/so/search?q=%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">拷贝构造函数</a>应用的场合由以下几个方面：<br />1 函数的参数是一个对象，并且是值传递方式<br />2 函数的返回值是一个对象，并且是值传递方式<br />3 用一个对象初始化另外一个对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>()</span><br><span class="line">        &#123;   </span><br><span class="line">            ctor_count++;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;ctor &quot;</span>&lt;&lt;ctor_count&lt;&lt;endl;</span><br><span class="line">        &#125;   </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">const</span> Test &amp; r)</span><br><span class="line">        &#123;   </span><br><span class="line">            ctor_count++;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;copy ctor &quot;</span>&lt;&lt;ctor_count&lt;&lt;endl;</span><br><span class="line">        &#125;   </span><br><span class="line"> </span><br><span class="line">        Test &amp; <span class="keyword">operator</span>= (<span class="type">const</span> Test&amp; r)</span><br><span class="line">        &#123;   </span><br><span class="line">            ctor_count++;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;assignment op &quot;</span>&lt;&lt;ctor_count&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> ctor_count; <span class="comment">//only a declaration</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> Test::ctor_count=<span class="number">0</span>; <span class="comment">// definition + initialization</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    Test test1=test;</span><br><span class="line">    <span class="function">Test <span class="title">test2</span><span class="params">(test)</span></span>;</span><br><span class="line">    Test test3=test2=test1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <br />输出结果<br />[root@xxx]$ .&#x2F;a.out<br />ctor 1<br />copy ctor 2<br />copy ctor 3<br />assignment op 4<br />copy ctor 5</p><p>我们看到：<br />Test test; &#x2F;&#x2F;实例化test对象时调用了默认构造函数<br />Test test1&#x3D;test;&#x2F;&#x2F; test1使用了拷贝构造函数（因为这是一个新的对象产生）<br />Test test2(test);&#x2F;&#x2F;test2时也是用了拷贝构造函数，<br />Test test3&#x3D;<strong>test2&#x3D;test1;</strong>&#x2F;&#x2F;而test2&#x3D;test1则使用了<strong>操作符重载</strong>（没有新的对象产生），<br />Test <strong>test3&#x3D;test2</strong>&#x3D;test1;&#x2F;&#x2F;test3&#x3D;test2则使用了<strong>拷贝构造函数</strong>，原因同上。</p><p>所以要看<strong>是不是有新的对象产生，才能决定到底是调用了拷贝构造函数，还是赋值运算符。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>继承时的名空间隐藏、重载、覆盖</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%BB%A7%E6%89%BF%E6%97%B6%E7%9A%84%E5%90%8D%E7%A9%BA%E9%97%B4%E9%9A%90%E8%97%8F%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%BB%A7%E6%89%BF%E6%97%B6%E7%9A%84%E5%90%8D%E7%A9%BA%E9%97%B4%E9%9A%90%E8%97%8F%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<h3 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h3><p>隐藏：子类对象优先考虑子类域自身成员（成员变量和成员函数）<br /> 　　隐藏发生的主要原因，就是当子类有父类的<strong>同名成员</strong>时，子类对象访问该成员时，会发生冲突。所以编译器的处理方式是，<strong>优先考虑子类域中的自身成员。</strong><br />即，子类对象访问某成员时，如ch.m_m 或者ch.f(),成员变量和成员函数都一样。编译器首先在子类域中检索，如果在子类域中找到该成员，则检索结束，返回该成员进行访问。如果在子类域中找不到该成员，则去父类域中检索。如果父类域中存在，则返回该成员进行访问，如果父类域中也不存在，则编译错误，该成员无效。<br />　**　当父子类域都存在同一成员时，编译器优先在子类中检索<strong>，就算父类域中也存在该同名成员，也不会被检索到。因此，</strong>父类域中的该成员被子类域中的该同名成员隐藏，即访问时完全以为该成员不存在，如果想访问父类域中的该成员，只能通过显示调用的方式，即：ch.Father::m_m;**</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> f_a;</span><br><span class="line">    <span class="type">int</span> f_b;</span><br><span class="line">string f_c;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ff1</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;father ff1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Childer</span>:<span class="keyword">public</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> c_a;</span><br><span class="line">    <span class="type">int</span> f_b;</span><br><span class="line"><span class="type">int</span> f_c;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cf1</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;childer cf1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ff1</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;childer ff1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Childer ch;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ch.c_a&lt;&lt;endl; <span class="comment">//只在子类域中的成员变量</span></span><br><span class="line">    cout&lt;&lt;ch.f_b&lt;&lt;endl; <span class="comment">//子类域和父类域都存在，优先访问子类域中的</span></span><br><span class="line">    cout&lt;&lt;ch.Father::f_b&lt;&lt;endl; <span class="comment">//显示访问被隐藏的成员变量</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;====================\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ch.<span class="built_in">cf1</span>();</span><br><span class="line">    ch.<span class="built_in">ff1</span>();</span><br><span class="line">    ch.Father::<span class="built_in">ff1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>ch</code>无法访问父类的<code>f_b</code>和<code>f_c</code>。说明：名空间的隐藏只在乎<strong>名字是否相同，而不在乎类型是否相同</strong></li><li><code>ch.Father::ff1();</code>必须通过显式调用才能访问到。说明：只是<strong>隐藏了，看不到了，而不代表没有</strong></li></ol><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载：<strong>相同域的同名不同参函数</strong><br />　　重载必须是发生在<strong>同一个域</strong>中的两个<strong>同名不同形参</strong>之间的。如果一个在父类域一个在子类域，是不会存在重载的，属于隐藏的情况。调用时，只会在子类域中搜索，如果形参不符合，会认为没有该函数，而不会去父类域中搜索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">double</span> i)</span></span>;<span class="comment">//overload</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> j)</span></span>;<span class="comment">//overload</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">double</span> i, <span class="type">int</span> j)</span></span>;<span class="comment">//overload</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span></span>;         <span class="comment">//错误，非重载。注意重载不关心函数返回类型。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">10</span>;<span class="comment">//id在Undergraduated_Student中仍然是私有的，默认权限位private</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123; <span class="built_in">strcpy</span>(nickname, s); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> nickname[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_ID</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; id = x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; nickname &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;getId&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// 通过继承基类的公有方法访问到基类的私有变量</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> y = <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span> : <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="type">int</span> dept_no&#123;&#125;;<span class="comment">//学院编号</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; dept_no = x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    void showInfo()&#123;cout &lt;&lt; dept_no &lt;&lt; &quot;:&quot; &lt;&lt; nickname &lt;&lt; endl;&#125;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_ID</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;changed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// 对基类的函数进行覆盖，并修改了访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> Student::nickname;<span class="comment">//这样在才能修改可见性</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新定义了一个private方法，父类对应方法被隐藏</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Undergraduated_Student *us = <span class="keyword">new</span> Undergraduated_Student;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; us-&gt;y;</span></span><br><span class="line">    us-&gt;<span class="built_in">SetNickName</span>();</span><br><span class="line">    us-&gt;<span class="built_in">getId</span>();</span><br><span class="line"><span class="comment">//    us-&gt;showInfo(); 无法访问，通过隐藏父类的方法，修改了访问权限</span></span><br><span class="line">    us-&gt;Student::<span class="built_in">showInfo</span>(<span class="number">10</span>); <span class="comment">// 被隐藏了，但是可以显式的使用对应的名空间进行访问</span></span><br><span class="line"><span class="comment">//    us-&gt;showInfo(10); //error ,因为被子类的同名方法所隐藏了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2022/11/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">110</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;base in A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">1</span>)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; in B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;override in B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;overload_int&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;overload_double&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">C</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x = <span class="number">75</span>)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; in C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot; in C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">f1</span>();</span><br><span class="line">    b.<span class="built_in">f1</span>(<span class="number">10</span>);</span><br><span class="line">    b.<span class="built_in">f1</span>(<span class="number">100.5</span>);</span><br><span class="line">    b.A::<span class="built_in">f1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// override in B</span></span><br><span class="line"><span class="comment">// overload_int</span></span><br><span class="line"><span class="comment">// overload_double</span></span><br><span class="line"><span class="comment">// base in A</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>练习</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%BB%83%E4%B9%A0/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<ul><li><code>friend complex operator+(const complex &amp;A, const complex &amp;B) const;</code> 非成员函数不能是const，会报错<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;基类函数 fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    void fun1() &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; &quot;派生类函数 fun1&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">fun1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>10<br>基类函数 fun1</p></blockquote></li></ul><p>输出的<code>a</code>是基类名空间下的<code>a</code>，而不是派生类名空间下的<code>a</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;基类函数 fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;派生类函数 fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">fun1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>20<br>派生类函数 fun1</p></blockquote><p>因为在派生类中定义了相同名字的函数和变量，所以基类名空间下的被隐藏了</p><h3 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2023/2/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">complex</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line">    complex <span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;A) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="type">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>() : <span class="built_in">m_real</span>(<span class="number">0.0</span>), <span class="built_in">m_imag</span>(<span class="number">0.0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag) : <span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex complex::<span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;A) <span class="type">const</span> &#123;</span><br><span class="line">    complex B;</span><br><span class="line">    B.m_imag = <span class="keyword">this</span>-&gt;m_imag + A.m_imag;</span><br><span class="line">    B.m_real = <span class="keyword">this</span>-&gt;m_real + A.m_real;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; m_real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; m_imag &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function">complex <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    complex c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// construct</span></span><br><span class="line"><span class="comment">// construct</span></span><br><span class="line"><span class="comment">// deconstruct</span></span><br><span class="line"><span class="comment">// 6.7 + 9.5i</span></span><br><span class="line"><span class="comment">// deconstruct</span></span><br><span class="line"><span class="comment">// deconstruct</span></span><br><span class="line"><span class="comment">// deconstruct</span></span><br></pre></td></tr></table></figure><p>为什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 13467 on 2023/2/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">complex</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line"><span class="comment">//    complex operator+(const complex &amp;A) const;</span></span><br><span class="line">    <span class="keyword">friend</span> complex <span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;A, <span class="type">const</span> complex &amp;B);</span><br><span class="line"></span><br><span class="line">    complex <span class="keyword">operator</span> *(<span class="type">const</span> complex &amp;other)<span class="type">const</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="type">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>() : <span class="built_in">m_real</span>(<span class="number">0.0</span>), <span class="built_in">m_imag</span>(<span class="number">0.0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag) : <span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//complex complex::operator+(const complex &amp;A) const &#123;</span></span><br><span class="line"><span class="comment">//    complex B;</span></span><br><span class="line"><span class="comment">//    B.m_imag = this-&gt;m_imag + A.m_imag;</span></span><br><span class="line"><span class="comment">//    B.m_real = this-&gt;m_real + A.m_real;</span></span><br><span class="line"><span class="comment">//    return B;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>*(<span class="type">const</span> complex &amp;A) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="keyword">this</span>-&gt;m_real * A.m_real, <span class="keyword">this</span>-&gt;m_imag * A.m_imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;A, <span class="type">const</span> complex &amp;B) &#123;</span><br><span class="line">    complex C;</span><br><span class="line">    C.m_real = A.m_real + B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag + B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; m_real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; m_imag &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function">complex <span class="title">c2</span><span class="params">(<span class="number">1.0</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    complex c3;</span><br><span class="line">    c3 = c1 + c2 * c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">construct</span><br><span class="line">construct</span><br><span class="line">construct</span><br><span class="line">deconstruct</span><br><span class="line">deconstruct</span><br><span class="line"><span class="number">5.3</span> + <span class="number">19.49</span>i</span><br><span class="line">deconstruct</span><br><span class="line">deconstruct</span><br><span class="line">deconstruct</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Effective%20C++/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Effective%20C++/</url>
      
        <content type="html"><![CDATA[<ol start="33"><li><p><code>Avoid hiding inherited names</code>避免掩盖继承而来的名字</p></li><li><p><code>Never redefine an inherited non-virtual function</code>绝不重新定义继承而来的非虚函数</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    virtual </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C *pc = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">    B *pb = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">    A *pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">    pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">    C *pnull = <span class="literal">nullptr</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line">    pa-&gt;<span class="built_in">func</span>(); <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">    pc-&gt;<span class="built_in">func</span>(); <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">    pnull-&gt;<span class="built_in">func</span>(); <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="37"><li><code>Never redefine a function&#39;s inherited default parameter value</code>绝不重新定义继承而来的缺省参数值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;E::func()\t&quot;</span>&lt;&lt; i &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> : <span class="keyword">public</span> E</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;F::func()\t&quot;</span> &lt;&lt; i &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F* pf = <span class="keyword">new</span> <span class="built_in">F</span>();</span><br><span class="line">    E* pe = pf;</span><br><span class="line">    pf-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 1  正常，就该如此；</span></span><br><span class="line">    pe-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676269766535-c95849eb-027e-48bb-88da-7046516a74e2.png" alt="image.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态绑定和动态绑定</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<ol><li>静态绑定发生在编译期，动态绑定发生在运行期； </li><li>对象的动态类型可以更改，但是静态类型无法更改； </li><li>要想实现动态，必须使用动态绑定； </li><li>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</li></ol><p>建议：<br />绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用<strong>由对象声明时的静态类型确定</strong>了，而<strong>和对象本身脱离了关系</strong>，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    virtual </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C *pc = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">    B *pb = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">    A *pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">    pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">    C *pnull = <span class="literal">nullptr</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line">    pa-&gt;<span class="built_in">func</span>(); <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">    pc-&gt;<span class="built_in">func</span>(); <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">    pnull-&gt;<span class="built_in">func</span>(); <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">C *pc = <span class="keyword">new</span> <span class="built_in">C</span>(); </span><br><span class="line">B *pb = <span class="keyword">new</span> <span class="built_in">B</span>(); </span><br><span class="line">A *pa = pc;      </span><br><span class="line">pa = pb;         </span><br><span class="line">C *pnull = <span class="literal">nullptr</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>using 的使用</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/using%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/using%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-导入命名空间"><a href="#1-导入命名空间" class="headerlink" title="1. 导入命名空间"></a>1. 导入命名空间</h2><p>使用C++在写不同的功能模块时，为了防止命名冲突，建议对模块取命名空间，这样在使用时就需要指定是哪个命名空间。<br />使用 using 导入命名空间，即使一个命名空间中的所有名字都在该作用域中可见，常见的如下：<br />&#x2F;&#x2F; 导入整个命名空间到当前作用域 using namespace std; &#x2F;&#x2F; 只导入某个变量到当前作用域  using std::cout;  <br /><strong>在.h头文件中，一般不应该使用using声明。</strong><br />因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明，从而可能产生名字冲突。</p><h2 id="2-指定别名"><a href="#2-指定别名" class="headerlink" title="2. 指定别名"></a>2. 指定别名</h2><p>C++ 11 通过 using 指定别名，作用等同于 typedef，但相比 typedef，逻辑更直观，可读性更好。<br />typedef int T; &#x2F;&#x2F; 用 T 代替 int using T &#x3D; int; &#x2F;&#x2F; 用 T 代替 int </p><h2 id="3-在派生类中引用基类成员"><a href="#3-在派生类中引用基类成员" class="headerlink" title="3. 在派生类中引用基类成员"></a>3. 在派生类中引用基类成员</h2><p>但是：<br /><code>private</code>变量不能通过<code>using</code>获得<br /><code>using</code>的使用更像是配合<code>private</code>继承来使用，通过基类的<code>public</code>来暴露接口。<br />代码如下：<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676978836927-6bb01102-9146-4096-af88-b5a8cbadf1cb.webp"><br>如上图代码所示，尽管派生类 Derived 对 基类 Base 是私有继承，但通过 using 声明，派生类的对象就可以访问基类的 proteced 成员变量和 public 成员函数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;array&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;dis1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;dis2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>:<span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::dis1;<span class="comment">//需要在BaseA的public下释放才能对外使用，</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis2show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">dis2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    BaseA ba;</span><br><span class="line">    ba.<span class="built_in">dis1</span>();</span><br><span class="line">    ba.<span class="built_in">dis2show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：using只是引用，不参与形参的指定。</strong></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first name space</span></span><br><span class="line"><span class="keyword">namespace</span> first_space &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// second name space</span></span><br><span class="line">    <span class="keyword">namespace</span> second_space &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> first_space::second_space;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This calls function from second name space.</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by DELL on 2023/2/21.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A::<span class="built_in">f</span>();</span><br><span class="line">    B::<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1213</span></span><br><span class="line">-------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A::<span class="built_in">f</span>();</span><br><span class="line">    B::<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line">-------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A::<span class="built_in">f</span>();</span><br><span class="line">    B::<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> B::f;; <span class="comment">// no error</span></span><br><span class="line">    <span class="built_in">f</span>(); </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">//why 2?</span></span><br><span class="line">    <span class="comment">// 12122</span></span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> B::f;; <span class="comment">// no error</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">//</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="comment">// 222</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 如果是B::f，那就是特殊引用，所以就不会再次被覆盖了，如果是全部的，就会被特殊引用被覆盖<br /> <strong>一般引用可以被特殊引用覆盖，但是不能被另外的一般引用覆盖；特殊引用不可以被另外的特殊引用覆盖（会报错），不会被另外的一般引用覆盖（无报错），相当于重新引用了一般引用。但是还可以使用B::f</strong><br /> </p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数重载匹配顺序问题</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8C%B9%E9%85%8D%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8C%B9%E9%85%8D%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="最佳匹配原则"><a href="#最佳匹配原则" class="headerlink" title="最佳匹配原则"></a><strong>最佳匹配原则</strong></h2><p>一般来说，精确匹配肯定比需要类型转换的匹配要更好，但是当形参有多个，并且无法完全精确匹配的时候，要确定最佳匹配函数就有点困难了。<br />但是有下面的原则：</p><ul><li>函数的每个实参的匹配都不能比其他可行函数更差</li><li>函数至少有一个实参的匹配要比其他可行函数更好</li></ul><p>那么问题又来了，什么是更好，什么又是更差呢？编译器将实参类型到形参类型的转换划分了等级：</p><ul><li>精确匹配，包括实参类型和形参类型相同，实参从数组或函数转换成对应的指针类型，向实参添加顶层const或从实参删除顶层const</li><li>通过const转换实现的匹配</li><li>通过类型提升实现的匹配</li><li>通过算数类型转换实现的匹配</li><li>通过类类型转换实现的匹配</li></ul><h2 id="最佳匹配原则-1"><a href="#最佳匹配原则-1" class="headerlink" title="最佳匹配原则"></a><strong>最佳匹配原则</strong></h2><p>一般来说，精确匹配肯定比需要类型转换的匹配要更好，但是当形参有多个，并且无法完全精确匹配的时候，要确定最佳匹配函数就有点困难了。<br />但是有下面的原则：</p><ul><li>函数的<strong>每个实参</strong>的匹配都不能比其他可行函数更差</li><li>函数<strong>至少有一个实参</strong>的匹配要比其他可行函数更好</li></ul><p>那么问题又来了，什么是更好，什么又是更差呢？编译器将实参类型到形参类型的转换划分了等级：</p><ul><li><strong>精确匹配</strong>，包括实参类型和形参类型相同，实参从数组或函数转换成对应的指针类型，向实参添加顶层const或从实参删除顶层const</li><li>通过<strong>const转换</strong>实现的匹配</li><li>通过<strong>类型提升</strong>实现的匹配</li><li>通过<strong>算数类型转换</strong>实现的匹配</li><li>通过<strong>类类型转换</strong>实现的匹配</li></ul><p>等级越前，匹配也就越好</p><h2 id="通过const转换实现的匹配"><a href="#通过const转换实现的匹配" class="headerlink" title="通过const转换实现的匹配"></a><strong>通过const转换实现的匹配</strong></h2><p>所谓通过const转换实现的匹配，指的是通过加const限定词，能够与可行函数精确匹配。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int f(string &amp;a)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;call function 1&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">const</span> string &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call function 2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string test = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="built_in">f</span>(test);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，test可以通过const转换，从而匹配函数2，将能够找到最佳匹配函数2（当前情况它也只有一个可选了）。<br />运行结果如下：<br /><code>call function 2</code>                                    <br />如果把函数1的注释去掉再运行，就会发现，虽然第一个调用既能匹配函数1，也能匹配函数2，但是由于匹配函数2的时候，需要const转换，因此比精确匹配要差，最终，它会调用函数1。<br />去掉函数1的注释后，运行结果如下：<br /><code>call function 1</code>                                       </p><h2 id="通过类型提升实现的匹配"><a href="#通过类型提升实现的匹配" class="headerlink" title="通过类型提升实现的匹配"></a><strong>通过类型提升实现的匹配</strong></h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676996152512-8feeb0a4-f035-4300-b3a7-4ae320476f43.png" alt="image.png"><br>关于类型提升，这里不多做介绍。简单说明类型提升规则：</p><ul><li>float将提升到double</li><li>char、short和相应的signed、unsigned类型将提升到int</li></ul><p>我们来看一个示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int f(short a)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;call function 1&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call function 2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">short</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，我们暂时把函数1注释掉。由于a是short类型，但是通过类型提升，可以转换为int，因为它也能调用函数2。运行结果如下：<br /><code>call function 2</code> <br />但去掉函数1注释后，由于精确匹配优于通过类型提升的匹配，因此将会调用函数1，运行结果如下：<br /><code>call function 1</code></p><h2 id="通过算术类型转换实现的匹配"><a href="#通过算术类型转换实现的匹配" class="headerlink" title="通过算术类型转换实现的匹配"></a><strong>通过算术类型转换实现的匹配</strong></h2><p>short int和float，double等之间的转换，都是算术类型之间的转换。我们仍然来看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call function 1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call function 2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">short</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，short类型的a既可以通过<strong>类型提升转换为int</strong>，也可以通过<strong>算术类型转换成为double</strong>。这个时候，哪个才是最佳匹配呢？我们看运行结果：<br /><code>call function 1</code> <br />对于这个结果，并不意外，因为前面我们已经说到，<strong>通过类型提升的转换是优于算术转换的</strong>，因而函数1是它的最佳匹配函数。</p><h2 id="二义性示例"><a href="#二义性示例" class="headerlink" title="二义性示例"></a><strong>二义性示例</strong></h2><p>前面基本能够找到最佳匹配，我们来看一个有多个可行函数，最后却没有最佳匹配的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="comment">//函数1</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;function 1&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//函数2</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;function 2&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>函数1和函数2都是可行函数，但它们都没有在任意一个参数上比对方更好，因此将会产生二义性，编译时将会报错：<br /><code>error: call of overloaded ‘f(int, int)’ is ambiguous</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>调用重载函数时，应当避免强制类型转换。</li><li>设计重载函数时应<strong>避免可能产生的二义性。</strong></li><li>如果<strong>无法找到可行函数，编译器将报错。</strong></li><li>设计重载函数的时候，希望避免需要用到上面的知识，而在定位问题时能够利用上面的知识很快定位问题。</li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">short</span> w)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;function int&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">long</span> w)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;function long&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">23141592</span>;</span><br><span class="line">    <span class="built_in">func</span>(i); <span class="comment">// error Call to &#x27;func&#x27; is ambiguous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">short</span> w)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;function short&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">long</span> w)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;function int&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">7</span>; <span class="comment">// char-&gt;int 优于char-&gt;short</span></span><br><span class="line">    <span class="type">short</span> s = <span class="number">4</span>; <span class="comment">// short-&gt;int 优于 short-&gt;long</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">func</span>(i); <span class="comment">// int-&gt;long or int-&gt;short 有二义性</span></span><br><span class="line">    <span class="built_in">func</span>(s);</span><br><span class="line">    <span class="built_in">func</span>(c); <span class="comment">// char-&gt;short or char-&gt;long 有二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>inline</title>
      <link href="/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/inline/"/>
      <url>/2023/03/03/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/inline/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u010150046/article/details/73823539">https://blog.csdn.net/u010150046/article/details/73823539</a></p>]]></content>
      
      
      <categories>
          
          <category> C++高级程序设计 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第四章-朗顿的蚂蚁</title>
      <link href="/2023/03/03/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%9C%97%E9%A1%BF%E7%9A%84%E8%9A%82%E8%9A%81/"/>
      <url>/2023/03/03/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%9C%97%E9%A1%BF%E7%9A%84%E8%9A%82%E8%9A%81/</url>
      
        <content type="html"><![CDATA[<p>—<br />title: 4. 朗顿的蚂蚁<br />date: 2023-03-01 14:27:42<br />categories: 《Netlogo多主体建模入门学习笔记》<br />—<br />本章将介绍一个全新的人工生命模型——朗顿的蚂蚁。</p><h2 id="4-1-朗顿的蚂蚁"><a href="#4-1-朗顿的蚂蚁" class="headerlink" title="4.1 朗顿的蚂蚁"></a>4.1 朗顿的蚂蚁</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677592021921-46f18b95-8ed4-4bd4-9fc0-6b3f176e108a.png" alt="image.png"><br>我们会看到一只小蚂蚁在模拟世界里爬来爬去，神奇之处在于，模型运行时间足够长的话，这只蚂蚁会产生令人惊喜的行为，它会在模拟世界中修建出一条“高速公路”，而且这一现象是不依赖于初始条件的，如图4-1所示。通过这个人工生命的简单例子，我们还将介绍如何实现turtle与patch之间的互动。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677591076428-a4ce207e-dc63-4d94-9a3c-cdc1751d42d2.png" alt="image.png"></p><ol><li>规则一：如果当前这只蚂蚁所处的方格是白色的，则蚂蚁向右侧旋转90度，将方格涂成黑色，并且往前移动一格</li><li>规则二：如果当前这只蚂蚁所处的方格是黑色的，则蚂蚁向左侧旋转90度，将方格涂成白色，并且往前移动一格</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677591126273-94f10c33-9b08-4063-9429-e8fc22f26afe.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677591132834-24eeab24-95c0-4d1b-8f5e-31b58ee69378.png" alt="image.png"></p><h2 id="4-2-创建蚂蚁"><a href="#4-2-创建蚂蚁" class="headerlink" title="4.2 创建蚂蚁"></a>4.2 创建蚂蚁</h2><ol><li><code>heading</code>是<code>turtle</code>的一个属性</li><li><code>netlogo</code>字典中有<code>turtle</code>的相关属性和方法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">to setup</span><br><span class="line">    clear-all</span><br><span class="line">    create-turtles <span class="number">1</span> [</span><br><span class="line">        set heading random <span class="number">3</span> * <span class="number">90</span></span><br><span class="line">    ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol><h3 id="random命令"><a href="#random命令" class="headerlink" title="random命令"></a>random命令</h3><p><code>random x</code>。<br />x是一个整数，<br />如果x&gt;0, random x产生一个介于0和x之间的随机数<br />如果x&lt;0,random x产生一个介于x和0之间的随机数。<br />第3章提到了一个命令random-float，这里random x产生的随机数一定是整数，这是它和random-float最大的不同。<br />接下来具体解读<code>set heading random 3 * 90</code>这条语句。<br />大家可能会把它解读成设置turtle的朝向为在0度到270度之间随机取一个整数，它可以取30度、60度，也可以取90度。但其实并非如此，之所以大家会理解有误，主要原因在于不熟悉NetLogo的语法。<br /><strong>random命令后面的数字3是作为random这个函数的参数来调用的</strong>，它会先从0、1、2、3这4个数字里随机取一个整数，然后把数值乘以90。因此heading的取值只能有4种可能，分别是0、90、180、270。也就是说，这条语句相当于:<br /><code>set heading = (random 3) * 90</code></p><h2 id="4-3-让蚂蚁动起来"><a href="#4-3-让蚂蚁动起来" class="headerlink" title="4.3 让蚂蚁动起来"></a>4.3 让蚂蚁动起来</h2><ol><li><code>right x</code>是让蚂蚁向右转动<code>x</code>度 &#x3D; <code>left (-x)</code> </li><li><code>left x</code>是让蚂蚁向左转动<code>x</code>度</li><li>一个<code>turtle</code>对应于一个<code>patch</code>，但是一个<code>patch</code>可以对应多个<code>turtle</code>。如果要获得所有的<code>turtle</code>，使用<code>turtles-here</code>命令。所以在遍历<code>turtles</code>时，由于关系的对应，可以获得特定的<code>patch</code>的相关属性</li><li>使用<code>tick</code>计时<ol><li>tick来源于英文单词tick，这是一个象声词（“嘀嗒”），就像跑步比赛用秒表来计时一样，一开跑就按下秒表开始计时。</li><li>在setup代码中添加reset-ticks，也就是在<strong>每一次初始化时，重置秒表</strong>，然后在togo代码块中添加tick，表示<strong>每一个模拟周期计数一次</strong>。</li></ol></li><li>如果按下“go”按钮，它并不是一步一步运行的，原因是“<strong>视图更新方式</strong>”设置了“<strong>连续更新</strong>”，这里换成“<strong>按时间步更新</strong>”。现在运行就是一步一步显示了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">to go</span><br><span class="line">    ask turtles[</span><br><span class="line">        ifelse (pcolor = white)[</span><br><span class="line">            right <span class="number">90</span></span><br><span class="line">            set pcolor black</span><br><span class="line">            forward <span class="number">1</span></span><br><span class="line">        ][</span><br><span class="line">            left <span class="number">90</span></span><br><span class="line">            set pcolor white</span><br><span class="line">            forward <span class="number">1</span></span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">to setup</span><br><span class="line">  clear-all <span class="comment">// 清除页面中的所有元素</span></span><br><span class="line">  reset-ticks <span class="comment">// 重新设定计时器</span></span><br><span class="line">  create-turtles <span class="number">1</span>[ <span class="comment">// 创造 1 个turtle</span></span><br><span class="line">  <span class="function">set <span class="title">heading</span> <span class="params">(random <span class="number">3</span>)</span> * 90  </span></span><br><span class="line"><span class="function">    <span class="comment">// set heading random 3 * 90 两者是等价的</span></span></span><br><span class="line"><span class="function">  ]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">to go</span></span><br><span class="line"><span class="function">  ask turtles[</span></span><br><span class="line"><span class="function">    <span class="title">ifelse</span> <span class="params">(pcolor = white)</span>[</span></span><br><span class="line"><span class="function">      right 90</span></span><br><span class="line"><span class="function">      set pcolor black</span></span><br><span class="line"><span class="function">    ][</span></span><br><span class="line"><span class="function">      left 90</span></span><br><span class="line"><span class="function">      set pcolor white</span></span><br><span class="line"><span class="function">    ]</span></span><br><span class="line"><span class="function">    forward 1</span></span><br><span class="line"><span class="function">  ]</span></span><br><span class="line"><span class="function">  tick</span></span><br><span class="line"><span class="function">end</span></span><br></pre></td></tr></table></figure><blockquote><p>那为什么这只蚂蚁要在走一万多步以后才开始修建“高速公路”呢?<br>谁也不知道答案，包括朗顿自己。后来很多科学家想通过数学分析的方式给出答案。在不同的条件下是否会产生不同的轨道?我们反复不停地随机初始化它的条件，发现它在一万多步的时候总是会修建出这样的“高速公路”，尽管每次“高速公路”的朝向以及它起始的时间可能会不太一样，但是修建“高速公路”似乎是朗顿的蚂蚁模拟程序的一个吸引子一样。为什么朗顿的蚂蚁会修建这样一条“高速公路”仍然是一个谜，这就是复杂系统的涌现行为。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第五章-从羊－草生态系统深入turtle与plot画图</title>
      <link href="/2023/03/03/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BB%8E%E7%BE%8A%EF%BC%8D%E8%8D%89%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5turtle%E4%B8%8Eplot%E7%94%BB%E5%9B%BE/"/>
      <url>/2023/03/03/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BB%8E%E7%BE%8A%EF%BC%8D%E8%8D%89%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5turtle%E4%B8%8Eplot%E7%94%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>—<br />title: 5. 从羊－草生态系统深入turtle与plot画图<br />date: 2023-03-01 14:27:42<br />categories: 《Netlogo多主体建模入门学习笔记》<br />—<br />本章将介绍一个全新的NetLogo多主体模型，它是由羊和草两个物种构成的简单的生态系统。<br />羊-草生态系统模拟了自然界和人类社会都存在的最基本的生存逻辑：<strong>个体生存依赖一定的资源</strong>。这些资源可以是食物，也可以是财富、声望、权力、关系等。资源可以从环境中获得，它可以给个体带来好处（维持生存、达到行动目标），而失去资源将使个体处于不利的境地，不论是因为缺少食物而饿死，还是因为声誉损耗殆尽而无法在某地继续生存。<br /><strong>羊-草生态系统是关于系统内部食物、财富、声望、权力、关系等资源变化的基本模型，它以“羊”代表“个体”，以“草”代表“资源”</strong>，通过它我们可以研究资源分布、资源存量与个体生存及繁衍间的动态关系。掌握了羊-草生态系统模型，我们就可以将其扩展到其他资源和个体关系领域</p><h2 id="5-1-羊-草生态系统规则"><a href="#5-1-羊-草生态系统规则" class="headerlink" title="5.1 羊-草生态系统规则"></a>5.1 羊-草生态系统规则</h2><ol><li>这是一个由羊（turtle）和草（patch）两个物种构成的小型生态系统。</li><li>羊的内部有一个能量值。吃掉草可以增加能量值。每一个周期都在消耗能量。能量值小于或等于0，羊就会死掉。</li><li>羊能够繁殖。当能量累积到一定水平，就会繁殖。繁殖需要消耗能量。新出生的羊会天然具备一定的能量。</li><li>草可以自发地从地里长出来。</li></ol><h2 id="5-2-初始化羊－草生态系统"><a href="#5-2-初始化羊－草生态系统" class="headerlink" title="5.2 初始化羊－草生态系统"></a>5.2 初始化羊－草生态系统</h2><p>下面用NetLogo实现这个基本的程序，首先初始化生态系统。<br />在“界面”添加“setup”按钮。由于羊的内部都有一个能量值，因此我们需要<strong>自定义一个turtle的属性—— energy</strong>。跟第4章讲的patches-own语法类似，<strong>使用turtles-own命令</strong>，方括号内是变量名energy：<br /><code>turtles-own[energy]</code> <br />接下来，清空之前的所有状态，如下所示：<br><img src="/./assets/1677601691209-8fa712e3-b43b-4f02-bce5-719e3b0ddd24.png" alt="image.png"><br>然后动态地向生态系统添加草。本次模拟设置20%的草，80%的空地。</p><ol><li>首先使用ask patches对所有patch进行循环，</li><li>random-float命令产生一个0<del>1之间的随机小数 <code>**random-float n**</code>**产生一个0</del>n之间的随机小数**</li><li>这个数值如果小于0.2，就把当前patch设置成绿色。<code>set pcolor green</code> &#x3D; <code>pcolor = green</code></li><li>因此总体运行效果就是近20%的patch变成绿色，这样草的初始化就完成了。代码如下：</li></ol><p><img src="/./assets/1677601706109-7846cf84-a10e-4855-ba4b-647d34f43340.png" alt="image.png"><br>接下来初始化系统中的羊，使用<strong>create-turtles命令创建一只羊</strong>，并且把它的初始能量设置成100，否则这只羊没有能量用于移动。<br><img src="/./assets/1677601715216-ae195212-c84e-4c0a-bae4-e6e16d8fda6f.png" alt="image.png"><br>以上这部分就是初始化功能，完成后我们可以运行一下。每次单击“setup”按钮，都会随机产生20%的绿草，羊就位于这个世界的中心位置。初始化的生态系统完整的初始化程序如下：<br><img src="/./assets/1677601726244-093458f2-8100-43fc-937f-4b8cb08207aa.png" alt="image.png"></p><h2 id="5-3-添加to-go程序"><a href="#5-3-添加to-go程序" class="headerlink" title="5.3 添加to go程序"></a>5.3 添加to go程序</h2><p>接下来添加“go”按钮的程序，即每一个模拟周期要完成的功能。根据前述生态系统的规则，每一个模拟周期都要完成如下功能：</p><ol><li>草要自然生长</li><li>每只羊要不断地移动</li><li>羊在能量积累到一定值时繁育后代</li><li>如果羊的能量消耗尽，就会死亡。</li><li>我们用子函数（也称子模块）的方式实现这几个功能，在“go”按钮对应的代码中添加如下语句：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">to go</span><br><span class="line">    add_food                 ；；添加食物子函数</span><br><span class="line">    ask turtles[</span><br><span class="line">        turtle_move         ；；turtle移动子函数</span><br><span class="line">        turtle_breed        ；；turtle繁殖子函数</span><br><span class="line">        turtle_die          ；；turtle死亡子函数</span><br><span class="line">    ]</span><br><span class="line">    tick</span><br><span class="line">end</span><br></pre></td></tr></table></figure>执行程序时，它就会调用相应子函数，从而实现整体功能。接下来我们看看每一个功能模块如何操作。</li></ol><h3 id="5-3-1-add-food"><a href="#5-3-1-add-food" class="headerlink" title="5.3.1 add_food"></a>5.3.1 add_food</h3><p>为了实现添加草的功能，我们添加了一个<strong>自定义模块</strong>，该模块跟to setup、to go代码类似，<strong>用to作为关键词，后面跟要定义的模块名称，最后用end结束，这样用户就可以定义自己的函数了。</strong>add_food函数要实现的功能就是在每个周期都添加一定量的草。可以添加如下代码：</p><p><img src="/./assets/1677601790366-b00ba31f-fb22-40df-9de2-de77b23bac3e.png" alt="image.png"><br>这里用到了一个具有强大功能的函数——n-of。它的一般格式为：<code>**n-of size agentset**</code>。<br /><code>**n-of 10 patches**</code><strong>的作用就是从patches集合中随机挑选10个patch，形成了一个新的patches集合。</strong><br />有了集合以后，再对集合中的每一个元素进行循环，将其颜色设置成绿色，无论这个patch当前是绿色的还是黑色的。<br />该函数的作用相当于下了一场“食物雨”，每一个模拟周期都会运行一遍add_food函数，都会有10个单位的patch添加上草。<br />完成了第一步add_food的操作，接下来要做的就是循环访问现在系统中所有的turtle，并且每一个turtle的一生都伴随着3件事——移动、繁殖和死亡。</p><h3 id="5-3-2-turtle-move"><a href="#5-3-2-turtle-move" class="headerlink" title="5.3.2 turtle_move"></a>5.3.2 turtle_move</h3><p>关于第二个功能，首先我们来看羊的移动需要哪些操作，同样用一个子模块的方式定义移动相关代码，如下所示：<br><img src="/./assets/1677601810252-1cba0107-6379-4059-a384-a88c94da31cb.png" alt="image.png"><br>它要实现的功能包括如下几点。</p><ol><li>如果当前patch是绿色的，即上面有草，那么这只羊会吃掉草，羊的能量也相应增加。这里设置羊的energy增加10，并将当前patch的颜色设置为黑色，表示草被吃掉了。这就是第一部分代码所完成的功能。</li><li>为了使羊的移动看起来更自然，我们<strong>让羊在每个周期以0.2的概率随机转换方向，其他时间都匀速直线前进</strong></li><li>羊的移动功能。每个周期都消耗1个单位的能量，向前移动一步。这三部分代码都可以通过前面讲过的知识完成。<strong>如何设置变量的值、如何产生随机数、如何设置turtle的运动方向、用fd 1完成移动</strong>（这里fd是forward的缩写），这些语句组合在一起就实现了turtle_move这个函数。</li></ol><h3 id="5-3-3-turtle-breed"><a href="#5-3-3-turtle-breed" class="headerlink" title="5.3.3 turtle_breed"></a>5.3.3 turtle_breed</h3><p>接下来用turtle_breed来完成繁殖这部分功能，代码如下所示<br><img src="/./assets/1677601844251-9dd9f48c-a635-4cc1-b98d-42bba1e271a5.png" alt="image.png"><br>在这部分代码中，<strong>首先检测这只羊的能量水平是否足够繁育后代</strong>，这里规定当它的能量值大于500时才能够繁育后代。繁育后代涉及两件事情，</p><ol><li>是自己的能量值减少。这部分代码也体现了为人父母的辛苦，养育后代要消耗自身大量能量。</li><li>是新生儿的出生。这里用到一个新命令——<strong>hatch</strong>。hatch的英文含义是孵化，非常形象。<strong>方括号内的这部分内容就是针对新出生的这只羊的。</strong>这只新出生的羊要完成两个操作，<ol><li>第一是往前走一步——fd 1，<strong>新出生的羊的指向heading是随机取值的，往前走一步就可以跟它的母体分开。</strong></li><li>第二个操作是<strong>给新出生的羊一个初始能量</strong>，否则它一出生就死掉了。此处把它的能量值设置成100。这样就完成了繁殖功能。</li></ol></li></ol><h3 id="5-3-4-turtle-die"><a href="#5-3-4-turtle-die" class="headerlink" title="5.3.4 turtle_die"></a>5.3.4 turtle_die</h3><p>最后一个功能是turtle_die，判断一只羊的能量值小于或等于0，它就会死掉。在NetLogo中，我们可以用die这个单词作为命令来杀死turtle。<br><img src="/./assets/1677601862611-9d0b7a88-a522-4c6b-938d-aa25e00dff6d.png" alt="image.png"><br>以上就是羊-草生态系统模型所需要的代码，运行一下看看它的效果。单击“setup”按钮，然后单击“go”按钮，开始可能大家会觉得画面非常乱，稍微把速度调慢一点儿，这时你就会看到有一些用小箭头表示的羊在环境里随机游走，并且可以吃掉草<br><img src="/./assets/1677601899764-f1199f33-2630-4b7c-a89c-18f6416a771b.png" alt="image.png"> <br />我们可以重新运行程序，开始的时候只有一只羊，很快它就会繁殖出更多的羊，大家可以看到它的繁殖过程。只要吃掉的草足够多，它就可以进行繁殖。</p><h2 id="5-4-追踪某一个具体的turtle或者patch的行为"><a href="#5-4-追踪某一个具体的turtle或者patch的行为" class="headerlink" title="5.4 追踪某一个具体的turtle或者patch的行为"></a>5.4 追踪某一个具体的turtle或者patch的行为</h2><ol><li>右击turtle，可以对turtle进行inspect、watch和follow操作<ol><li>inspect：弹出记录了turtle属性的窗口</li><li>watch：指定的turtle周围出现聚焦的圆圈</li><li>follow：指定turtle出现在屏幕中心位置</li></ol></li><li>右击patch，可以对patch进行inspect操作</li></ol><h2 id="5-5-变量的主体"><a href="#5-5-变量的主体" class="headerlink" title="5.5 变量的主体"></a>5.5 变量的主体</h2><ol><li>NetLogo中的每一个变量都有隶属关系</li><li>如果不是在ask turtles这个循环里调用turtle_move子函数，它的调用主体就不是turtle了，而是一个全局的调用主体obsever，obsever没有pcolor、energy属性，程序就会提示错误。</li></ol><h2 id="5-6-添加绘图框"><a href="#5-6-添加绘图框" class="headerlink" title="5.6 添加绘图框"></a>5.6 添加绘图框</h2><ol><li>在NetLogo“界面”加号旁边的<strong>下拉框中选中“图”（plot）</strong>，选中时鼠标指针变成一个十字，然后在空白处单击，就会出现一个弹框</li><li>设置“名称”为Population（种群）；设置它的“X轴标记”为Time，显示时间；“Y轴标记”设置为Population，显示种群数量；X和Y的最小值和最大值可以设置，也可以不设置；<strong>勾选“自动调整尺度”后，如果曲线的最大值超过坐标的最大值，绘图框将自动调节坐标最大值</strong>；“显示图例”就是在绘图框右侧位置标出每一个片条对应的曲线；“绘图笔”对应图中曲线。</li><li>第一条曲线绘制系统中羊群数量随时间变化的趋势。我们可以修改绘图笔的颜色为黑色，名称设为sheep。这里<strong>请尽量用英文来设置</strong>，因为有时曲线名称会对应函数来进行调用，写中文的话可能会出错。</li><li>“绘图笔更新命令”表示实现这条曲线需要的代码，在每一次绘制这条曲线的新点的时候，需要激活这部分代码来实现绘图功能，默认代码plot count turtles刚好满足我们的需求。<strong>plot语句的作用就是绘制图形，count turtles就是统计turtle的数量。</strong></li><li>第二条曲线绘制草总量的变化情况。添加一个绘图笔，把它的颜色改为绿色，名称改成grass。这时绘图命令就需要我们手动填写了<code>plot count patches with [pcolor = green]</code>这条命令表示绘制曲线，统计当前pcolor属性是绿色的patch数量。单击“确定”，绘图框就设定好了。</li><li>重新运行程序，你会发现运行得很好，但是右侧新加入的绘图框没有任何反应。这是因为在NetLogo当前版本中，只有设定了tick，绘图框才会生效。这点不难理解，<strong>不设置tick时，模拟世界有一个时钟，绘图本身的更新也有一个时钟，我们用tick来做模拟世界和绘图框的时间同步。</strong>跟之前的程序设定一样，在setup代码中添加<strong>reset-ticks</strong>进行重置，然后在to go代码中添加<strong>tick</strong>进行计时。这时再运行程序，就画出了漂亮的曲线</li></ol><p><img src="/./assets/1677646172478-8500f441-096f-4cdb-a59a-2e96a8b5c490.png" alt="image.png"></p><h2 id="5-7-小结"><a href="#5-7-小结" class="headerlink" title="5.7 小结"></a>5.7 小结</h2><ol><li>介绍了pcolor、energy等每一个属性变量都有一个相应的调用主体，在实现子模块时要特别注意。</li><li>介绍了操作NetLogo界面追踪某一个具体的turtle或者patch的方法。这对于模型调试，以及理解turtle的行为是否正确，起到了重要作用。</li><li>介绍了如何添加plot绘图框。绘图框的使用非常方便，通过简单的设置就可以完成。但是要记得添加tick代码，确保模拟世界和绘图框的时间同步。</li><li>介绍了hatch和die两个关键字<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">turtles-own[energy]</span><br><span class="line">to setup</span><br><span class="line">  clear-all</span><br><span class="line">  reset-ticks</span><br><span class="line">  ask patches[</span><br><span class="line">    <span class="keyword">if</span> (random-<span class="type">float</span> <span class="number">1</span>) &lt; <span class="number">0.2</span>[</span><br><span class="line">      set pcolor green </span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">  create-turtles <span class="number">1</span>[</span><br><span class="line">    set energy <span class="number">100</span></span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">to go</span><br><span class="line">  tick</span><br><span class="line">  addFood ;; 添加食物子函数</span><br><span class="line">  ask turtles[</span><br><span class="line">    turtleMove</span><br><span class="line">    turtleBreed ;;turtle繁殖子函数</span><br><span class="line">    turtleDie ;;turtle死亡子函数</span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">to addFood  ;;每一个模拟周期都会运行一遍add_food函数，都会有<span class="number">10</span>个单位的patch添加上草</span><br><span class="line">  ;; n-of <span class="number">10</span> patches的作用就是从patches集合中随机挑选<span class="number">10</span>个patch</span><br><span class="line">  ;; 形成了一个新的patches集合</span><br><span class="line">  ask n-of <span class="number">10</span> patches[</span><br><span class="line">    set pcolor green</span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line">to turtleMove</span><br><span class="line">  <span class="keyword">if</span> pcolor = green [</span><br><span class="line">    set energy energy + <span class="number">10</span></span><br><span class="line">    set pcolor black </span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">if</span> random-<span class="type">float</span> <span class="number">1</span> &lt; <span class="number">0.2</span> [</span><br><span class="line">    set <span class="built_in">heading</span> (random <span class="number">360</span>) ;; 在每个周期以<span class="number">0.2</span>的概率随机转换方向，其他时间都匀速直线前进。</span><br><span class="line">  ]</span><br><span class="line">  set energy energy - <span class="number">1</span> ;; 每个周期都消耗<span class="number">1</span>个单位的能量，向前移动一步。</span><br><span class="line">  forward <span class="number">1</span> ;;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">to turtleBreed</span><br><span class="line">  <span class="keyword">if</span> energy &gt; <span class="number">500</span> [</span><br><span class="line">    set energy energy - <span class="number">500</span></span><br><span class="line">    ;; hatch。hatch的英文含义是孵化，非常形象。方括号内的这部分内容就是针对新出生的这只羊的。</span><br><span class="line">    hatch <span class="number">1</span> [</span><br><span class="line">      forward <span class="number">1</span> ;; 新出生的羊的指向heading是随机取值的，往前走一步就可以跟它的母体分开</span><br><span class="line">      set energy <span class="number">100</span> ;; 给新出生的羊一个初始能量，否则它一出生就死掉了。此处把它的能量值设置成<span class="number">100</span>。</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line">to turtleDie</span><br><span class="line">  <span class="keyword">if</span> energy &lt;= <span class="number">0</span>[</span><br><span class="line">    die ;;给新出生的羊一个初始能量，否则它一出生就死掉了。此处把它的能量值设置成<span class="number">100</span>。</span><br><span class="line">  ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第六章-人工经济模型与turtle间的互动</title>
      <link href="/2023/03/03/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E7%BB%8F%E6%B5%8E%E6%A8%A1%E5%9E%8B%E4%B8%8Eturtle%E9%97%B4%E7%9A%84%E4%BA%92%E5%8A%A8/"/>
      <url>/2023/03/03/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E7%BB%8F%E6%B5%8E%E6%A8%A1%E5%9E%8B%E4%B8%8Eturtle%E9%97%B4%E7%9A%84%E4%BA%92%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>—<br />title: 6. 人工经济模型与turtle间的互动<br />date: 2023-03-01 15:23:42<br />categories: 《Netlogo多主体建模入门学习笔记》<br />—<br />本章将介绍一个人工经济模型，通过该模型进一步理解turtle之间的互动</p><h2 id="6-1-货币转移模型"><a href="#6-1-货币转移模型" class="headerlink" title="6.1 货币转移模型"></a>6.1 货币转移模型</h2><p>社会经济中有一个显著的现象：财富分布的不均衡性。<br />早在19世纪，意大利著名经济学家维弗雷多·帕累托（Vilfredo Pareto）就分析了大量实证数据，发现财富分布遵循一条幂律分布曲线。<br />这条幂律分布曲线满足帕累托法则（Pareto principle），也叫二八定律，即20%的财富被80%的穷人拥有（图中绿色的区域），而80%的财富被20%的富人占有（图中黄色的区域），二八定律充分反映了社会财富分布的不均衡性。<br><img src="/./assets/1677651149858-800b6772-6be5-4931-bf57-98270eb4fbee.png" alt="image.png">为了解释这种分布不均衡性，2000年，物理学家Victor M.Yakovenk提出了一个非常简单的人工经济模型：<strong>货币转移模型（money transfer model）</strong>。<br />在这个模型里，他把经济体比喻成分子，把货币量比喻成能量。对于一个气体系统来说，气体分子在碰撞过程中，能量只能从一个分子转移到另一个分子，而总能量保持守恒。经过大量碰撞，最终气体分子会达到一个非常不均等的能量分布状态。<br />货币在该模型中的分布也具有类似的特性。因此，货币转移模型符合如下基本规则：</p><ol><li>经济系统中人和财富的总量保持不变；</li><li>开始的时候，每个人都有等量的货币；</li><li>每当两个主体相遇，他们就随机分配财富。</li></ol><p><img src="/./assets/1677651360910-bd100f83-3729-4cc6-aa0c-75432b75a1de.png" alt="image.png"></p><h2 id="6-2-添加全局变量"><a href="#6-2-添加全局变量" class="headerlink" title="6.2 添加全局变量"></a>6.2 添加全局变量</h2><p>首先打开NetLogo“界面”，添加两个按钮：“setup”和“go”，添加“go”按钮时勾选“持续执行”。然后添加一个全新的控件——“滑块”，使用滑块控件可以很方便地调整变量的数值。在“添加”下拉框中点选“滑块”，然后在空白处单击添加，这时会出现弹框，如图6-3所示。首先输入全局变量名称num_agents，代表主体个数，即货币转移模型中一共有多少人。“最小值”“增量”“最大值”用于设定数值变化范围，这里设定数值从1开始变到1000，增量是1，初始值设置成100，单击“确定”，这样全局变量就创建好了。拖动滑块，就可以看到变量的取值发生变化。<br><img src="/./assets/1677655668683-7c12338f-6d0a-4492-84dd-d8f2be20d4b7.png" alt="image.png"><br>与此类似，我们可以再添加一个滑块来控制系统中的货币总量，变量名为total_money，取值范围选取1到1 000 000，增量为1，默认值设为10 000。这两个滑块所定义的总量值都可以在我们的代码中应用。</p><h2 id="6-3-初始化模拟世界"><a href="#6-3-初始化模拟世界" class="headerlink" title="6.3 初始化模拟世界"></a>6.3 初始化模拟世界</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">to setup</span><br><span class="line">  clear-all</span><br><span class="line">  reset-ticks</span><br><span class="line">  create-turtles num_agents[</span><br><span class="line">    <span class="function">set <span class="title">money</span> <span class="params">(total_money / num_agents)</span> </span>;; 初始情况下每个turtle都拥有相同的货币量</span><br><span class="line">    setxy random-xcor random-ycor  ;; 设置为随机取值，实现随机分布</span><br><span class="line">  ] ;; 除号两侧要保留空格</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="6-4-主体之间如何交互"><a href="#6-4-主体之间如何交互" class="headerlink" title="6.4 主体之间如何交互"></a>6.4 主体之间如何交互</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">to go</span><br><span class="line">    ask turtles[</span><br><span class="line">        let agsets other turtles-here</span><br><span class="line">        <span class="keyword">if</span> count agsets &gt;= <span class="number">1</span></span><br><span class="line">        [</span><br><span class="line">            <span class="built_in">transaction</span> (one-of agsets)</span><br><span class="line">        ]</span><br><span class="line">        forward <span class="number">1</span></span><br><span class="line">    ]</span><br><span class="line">    tick</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>在NetLogo里，<strong>let和set都是赋值语句</strong>，它们的用法一样，但二者有一个非常重要的区别：<strong>set只能应用于已经定义好的变量，而let适用于为第一次使用的变量赋值，它包含定义变量的意思。</strong></li></ol><p>比如变量agsets，前文并未定义，如果用set去赋值，系统会提示错误，所以这时必须使用let语句给agsets赋初始值。为什么以前没有遇到过let呢？比如初始化money时就没有定义过，其实<strong>turtles-own就给每一个turtle定义了money变量</strong>。另外像pcolor这样的变量，赋值前也没有先定义，但是<strong>pcolor是每一个patch都有的属性，它是NetLogo自带的变量</strong>，因此在初始化模拟世界时，patch的pcolor属性已经定义了。</p><ol start="2"><li><code>other turtles-here</code>，顾名思义，就是<strong>其他</strong>所有turtles-here。第4章讲过，turtle和patch存在多个turtle对应一个patch的情况，比如当前turtle是我，我站在一个patch上，这个patch上也可能有其他turtle。<ol><li><code>turtles-here</code>返回值就是当前patch上<strong>包含了我的所有turtle的集合</strong></li><li><code>other turtles-here</code>返回值就是当前patch上<strong>除我以外其他turtle的集合</strong>，即我的潜在交易对象</li></ol></li><li><code>one-of agsets</code><ol><li><code>one-of agentset</code>，从集合agentset中随机选择一个元素；</li><li><code>n-of n agentset</code>，从集合agentset中随机选择n个元素。</li><li>当元素个数不满足时，比如集合为空，它返回的也为空；小于n时，就返回小于n的所有元素。</li></ol></li></ol><h3 id="6-4-1-transaction模块"><a href="#6-4-1-transaction模块" class="headerlink" title="6.4.1 transaction模块"></a>6.4.1 transaction模块</h3><ol><li>类比于函数，有自己的参数，<strong>通过方括号传入</strong></li><li><code>let money1 ([money] of trader)</code>此处<code>[money] of trader</code>相当于我们在写Java或者Python这种面向对象语言时用到的trader.money，<strong>在NetLogo中是用of来表示的，并且变量要用方括号括起来，如果要访问多个变量，可以用逗号隔开。</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">to transaction [trader]</span><br><span class="line">    let deltam <span class="number">0</span></span><br><span class="line">    <span class="function">let <span class="title">money1</span> <span class="params">([money] of trader)</span></span></span><br><span class="line"><span class="function">    let <span class="title">epsilon</span> <span class="params">(random-<span class="type">float</span> <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    set <span class="title">deltam</span> <span class="params">(epsilon - <span class="number">1</span>)</span> * money + epsilon * money1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> money + deltam &gt;</span>= <span class="number">0</span> <span class="keyword">and</span> money1 - deltam &gt;= <span class="number">0</span></span><br><span class="line">    [</span><br><span class="line">        set money money + deltam</span><br><span class="line">        ask trader[</span><br><span class="line">            set money money1 - deltam</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-4-2-变量作用域"><a href="#6-4-2-变量作用域" class="headerlink" title="6.4.2 变量作用域"></a>6.4.2 变量作用域</h3><p>在主体之间相互交互时，有一个关键点：变量的作用域。首先对所有turtle进行循环。因为每个turtle会随机选当前patch的另一个turtle做交易，所以<strong>transaction模块的所有变量，特别是money变量，隶属于当前turtle。</strong>也就是说，turtle在不停地进行循环。假如循环到的当前turtle是agent1，那么这时transaction模块的money就是agent1相应的属性<br><img src="/./assets/1677656294659-dc4973b4-6b4c-4b49-9a3d-fdb97dc147f0.png" alt="image.png"><br>除去<code>[money] of trader（方括号配合 of 的限定）</code>和<code>set money money1 - deltam（作用域的限定）</code>中的money是trader的属性，其他money都是当前turtle也就是agent1的属性。在所有NetLogo程序里，<strong>一定要捋清楚变量到底隶属于谁，当出现多层嵌套的时候，一定要清楚其中任意一个变量到底是哪个主体的。</strong></p><h2 id="6-5-命令中心"><a href="#6-5-命令中心" class="headerlink" title="6.5 命令中心"></a>6.5 命令中心</h2><p>在编程中，首先要保证语法通顺，但是在代码实现过程中，也可能有一些逻辑错误，这时系统并不会报错。针对这个例子，如何验证程序中的逻辑是否正确呢？根据货币转移模型规则，系统中的人和货币的总量不变，但是代码中并没有验证这两个量是否守恒，所以需要一个调试手段来验证程序的正确性。我们可以使用命令中心的功能，通过命令交互的方式来访问整个NetLogo的变量。比如对于货币总量，我们可以在“观察者”那里输入以下命令：<br /><code>sum [money] of turtles</code> <br />它的作用就是把所有turtle的money组成一个集合，然后进行累加求和。<br />NetLogo是一个面向对象的层次性结构，它的最上层是observer，是<strong>由observer直接对整个系统进行操作的。</strong>因此我们刚才输入的命令实际是观察者（observer）输入的，它的返回结果也是由observer给出的。从返回值可以看到，它跟系统引入的货币量是一致的，<strong>小数是由于计算误差引起的，特别是过程中有随机小数把这些钱不停地进行分割，因此它在允许范围内会有一定误差。</strong></p><h2 id="6-6-绘制财富分布直方图"><a href="#6-6-绘制财富分布直方图" class="headerlink" title="6.6 绘制财富分布直方图"></a>6.6 绘制财富分布直方图</h2><ol><li><strong>调整绘图笔为条形</strong>，这样它就会以柱状图的方式显示图形</li><li>绘图命令也要改，因为默认命令比较适合绘制时间序列曲线，例如横坐标轴是时间、纵坐标轴是种群数量的图形。但是当前需要绘制模型每一时刻的财富分布情况，因此要删掉绘图命令，并且修改X轴标记为Wealth，Y轴标记为Counts，<strong>在绘图更新命令中添加自定义函数</strong>——to-update-plot，这样在绘图时就会动态调用绘图更新命令。</li></ol><p><code>histogram</code>直方图</p><ol><li>定义一个变量lst，该变量的值是所有turtle的money属性组成的集合，lst是一个数值列表，其中每一个数值对应某个turtle的财富值。</li><li>设定了统计小区间的个数为100。</li><li>if not empty? lst判断lst这个列表是否为空。这里<strong>empty?</strong> 是NetLogo自带的变量，该变量是一个布尔型变量，返回true或false。因此整个判断语句的意思是，如果lst不为空，则执行下面两行代码</li><li><code>set-plot-x-range 0 (max lst)</code><strong>设定了X轴的取值范围</strong>是从0到财富值的最大值。在默认情况下，它的取值范围是0~10，但是这并不合理，因为当turtle发生交易后，财富值有可能非常大，所以这时我们要动态调整它的最大值。</li><li><code>histogram lst</code>的作用是<strong>把lst变量以直方图的方式进行统计，并且把统计结果绘制到绘图界面。</strong>histogram是NetLogo自带的命令。</li><li><strong>保持模拟世界和绘图界面同步更新。</strong>在初始化代码中加入reset-ticks，然后在to go函数中添加tick进行计时，最后记得把“视图更新方式”选项改为“按时间步更新”<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">to to-update-plot</span><br><span class="line">    let lst [money] of turtles</span><br><span class="line">    set-histogram-num-bars <span class="number">100</span> ;; 设定了统计小区间的个数为<span class="number">100</span>。</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> empty? lst [</span><br><span class="line">        set-plot-x-range <span class="number">0</span> max lst</span><br><span class="line">        histogram lst</span><br><span class="line">    ]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">turtles-own [money]</span><br><span class="line">to setup</span><br><span class="line">  clear-all</span><br><span class="line">  reset-ticks</span><br><span class="line">  create-turtles num_agents[</span><br><span class="line">    <span class="function">set <span class="title">money</span> <span class="params">(total_money / num_agents)</span> </span>;; 初始情况下每个turtle都拥有相同的货币量</span><br><span class="line">    setxy random-xcor random-ycor  ;; 设置为随机取值，实现随机分布</span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line">to go</span><br><span class="line">  ask turtles [</span><br><span class="line">    let agsets other turtles-here ;; 其他所有turtles-here</span><br><span class="line">    let agentNum count agsets</span><br><span class="line">    <span class="keyword">if</span> agentNum &gt;= <span class="number">1</span> [</span><br><span class="line">      <span class="built_in">transaction</span> (one-of agsets)</span><br><span class="line">    ]</span><br><span class="line">    forward <span class="number">1</span></span><br><span class="line">  ]</span><br><span class="line"> tick</span><br><span class="line">end</span><br><span class="line">to transaction [trader]</span><br><span class="line">  let deltam <span class="number">0</span></span><br><span class="line">  let <span class="built_in">money1</span> ([money] of trader)</span><br><span class="line">  let <span class="built_in">epsilon</span> (random-<span class="type">float</span> <span class="number">1</span>) ;; 定义epsilon为一个<span class="number">0</span>~<span class="number">1</span>的随机数。前面用过random-<span class="type">float</span>，它会产生一个<span class="number">0</span>~<span class="number">1</span>的随机小数</span><br><span class="line">  -------------------</span><br><span class="line">    公式<span class="number">1</span></span><br><span class="line">    set deltam epsilon * money1 + (epsilon - <span class="number">1</span>) * money</span><br><span class="line">  <span class="keyword">if</span> money + deltam &gt;= <span class="number">0</span> <span class="keyword">and</span> money1 - deltam &gt;= <span class="number">0</span>[</span><br><span class="line">    set money money + deltam </span><br><span class="line">    ;;set [money] of trader money1 - deltam不能对其使用set</span><br><span class="line">    ask trader [</span><br><span class="line">      set money money1 - deltam </span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">    -------------------</span><br><span class="line">    公式<span class="number">2</span></span><br><span class="line">let all money + money1</span><br><span class="line">  set money epsilon * all</span><br><span class="line">  ask trader [</span><br><span class="line">    <span class="function">set <span class="title">money</span> <span class="params">(<span class="number">1</span> - epsilon)</span> * all</span></span><br><span class="line"><span class="function">  ]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">to to-update-plot</span></span><br><span class="line"><span class="function">    let lst [money] of turtles</span></span><br><span class="line"><span class="function">    set-histogram-num-bars 100</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> <span class="keyword">not</span> empty? lst [</span></span><br><span class="line"><span class="function">        set-plot-x-range 0 <span class="params">(max lst)</span></span></span><br><span class="line"><span class="function">        histogram lst</span></span><br><span class="line"><span class="function">    ]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七章-文件导出与复杂曲线绘制</title>
      <link href="/2023/03/03/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6/"/>
      <url>/2023/03/03/Netlogo%E5%A4%9A%E4%B8%BB%E4%BD%93%E5%BB%BA%E6%A8%A1%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>—<br />title: 7. 文件导出与复杂曲线绘制<br />date: 2023-03-01 15:54:42<br />categories: 《Netlogo多主体建模入门学习笔记》<br />—   <br />本章内容如下。学习导出数据文件，配合其他软件进行数据分析。NetLogo擅长仿真和模拟，并不擅长对数据做分析和统计，因此我们需要使用其他工具辅助分析。掌握洛伦兹曲线的概念。洛伦兹曲线能够非常方便地反映经济体系的财富分布不均衡现象。通过这样一条曲线，我们将很容易验证二八定律。绘制复杂曲线：洛伦兹曲线的若干编程技术。</p>]]></content>
      
      
      <categories>
          
          <category> Netlogo多主体建模入门学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2023/02/27/hello-world/"/>
      <url>/2023/02/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>page0</title>
      <link href="/2023/02/27/page0/"/>
      <url>/2023/02/27/page0/</url>
      
        <content type="html"><![CDATA[<p>4444444</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第七课 存储器</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%83%E8%AF%BE%20%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>第七课 存储器.md<a name="Bj1VP"></a></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>存储器(Memory )由一定数量的单元【一个单元往往存储的是一个字节】构成，每个单元可以<strong>被唯一标识</strong>，每个单元都有<strong>存储一个数值</strong>的能力</p><ul><li><strong>址</strong>：单元的唯一标识符（采用二进制）</li><li><strong>地址空间</strong>：可唯一标识的单元总数</li><li><h1 id="寻址能力∶存储在每个单元中的信息的位数，即内存中能被单独识别并独立存放一个数据的最小内存空间-大多数存储器是字节-8bit-寻址的，32位计算机的最大寻址空间为4GB"><a href="#寻址能力∶存储在每个单元中的信息的位数，即内存中能被单独识别并独立存放一个数据的最小内存空间-大多数存储器是字节-8bit-寻址的，32位计算机的最大寻址空间为4GB" class="headerlink" title="寻址能力∶存储在每个单元中的信息的位数，即内存中能被单独识别并独立存放一个数据的最小内存空间 - 大多数存储器是字节(8bit )寻址的，32位计算机的最大寻址空间为4GB "></a><strong>寻址能力</strong>∶存储在每个单元中的信息的位数，即<strong>内存中能被单独识别并独立存放一个数据的最小内存空间</strong><br> - 大多数存储器是字节(8bit )寻址的，32位计算机的最大寻址空间为4GB<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/967952ba4e1b290af0e1170cb711f7f9.svg"> </h1><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/77bd38e6cb7126e96b7a68955b408bd0.svg">。<br><a name="taQ02"></a></li></ul><h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666253958970-418b3025-a214-4fa8-aa46-706fa6efa141.png" alt="image.png"></p><ol><li>层次结构的原因：在<strong>成本</strong>的限制下，达到容量和速度的兼容。<br><a name="XFbYN"></a></li></ol><h3 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h3><ul><li>双稳态：没有外部信号，会保持目前所处的状态</li><li>单稳态：只能处于一种状态，给予一种刺激由0变为1后，会慢慢变为0 – 类似弹簧</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666254345494-87a5d603-a811-4b9c-829f-ef154d153ff2.png" alt="image.png"><br><a name="pCACJ"></a></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>介质：半导体<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666254421485-b941dcbc-e923-474c-8211-dbf4d265860b.png" alt="image.png"></p><ul><li>U盘属于快闪存储器<code>flash</code>的一种</li><li><strong>易失性：断电后数据是否能够保存</strong><br><a name="n2oKf"></a></li></ul><h3 id="读写存储器"><a href="#读写存储器" class="headerlink" title="读写存储器"></a>读写存储器</h3><p><a name="oGcG1"></a></p><h4 id="随机存取存储器-RAM"><a href="#随机存取存储器-RAM" class="headerlink" title="随机存取存储器 RAM"></a>随机存取存储器 RAM</h4><ol><li>反面：顺序存储器-磁带。需要倒带到特定顺序才能播放</li><li>随机不是代表位置的存取是随机的，而是代表时间是相同的</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666254829463-6a3bbbcd-da16-4124-9c15-d8e0d4b3b188.png" alt="image.png"><br><a name="qy6gs"></a></p><h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668405615011-cf967293-5688-4e45-b96c-c6ffcd502f0b.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671717235240-4933daf0-c023-4cb9-9503-3ab3edb7fd28.png" alt="image.png"><br /><strong>写0操作</strong><br />写0的时候，首先将BL输入0电平，（～BL）输入1电平。<br />然后，相应的Word Line（WL）选通，则M5和M6将会被打开。<br />0电平（来自BL）输入到M1和M2的G极控制端<br />1电平（来自~BL）输入到M3和M4的G极控制端<br />因为M2是P型管，高电平截止，低电平导通。而M1则相反，高电平导通，低电平截止。<br />所以在0电平的作用下，M1将截止，M2将打开。（～Q)点将会稳定在高电平。<br />同样，M3和M4的控制端将会输入高电平，因NP管不同，M3将会导通，而M4将会截止。Q点将会稳定在低电平0。<br />最后，关闭M5和M6，内部M1,M2,M3和M4处在稳定状态，一个bit为0的数据就被锁存住了。<br />此时，在外部VDD不断电的情况下，这个内容将会一直保持。<br><a name="ZpF7B"></a></p><h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666256057739-fcc9773c-f2f1-4a7e-b79d-e1115e22688d.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671717878470-c9fb358e-d087-4340-ae21-caad67462b49.png" alt="image.png"><br />其<strong>写操作</strong>相对简单：（我们以写1为例）<br />当需要写1的时候，先将BL（Bit Line）输入高电平1，然后选中对应的Word Line（同一时间将只有一根WL被选中）, 打开相应的MOS管，如图中所示3号位。此时，外部驱动能力很强，通过一定的时间，4号位的电容将会被充满。此时，关闭3号位的MOS管。内容1将在一定时间内被保存在4号位的电容中。写0的操作与之相反，不同的是将4号位电容中的电荷通过Bit Line放光。然后关闭3号位的MOS管，锁存相应数据。<br />而<strong>读操作</strong>相对来说，较为复杂。我们可以观察到4号位电容非常小，只有pF级别，而Bit Line往往都很长，上面挂了非常多个存储单元（cell），我们可以通过5号位的电容来表示。所以当我们直接把3号位的MOS管打开，Bit Line上将基本看不到什么变化，所以需要<strong>刷新放大器</strong><br><a name="hjPYy"></a></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666256145999-760adee0-9ba5-4380-9fc9-5a158714a86d.png" alt="image.png"></p><ol><li>因为是双稳态触发器，所以不需要刷新</li><li>L3是共享的缓存</li><li>SRAM常用做CPU中的<strong>高速处理器</strong></li><li>图中黑色方块为DRAM中的芯片，存储阵列。能够拥有<strong>比较大的存储空间</strong><br><a name="mzURA"></a></li></ol><h4 id="SRAM和DRAM的区别"><a href="#SRAM和DRAM的区别" class="headerlink" title="SRAM和DRAM的区别"></a>SRAM和DRAM的区别</h4><ul><li>SRAM成本比较高（6 个场效应管组成一个存储单元）DRAM成本较低（1个场效应管加一个电容）</li><li>SRAM存取速度比较快 DRAM存取速度较慢（电容充放电时间）</li><li>SRAM一般用在高速缓存中 DRAM一般用在内存条里</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671718033563-5232ce07-47e9-4e42-94f8-95a1cac280c7.png" alt="image.png"><br />动态存储器的定期刷新：在不进行读写操作时，DRAM 存储器的各单元处于断电状态，由于漏电的存在，保存在电容CS 上的电荷会慢慢地漏掉，为此必须定时予以补充，称为刷新操作<br><a name="PWrZ3"></a></p><h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><p><a name="UFvGB"></a></p><h4 id="只读存储器-ROM"><a href="#只读存储器-ROM" class="headerlink" title="只读存储器 ROM"></a>只读存储器 ROM</h4><p>好处：批量生产，能够节约成本—能达到一定的销售量<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666256377069-26da4fa4-5e53-43f3-8206-423c79ffe76b.png" alt="image.png"><br><a name="U8LA9"></a></p><h4 id="可编程ROM-（PROM）"><a href="#可编程ROM-（PROM）" class="headerlink" title="可编程ROM （PROM）"></a>可编程ROM （PROM）</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666257357441-ce4c16cc-6afd-4f43-a39a-3d9599c20623.png" alt="image.png"><br><a name="h8zhH"></a></p><h3 id="主要读的存储器"><a href="#主要读的存储器" class="headerlink" title="主要读的存储器"></a>主要读的存储器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671709158151-5c2175ab-4cb3-451e-bf5f-a02f46a2e501.png" alt="image.png"><br><a name="qSigr"></a></p><h4 id="EPROM"><a href="#EPROM" class="headerlink" title="EPROM"></a>EPROM</h4><p>缺点：</p><ol><li>不精准。芯片级的擦除，一次照射，所有的位元都会清除。</li><li>擦除时间受玻璃材质影响大</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671709272746-8078e179-56b6-4508-b232-3b11039cd711.png" alt="image.png"><br><a name="ty89k"></a></p><h4 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667290556906-7e500d52-fe1b-4f87-ba5d-551781cbc4f2.png" alt="image.png"></p><ol><li>DRAM比SRAM需要更多的引脚，拥有的内存更大</li><li>存储阵列所使用的线更少 4<em>4 VS 2</em>8<br><a name="ozdnc"></a></li></ol><h4 id="快闪存储器"><a href="#快闪存储器" class="headerlink" title="快闪存储器"></a>快闪存储器</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671709396073-4cefab9d-b3d8-4846-bed4-086a8fa06292.png" alt="image.png"><br><a name="YCQx3"></a></p><h3 id="从位元到主存"><a href="#从位元到主存" class="headerlink" title="从位元到主存"></a>从位元到主存</h3><p><a name="B5a0Z"></a></p><h4 id="寻址单元"><a href="#寻址单元" class="headerlink" title="寻址单元"></a>寻址单元</h4><p>在寻址单元中放入多少个位元，称为寻址模式<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671709520566-2f9928de-8b40-4a24-b699-e7817ea04d70.png" alt="image.png"><br><a name="d2Ue4"></a></p><h4 id="存储阵列"><a href="#存储阵列" class="headerlink" title="存储阵列"></a>存储阵列</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671709638263-ed6adc43-9914-45ff-8d7f-25739968d4db.png" alt="image.png"></p><ul><li>对于100个寻址单元构成的存储阵列，1<em>100需要100根线；10</em>10只需要20根线</li><li>缓冲器：进行行地址和列地址的复用；在使用译码器进行解析</li><li>刷新计时器：内存主要由DRAM组成，由于电容的自然丢失，需要不断刷新</li></ul><p>DRAM本身很大，引脚的使用量大，需要行列的复用<br />SRAM容量较小，不需要行列的复用<br><a name="kLFYL"></a></p><h5 id="如何寻址：获得总线控制权"><a href="#如何寻址：获得总线控制权" class="headerlink" title="如何寻址：获得总线控制权"></a>如何寻址：获得总线控制权</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671710528848-98166ff8-0dc2-4316-a793-e6959d24fa54.png" alt="image.png"><br><a name="F5JwS"></a></p><h5 id="如何寻址：行访问"><a href="#如何寻址：行访问" class="headerlink" title="如何寻址：行访问"></a>如何寻址：行访问</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259209097-929a92c0-4753-4d8a-b8cb-f2601832a6ca.png" alt="image.png"></p><ol><li>CPU获得总线的控制权，进行行的访问（行地址和列地址都是32位，不进行区分）</li><li>CPU发送地址</li><li>控制器进行分解</li><li>发出行地址<br><a name="LwqZ5"></a></li></ol><h5 id="如何寻址：列访问"><a href="#如何寻址：列访问" class="headerlink" title="如何寻址：列访问"></a>如何寻址：列访问</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259229644-a2ab2965-7d3a-48b2-9068-09a40b35d5e7.png" alt="image.png"><br><a name="CWPKp"></a></p><h5 id="地址译码器"><a href="#地址译码器" class="headerlink" title="地址译码器"></a>地址译码器</h5><p>n位地址0101110……可以产生</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/055ce37910d06a8239ef5a1ee87765f5.svg">种输出，每一种输出就是一个电信号，代表选中，从而实现选择<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259306532-4e7dacf5-e19b-4d31-b1d9-ce1759c9066c.png" alt="image.png"><br><a name="Dbpcu"></a></p><h5 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h5><ul><li>集中式刷新：在具体的时间内，逐行刷新，但是停止CPU的读写操作了，内存一会工作一会不工作</li><li>分散式刷新：将集中分散到每一次读写操作中。刷新的时间和集中式刷新是差不多的，因为电容的流失不至于太快。不会出现不可访问的阶段</li><li>异步刷新：只要电容在一定时间内刷新即可，不被访问就刷新，一直被访问就强制刷新。读一行，刷另外一行</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259483211-26d40a9a-22d4-4248-a49f-97b249d4009d.png" alt="image.png"><br><a name="zz743"></a></p><h4 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h4><p>对存储阵列进行封装<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671712290026-d31348b2-b77c-46db-af2c-fc33f5c88c62.png" alt="image.png"><br><a name="f7itY"></a></p><h4 id="模块组织"><a href="#模块组织" class="headerlink" title="模块组织"></a>模块组织</h4><p>将芯片组织起来<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671712414530-dfadf9b4-2be0-4913-8852-136cefd3c093.png" alt="image.png"></p><ul><li>位扩展：寻址单元的个数没有变化，改变的是寻址单元内位元的个数&#x2F;改变的是寻址模式<ul><li>地址线决定的是有多少行、有多少列，此时不变</li><li>数据线的根数增加</li></ul></li><li>字扩展：改变的是寻址单元的个数，不改变寻址单元内的位数<ul><li>改变之前：如果<strong>行列复用</strong>，16k &#x3D; 2^14需要7根地址线；改变后：64k &#x3D; 2^16，需要8根地址线。<strong>地址线只多了一根，不复用的话多两根</strong></li></ul></li><li>字、位同时扩展：既增加寻址单元个数，也会增加寻址单元内的位数<ul><li>复用多1根，不复用多2根</li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671714564708-e0fb072c-8729-47e5-b858-7cf597b9eecc.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671714679353-37b606d9-1271-479e-bee9-ac19b404163e.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671714594150-daf87b2f-5d14-4a5b-9a33-f781bd18e1ff.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671714644224-8603445c-d96f-4b74-b474-421ddc345aa6.png" alt="image.png"><br><a name="PD1bJ"></a></p><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671713522289-e9df3587-148a-48be-be4f-ec589a1135e9.png" alt="image.png"><br />红色、黄色：内存插槽，插入内存条<br />使用的是<strong>字扩展：可以访问的存储单元的个数增加了</strong><br><a name="xQdip"></a></p><h3 id="高级DRAM组织"><a href="#高级DRAM组织" class="headerlink" title="高级DRAM组织"></a>高级DRAM组织</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671716488949-7b4ba96f-542e-4eac-88e9-047846dccd3c.png" alt="image.png"><br><a name="wnwEQ"></a></p><h4 id="同步DRAM-SDARM"><a href="#同步DRAM-SDARM" class="headerlink" title="同步DRAM SDARM"></a>同步DRAM SDARM</h4><p>synchronous DRAM<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671716501948-49a3497e-e203-4d8d-badd-bced5faff0e6.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259936287-19390916-a4da-4b3e-9d75-4cd30a79e71b.png" alt="image.png"></p><ul><li>发出的是同一行数据，不需要行选</li><li>再读下一行时，需要预充电<br><a name="sapTA"></a></li></ul><h4 id="DDR-SDRAM"><a href="#DDR-SDRAM" class="headerlink" title="DDR SDRAM"></a>DDR SDRAM</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666259978458-337b22e1-d15d-4714-b519-1bf3132f5096.png" alt="image.png"><br />增加数据带宽</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666260064153-ad903d08-4854-4535-8622-f574d5de09ef.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667291222104-2da8fbab-b5df-4519-9635-59b649075566.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671716590397-287de097-6087-40ce-8bef-7dacdc97093f.png" alt="image.png"><br><a name="jT70w"></a></p><h4 id="寄存器基本原理"><a href="#寄存器基本原理" class="headerlink" title="寄存器基本原理"></a>寄存器基本原理</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667292032655-b06040e3-6828-4dee-a1c2-54f97fd6e5aa.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667292100767-5786bfe8-2c9a-4330-b15a-8c72b7b0889a.png" alt="image.png"></p><ol><li>连接在同一个时钟周期上，32位的变化是同步的</li><li>寄存器很快：和CPU的时钟周期是同步的</li><li>存储数据：用到的是RS锁存器（是实现SRAM的基础）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第九课 外部存储器</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B9%9D%E8%AF%BE%20%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B9%9D%E8%AF%BE%20%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>圆形：更方便读取数据，可以存储更多的数据</li><li>黑胶唱片：存储的是模拟信号，而不是01信号</li><li>固态硬盘比机械硬盘的抗冲击能力更好<br><a name="SMi2Q"></a></li></ul><h2 id="硬盘存储器"><a href="#硬盘存储器" class="headerlink" title="硬盘存储器"></a>硬盘存储器</h2><p><a name="j5J83"></a></p><h3 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667974491917-af4225c2-cf15-4ecf-befc-bb40c005a734.png" alt="image.png"></p><ul><li>唱针直接接触唱片，磁头不是直接接触磁盘，而是以非常小的间隙悬空</li><li>飞行高度更低，读取的面积更小，电磁感应更强，更易于读取数据</li><li>直接接触：唱片要30分钟从最外圈到最里面。而磁盘旋转速度很快，如果直接接触，会毁坏磁盘</li><li>飞行高度：几微米。<strong>无尘环境</strong><br><a name="TNBUm"></a></li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>软盘：主流为1.44MB</li><li>硬盘：主流为TB级<br><a name="jLt0B"></a></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667975348681-32192075-8856-43ee-b858-c1e0aeeb45d7.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667975624407-778c818f-1d28-4a5a-b1f0-5137756fc057.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667975638599-4665970e-09c0-4c5b-b1b3-14d7eb67fb87.png" alt="image.png"></p><ul><li>飞行高度更低了，则磁头可以更窄，这样读取的数据密度更好，一次读取的面积更少</li><li>磁头更窄，则需要离磁片的距离更近</li><li>磁盘本身不选择，而是主轴旋转</li><li>主轴连接着各层磁盘，一起旋转</li><li>磁臂<br><a name="qsLmC"></a></li></ul><h3 id="读写机制"><a href="#读写机制" class="headerlink" title="读写机制"></a>读写机制</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667975839766-06d42956-1ce0-4785-82ce-6398a63b43e8.png" alt="image.png"><br><a name="g0j4g"></a></p><h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667976121627-ee3b12b4-183a-4bec-87e1-3665fa597fa8.png" alt="image.png"><br />单磁头读取速度较慢 – 感应电流稳定也需要时间</p><blockquote><p>传统的读机制利用了磁盘相对线圈运动时在线圈中产生电流这个效应。当磁盘表面在磁头下通过时，产生一个与数据记录电流极性相同的电流。这种方式的读磁头结构本质上与写磁头结构相同，因此，同一磁头既可用于读也可用于写。这种单磁头结构主要用于软盘系统和老式硬盘系统。</p></blockquote><p><a name="BGZd8"></a></p><h4 id="读取机制"><a href="#读取机制" class="headerlink" title="读取机制"></a>读取机制</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667976555818-3773dbb7-6835-4db3-8c16-6e914b33177f.png" alt="image.png"></p><p><a name="bTRg0"></a></p><h3 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667977309941-c0e168a8-139d-4848-a741-59d52e20afd8.png" alt="image.png"><br><br />磁道间隙：防止磁场之间互相干扰<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667977536693-af6242e4-fb76-4877-8015-5280b977bae5.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667977766417-1e9b666e-ca21-442b-b511-a2e31d070daa.png" alt="image.png"></p><ul><li>速度不是恒定的 -&gt; 同一个区域以相同的角速度，不同区域角速度不同<br><a name="NyJUk"></a></li></ul><h3 id="格式化类型"><a href="#格式化类型" class="headerlink" title="格式化类型"></a>格式化类型</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667978388155-08c93ebb-6f91-44a1-b3ab-e37f3b64745d.png" alt="image.png"></p><ul><li>工业生产不进行格式化 </li><li>道号：柱面号</li><li>头号：一个磁盘是两面的</li><li>同步字节：同步字节是一个特殊的位模式，用来定义区域的起始点。</li><li>间隙2：判断现在的扇区是不是目的扇区，因此会产生延迟。如果没有间隙，则可能判断后数据已经略过了。<strong>间隙不被磁化</strong></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667978755789-11eecfac-150d-465c-94d4-14e43a8f963a.png" alt="image.png"><br><a name="X0tHx"></a></p><h3 id="IO访问时间"><a href="#IO访问时间" class="headerlink" title="IO访问时间"></a>IO访问时间</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979061166-1aba53d5-c831-4b94-88b1-822df961c736.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979071278-a3e97956-36e4-4d90-96a6-fd6d4bd5977a.png" alt="image.png"><br><a name="YNBtC"></a></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote><p> <strong>RPM的全称为“Revolutions Per Minute”，即转每分，表示设备每分钟的旋转次数。</strong></p></blockquote><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979209801-8427ca02-d840-48ae-9ceb-a9b41b354ec6.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979438342-a137ae18-a619-4f40-b05e-16f8f9a52521.png" alt="image.png"><br />硬盘的7200rpm的意思是7200（转&#x2F;每分钟）。每旋转一周所需时间为60×1000÷7200&#x3D;8.33毫秒，则平均旋转延迟时间为8.33÷2&#x3D;4.17毫秒(平均情况下，需要旋转半圈)。<br />一个5400(转&#x2F;每分钟)的硬盘，平均旋转延迟时间为60×1000÷5400÷2&#x3D;5.56毫秒。7200转理论上比5400转快15%。</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979406165-3376c66b-3856-4cae-8de5-f2dd086de6f3.png" alt="image.png"></p><p><a name="qxD1u"></a></p><h3 id="磁头寻道-x2F-磁盘调度"><a href="#磁头寻道-x2F-磁盘调度" class="headerlink" title="磁头寻道&#x2F;磁盘调度"></a>磁头寻道&#x2F;磁盘调度</h3><p><a name="KaEOY"></a></p><h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务 FCFS"></a>先来先服务 FCFS</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979729752-9414d879-7952-4960-bcb3-d00772920845.png" alt="image.png"><br><a name="LnQXn"></a></p><h4 id="最短寻道时间优先-SSTF"><a href="#最短寻道时间优先-SSTF" class="headerlink" title="最短寻道时间优先 SSTF"></a>最短寻道时间优先 SSTF</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979701347-5edf41e6-38c4-4ae4-b93c-6a740efe2a56.png" alt="image.png"><br />饥饿现象：如果一直要访问88 91 93 85，则只会在90号左右磁道进行，而忽略了两端的磁道请求<br><a name="Bp3r9"></a></p><h4 id="扫描-x2F-电梯-SCAN"><a href="#扫描-x2F-电梯-SCAN" class="headerlink" title="扫描&#x2F;电梯 SCAN"></a>扫描&#x2F;电梯 SCAN</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667979835267-6fcba46f-329f-4fd0-b88c-884ec2f229e8.png" alt="image.png"><br><a name="bsNts"></a></p><h4 id="循环扫描-C-SCAN"><a href="#循环扫描-C-SCAN" class="headerlink" title="循环扫描 C-SCAN"></a>循环扫描 C-SCAN</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667980013055-dbe047d5-4f4a-42c6-8811-e9b5c0176dd2.png" alt="image.png"><br><a name="kQe6F"></a></p><h4 id="LOOK"><a href="#LOOK" class="headerlink" title="LOOK"></a>LOOK</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667980109452-f2004148-61a4-4a2b-a816-1e5daf3dcc61.png" alt="image.png"><br><a name="OTieV"></a></p><h4 id="C-LOOK"><a href="#C-LOOK" class="headerlink" title="C-LOOK"></a>C-LOOK</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667980125327-aeb9d22b-f96d-43ff-8f3c-1c69cbdf858f.png" alt="image.png"><br><a name="lDoSx"></a></p><h2 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668068497471-c0c8ee1d-976d-4c0e-bd26-35e610474bcd.png" alt="image.png"><br><a name="DDq0y"></a></p><h3 id="CD和CD-ROM"><a href="#CD和CD-ROM" class="headerlink" title="CD和CD-ROM"></a>CD和CD-ROM</h3><p> <img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668068916438-8895820d-4e36-429a-9a6e-0b66239c0cb1.png" alt="image.png"></p><ul><li>反射材料镀在凹坑上层</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070099129-25b37516-28c4-4967-8900-5002d8648d20.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070082295-b6295688-1184-4bd5-87fc-8f6cbec362de.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070266457-a94a372a-1c11-4132-a786-47902e37fc60.png" alt="image.png"><br><a name="Q5BMg"></a></p><h3 id="DVD-数字多功能光盘"><a href="#DVD-数字多功能光盘" class="headerlink" title="DVD 数字多功能光盘"></a>DVD 数字多功能光盘</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070319093-78de051e-b5a1-468f-b961-922700d82db8.png" alt="image.png"><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070488965-698e80ec-9258-4faa-ae7e-c1dac54677d6.png" alt="image.png"></p><blockquote><p>波长和分辨两点的最小距离是正相关的</p></blockquote><p><a name="OAJ80"></a></p><h2 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668070613542-32dc61e3-43be-449f-8758-edc1dce4d1d1.png" alt="image.png"><br><a name="XktPM"></a></p><h2 id="U盘和固态硬盘"><a href="#U盘和固态硬盘" class="headerlink" title="U盘和固态硬盘"></a>U盘和固态硬盘</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668071962854-273edac4-ddc3-425c-a360-50138c4cefe0.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668071953942-579a9213-42b4-46dd-ba97-543fe6964224.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二课 计算机的顶层视图</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E8%AF%BE%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E8%AF%BE%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>顶层设计：冯诺依曼结构&#x3D;&gt;计算机需要满足什么，具有一定的普适性。<br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1662630204935-215bd08d-ddb1-4ea5-8005-be0a92cd10eb.png" alt="image.png"><br />第一台计算机：10进制<br />有反直觉的设计：2进制（最理想的进制是<code>e</code>）<br />早期：组件之间用<strong>分散方式</strong>相连，现在主要用<strong>总线方式</strong>相连<br />冯诺伊曼最重要的思想：**存储程序（Stored-program） **<br />ABC计算机是硬件编程，而不是软件编程，所以是专用计算机，而非通用计算机，不具有存储功能。<br />冯诺依曼结构将数据和程序存放在一起，而哈弗结构将两者分开。有一些ARM（Cortex-M系列）是哈佛结构，而另一些ARM（Cortex-A）是冯诺依曼结构<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663229517646-09a5e875-d19b-4aeb-bedb-644b56493d27.png" alt="image.png"><br />关键概念：</p><ul><li>指令和数据存储在单个读写存储器中</li><li>主存中的内容按位置访问，无需考虑其中包含的类型</li><li>CPU从一条指令到下一条指令以顺序方式执行（除非明确修改)</li><li>与CPU和内存交换从外部来源收集的数据</li><li>总线是连接两个或多个设备的通信通路</li></ul><p>不成比例扩展效应：计算机各个部分的发展是不同步的。目前CPU的发展速度远远快于存储，会出现速度匹配不一致的影响<br><a name="Wa1F4"></a></p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p><a name="tWsLM"></a></p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>中央处理单元&#x2F;中央处理器 定义：获取并执行指令的计算机组成部分。由一个ALU、一个控制单元和多个寄存器构成。<br />处理器 processor：含有一个或者多个内核的物理硅片。处理器是计算机组件，用于解释和执行指令。如果一个处理器包含多个内核，则称之为<strong>多核处理器 <strong>（此处定义并不精准）<br />随着时代的发展，CPU的大小几乎不变，晶体管的数量一直增加，但是有一个物理极限。每个晶体管都可以看成一个开关，传输和开关都需要时间<br />无限增大CPU的面积&#x3D;&gt;面积增大，代表着</strong>互连延迟</strong>增大。一个时钟周期需要大于最大互联延迟<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663231672408-6ffbaeb9-6d3f-4b82-ad36-986165c3946e.png"></p><ol><li>传递速度不能达到光速 </li><li>未考虑开关消耗的时间</li><li>随着面积的增加，性能相应的增加变弱了，成本显著增加了<br><a name="aWja5"></a></li></ol><h3 id="CPU相关问题"><a href="#CPU相关问题" class="headerlink" title="CPU相关问题"></a>CPU相关问题</h3><p><a name="kppA3"></a></p><h4 id="问题1：CPU的频率不能无限提高"><a href="#问题1：CPU的频率不能无限提高" class="headerlink" title="问题1：CPU的频率不能无限提高"></a>问题1：CPU的频率不能无限提高</h4><ul><li>理论限制</li></ul><ol><li>MOS管开关、脉冲通过门电路需要时间</li><li>为了信号同步，每个脉冲信号需要持续一定的时间</li></ol><ul><li>制造限制</li></ul><ol><li>芯片面积越来越大，导致连线延迟越来越大，需要保证信号在设计指定时钟周期内从芯片的一角到达另一角</li><li>频率越高（即MOS管的开关频率也越高）会导致开关（电能状态变化）损耗也越高，CPU耗电和散热会提高。Mac book air（无风扇，CPU频率低）&lt;Mac boor pro（有风扇）</li></ol><p>必须在其他条件限制下，才能说频率越高性能越好<br />解决方法：改进CPU芯片结构+领域定制，面向特定领域开发芯片<br />晶体管数量的增加为更先进、更复杂的体系结构提供了基础<br><a name="u2fXc"></a></p><h4 id="问题2：内存墙的存在"><a href="#问题2：内存墙的存在" class="headerlink" title="问题2：内存墙的存在"></a>问题2：内存墙的存在</h4><p>主存和CPU之间传输数据的速度跟不上CPU的速度<br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663233136175-44f94e9a-8ad6-40b5-bf04-43f4879b199f.png" alt="image.png"><br />对于CPU：希望速度变快<br />对于内存：希望存储空间变大<br />解决方法：采用高速缓存（Cache）— 和缓存进行交互，</p><ol><li>增加一级或多级缓存，以减少存储器访问频率并提高数据传输速率</li><li>增大总线的数据宽度，来增加每次所能取出的位数</li></ol><p>问题：怎么能保证数据总在缓存中呢？<br><a name="e7VEU"></a></p><h4 id="问题3：CPU等待I-x2F-O传输数据"><a href="#问题3：CPU等待I-x2F-O传输数据" class="headerlink" title="问题3：CPU等待I&#x2F;O传输数据"></a>问题3：CPU等待I&#x2F;O传输数据</h4><p>CPU在等待I&#x2F;O设备时保持空闲<br />解决方法：采用中断机制<br /><strong>中断：</strong><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663233507712-f20de60b-71dd-488d-8a2c-d132b63a509e.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663233744614-224f9322-ac72-4b87-8787-25b6c9997b39.png" alt="image.png"><br><br />多重中断：</p><ol><li>多个中断处理顺序排列（无优先级）</li><li>多个中断处理嵌套排列（有优先级）</li></ol><p>最大差异：优先级的概念<br><a name="OjeA4"></a></p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663234498573-a20e53dc-2b58-4023-918a-6d1fd0abd500.png" alt="image.png"><br><br />CPU中的存储器<br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663234475831-fd01e064-5c16-4604-b2c9-d4ce824a647c.png" alt="image.png"><br><a name="IlAAa"></a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><a name="kTOU0"></a></p><h4 id="兼容存储容量、速度和成本"><a href="#兼容存储容量、速度和成本" class="headerlink" title="兼容存储容量、速度和成本"></a>兼容存储容量、速度和成本</h4><p>约束：</p><ol><li>容量：越大越好</li><li>速度：跟上处理器</li><li>成本：相对于其他组件合理，难以做到又大又快</li></ol><p>约束之间的关系：更短的访问时间，更高的每比特成本<br />解决：层次式存储结构<br><br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663235019714-d824ab48-3b24-4793-a56e-183d384dd628.png" alt="image.png"><br><br />从上往下：</p><ul><li>数量越来越大</li><li>速度越来越慢</li><li>离CPU越来越远</li></ul><p>主板外存储器 -&gt; I&#x2F;O设备（外围设备，类似于鼠标、键盘）<br />CD：光驱读取<br />离线存储器：磁带（纪录片拍摄曾用）<br />需求</p><ul><li>大容量数据存储</li><li>高速性能</li></ul><p>解决方案：使用存储器层次结构而不是依赖单个存储器组件<br><a name="NjnIw"></a></p><h2 id="I-x2F-O模块"><a href="#I-x2F-O模块" class="headerlink" title="I&#x2F;O模块"></a>I&#x2F;O模块</h2><p>与CPU和内存交换从外部来源收集的数据<br /><strong>I&#x2F;O设备不是I&#x2F;O模块</strong><br><a name="sLu79"></a></p><h3 id="问题：I-x2F-O设备传输速率差异大"><a href="#问题：I-x2F-O设备传输速率差异大" class="headerlink" title="问题：I&#x2F;O设备传输速率差异大"></a>问题：I&#x2F;O设备传输速率差异大</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663235493942-615cb7d7-6fa4-4bb9-9d60-223203818b5a.png" alt="image.png"></p><ol><li>CPU和内存速度不匹配：Cache    -&gt; CPU必须直接和内存交换</li><li>CPU和I&#x2F;O设备：采用中断机制  -&gt; CPU可以和内存交换</li></ol><p>解决：</p><ol><li>设立缓冲区，实现不同设备上速度的统一</li><li>新的接口技术</li><li>不同的I&#x2F;O操作技术<br><a name="O135b"></a></li></ol><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>两大基本特征：</p><ol><li>共享：多个部件连接在同一组总线上</li><li>分时：同一时刻，总线上只能传输一个部件发送的信息</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663235900267-cc460503-e351-4eec-9398-0b9a5f3e8bc7.png" alt="image.png"><br><a name="L8rHD"></a></p><h3 id="问题：计算机部件互连复杂"><a href="#问题：计算机部件互连复杂" class="headerlink" title="问题：计算机部件互连复杂"></a>问题：计算机部件互连复杂</h3><p>解决：采用总线<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663235983699-93504203-6207-4af3-beee-38284226035c.png" alt="image.png"></p><p><a name="EQFk2"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1663236054178-9d84a416-00bd-4419-b883-6107eb085de8.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第五课 浮点数运算</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%94%E8%AF%BE%20%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%94%E8%AF%BE%20%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p><a name="igMSi"></a></p><h2 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665650022766-f9e0c767-60a8-48d5-8b67-8d57ba152f3b.png" alt="image.png"></p><ol><li>尾数右移时，需要返回原来的隐藏位<code>1</code></li><li>尾数右移时，需要保持负号不变，在数值高位补<code>0</code>，但不改变符号位<br><a name="DeX3z"></a></li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665653840660-c16ae184-7d93-4e26-b060-50d96009fb3a.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665653694954-dc90dddc-91f1-4521-afd4-0a10467431a0.png" alt="image.png"><br><br /><strong>有进位要去掉进位</strong>，再进行左规<br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665826155336-ebc1c0bf-aa67-44ef-96de-2d7636217132.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665653514684-ee78ded2-8544-4e89-9a0c-0ae8290d58a0.png" alt="image.png"><br><a name="OfVdC"></a></p><h2 id="乘除"><a href="#乘除" class="headerlink" title="乘除"></a>乘除</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665650671642-12e369a6-b8eb-44cc-aa08-c06023ccb4cd.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665654392640-b83d1468-53f0-472b-a872-3113abdb4c03.png" alt="image.png"><br><a name="ww3nZ"></a></p><h2 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666086972475-e8ee49d0-503d-4407-ac4f-3fdd385db9e3.png" alt="image.png"><br><a name="fw9V3"></a></p><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665651221721-286719f7-7ebe-4a6d-b1d8-dccd815e8e4e.png" alt="image.png"><br />最大允许阶值 &#x3D; 127<br />最小允许阶值 &#x3D; -126<br /><strong>阶值 &#x3D; 阶码的二进制解释 - 偏置常数</strong><br /><strong>在浮点数的表示中，阶码全1和阶码全0都有特殊含义</strong><br><a name="DX7Bp"></a></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666086860494-e5bafb9f-2855-4c4d-be50-cac243daee47.png" alt="image.png"></p><p><br />双精度：阶下溢用0表示。<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665654690567-f1ac72ae-b798-4777-a0ff-f2da8da37a85.png" alt="image.png"><br><a name="YWTY5"></a></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665655265428-f33b3675-8474-44a4-988f-45696f22da9a.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666080813814-89570370-a4e8-4b86-ae86-56e784b4442f.png" alt="image.png"><br><a name="yvgPc"></a></p><h4 id="D-F-F-x3D-x3D-F"><a href="#D-F-F-x3D-x3D-F" class="headerlink" title="D+F-F &#x3D;&#x3D; F"></a>D+F-F &#x3D;&#x3D; F</h4><p>什么时候不成立？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> y = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-100</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> w = <span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">        <span class="keyword">if</span> ((y + w) - w != y) &#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; y+w-w&lt;&lt;&quot;!!!&quot;;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; y &lt;&lt;endl;</span></span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>i &gt;=53</code>时，不成立。因为<strong>双精度浮点数的尾数长度为52，所以，</strong><code>**1.0**</code><strong>在对阶过程中，因为阶值变成了53，所以相当于1前面增加了53个0，而尾数最长只有52，所以1就被舍去了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第六课 二进制编码的十进制数运算</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%85%AD%E8%AF%BE%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%85%AD%E8%AF%BE%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>使用原因</p><ul><li>精度限制</li><li>转换成本高</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666081387420-f366e86a-ff4f-4eeb-8311-fe2d76e27c1a.png" alt="image.png"><br><a name="fSLnM"></a></p><h3 id="加法溢出判定"><a href="#加法溢出判定" class="headerlink" title="加法溢出判定"></a>加法溢出判定</h3><p><a name="uY2xc"></a></p><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><ol><li>如果产生了进位1加0110</li><li>如果没产生进位，但是大于9了，产生进位</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666081877406-8d3e57a1-7d04-407c-bd20-78852572edcc.png" alt="image.png"><br /><strong>总是加上6</strong><br /><strong>0101+1001 &#x3D; 1110 【14】(BCD码中无法得到14) + 0110 &#x3D; 0100</strong><br />10进位和16进位刚好差一个6，所以补上6即可</p><blockquote><p>25 + 39 &#x3D; 64<br>需要额外增加 0110 原因是产生了进位。虽然表面上没有直接的1进位产生。但是，是<strong>用10进制的形式</strong>来进行计算，此时1110已经大于10了，所以产生了进位</p></blockquote><p><a name="d5pZC"></a></p><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666082710595-3a11b950-5693-4d5d-84c2-d5249e416b34.png" alt="image.png"><br><br /><code>0000</code> 直接反转 得到 <code>1111</code> &#x3D; 15 -$x$<br />但实际上需要得到$9-x$<br />所以</p><ol><li>按位反转，得到 $15-x$，添加<code>1010</code> 得到$25-x$，又因为最大值为<code>16</code>所以会自动减16 得到$9-x$</li><li>添加<code>0110</code>，得到 $x+6$,再按位反转，得到$15-(x+6) &#x3D; 9-x$<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1666083071821-d2e8151f-cdcc-47ea-9961-1813f5ac9673.png" alt="image.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第八课 高速缓存器</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%85%AB%E8%AF%BE%20%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%99%A8/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%85%AB%E8%AF%BE%20%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>对于直接映射的块交换还无法形成完整的逻辑自洽<ul><li>如何求的块内地址、标记、cache行号</li><li><strong>如何根据主存地址去寻找</strong></li></ul></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667292334410-03283cfc-3b29-4262-9e22-71ef3dbb1bc2.png" alt="image.png"><br />寄存器和<code>Cache</code>就集成在CPU中了<br />内存墙：CPU的速度比内存（受限于电容）的速度快得多<br />解决：CPU和内存之间增加<code>Cache</code><br><a name="CaZuv"></a></p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p><a name="CSLN2"></a></p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667292567472-9d5959d8-a0e0-44c1-93c8-4196b1beaaac.png" alt="image.png"><br><a name="yX2VV"></a></p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667292699652-b0ed8ba5-ae22-433b-b333-890d38384200.png" alt="image.png"></p><ul><li>如何判断是命中还是未命中？</li><li>如果未命中，为什么不直接把所需要的字从内存传送到CPU？<ul><li>时间局部性</li></ul></li><li>如果未命中，为什么从内存中读入一个块而不只读入一个字？<ul><li>空间局部性</li></ul></li><li>使用<code>Cache</code>后需要更多的操作，为什么还可以节省时间？<ul><li><br /><a name="WvfYN"></a></li></ul></li></ul><h4 id="命中VS未命中"><a href="#命中VS未命中" class="headerlink" title="命中VS未命中"></a>命中VS未命中</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667293060253-505d30ef-10f6-4824-95fc-6d3e8a72b7f7.png" alt="image.png"><br />通过这种映射关系判断有无命中<br><a name="BLU4w"></a></p><h4 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667293140962-04cc6eae-a14c-4b3f-93be-d17bf41743bc.png#averageHue=%23f0eeee&clientId=u06f12690-f928-4&from=paste&height=294&id=ue781c9ad&name=image.png&originHeight=367&originWidth=691&originalType=binary&ratio=1&rotation=0&showTitle=false&size=94471&status=done&style=shadow&taskId=udb808d65-418b-4d5d-8d33-e712d39e5e7&title=&width=552.8" alt="image.png"><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667294596527-0cf700f6-71c6-444b-acb7-b1c0b5392e3c.png" alt="image.png"></p><ul><li>把块给<code>Cache</code>，把字给处理器</li><li>两种方式时间开销上无较大差异</li><li>系统总线代表主存，主存速度很慢，而<code>CPU</code>会一直申请数据，所以需要缓冲器</li></ul><p>因为会重复访问特定的数据<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667294557008-b0914a4a-57d2-49f2-b8f2-3fd4007be848.png" alt="image.png"></p><ul><li>字在某一个块中，传递块而不是字</li><li>通过标记，判断字所在的块命中了，则字命中了&#x3D;&gt;所以块是预先划分好的</li><li>方便访问相邻数据<br><a name="h7IOU"></a></li></ul><h4 id="平均访问时间"><a href="#平均访问时间" class="headerlink" title="平均访问时间"></a>平均访问时间</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667295313429-3eb83d8c-ec9c-45d2-aab0-a5778b5f7c9b.png" alt="image.png"><br /><code>Tc</code>：做的是检查<br /><code>Ta = 检查时间+访问主存的时间（1-p 需要访问）</code></p><ol><li>降低<code>Tm</code>很难，受到电容的限制</li><li>命中率高要求cache大，而这会使访问cache时间变大<br><a name="LpKUq"></a></li></ol><h4 id="Cache未命中原因"><a href="#Cache未命中原因" class="headerlink" title="Cache未命中原因"></a>Cache未命中原因</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667295595914-e082f099-0bb8-40aa-a756-a2127b17c664.png" alt="image.png"> </p><ul><li>容量失效：原8kb的数据块访问后被后面的8kb的数据覆盖。如果再要访问到该8kb的数据，因为已经被替换了，则会失败，导致失效</li><li>冲突失效：<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667384986023-53efd5cd-671e-4f4a-b4d8-a3f6b8390d2c.png" alt="image.png"><br><a name="n370z"></a></li></ul><h3 id="Cache的设计要素"><a href="#Cache的设计要素" class="headerlink" title="Cache的设计要素"></a>Cache的设计要素</h3><ul><li>容量：太大-命中率低；太低：容量失效</li><li>映射功能：冲突失效</li><li>替换算法：用一个更小的区域放一个更大的区域，有更高概率被访问的数据留下来</li><li>写策略</li><li>Cache行大小（主存的块大小）</li><li>Cache数目<br><a name="cqwNm"></a></li></ul><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667295799998-8959f701-2751-4514-bfac-cb82477c6c18.png" alt="image.png"><br />涉及到的空间局部性和所需的数据更大，则容量设置的更大<br><a name="MlIc9"></a></p><h4 id="映射功能"><a href="#映射功能" class="headerlink" title="映射功能"></a>映射功能</h4><p><a name="WqwNQ"></a></p><h5 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667296212193-00f04372-8719-4439-a29b-a5998082176c.png" alt="image.png"></p><p>使用地址的高2位就可以<img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667296380909-54fc0771-6e3d-4ce1-aed2-bc6cf0027a2a.png#averageHue=%23e8c878&clientId=u06f12690-f928-4&from=paste&height=21&id=ub6935c40&name=8A81E895498104367421DECBCC173E3F.png&originHeight=26&originWidth=25&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1551&status=done&style=shadow&taskId=u6ecf5acd-f1f5-4ebb-b616-6636b062cb6&title=&width=20" alt="8A81E895498104367421DECBCC173E3F.png">指向具体的行<br /><code>**M是128/8=16，C=4 所以n=2：**</code><br /><strong>16个块，有4行，所以一行中有4个块，所以需要2位标记</strong><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667296502468-b839cc2a-2cf3-426a-aec8-7b6a994e409f.png" alt="image.png"><br /><code>CPU</code>寻找主存，通过主存地址进行寻找<br />一个块包含很多字，一个块对应的是<code>cache</code>中的一行。<br />所以要通过块内地址找到块中具体的字在哪里。</p><ul><li>什么是每行包含8个字：一个块包含了八个字，需要用3位二进制进行。这里的字可以理解为一个数据单元。</li><li>主存中包含128个字：所以主存地址为7位</li><li>主存和缓存是按块进行存储的</li><li>块的大小是相同的</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667296642223-21734d28-1639-4116-8a8b-9b5828c260a7.png#averageHue=%23f6f4f3&clientId=u06f12690-f928-4&from=paste&height=506&id=ucadff43d&name=image.png&originHeight=633&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&size=133543&status=done&style=shadow&taskId=u3fffeb46-09f2-4e14-81d9-9f9eceee242&title=&width=692.8" alt="image.png"><br />命中了的话再根据子块内地址找到对应的字<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667388177145-4c64d0e3-aebd-48b3-b1d2-de30698abe5d.png" alt="image.png"></p><ul><li>因为只有16行，所以只需要1位表示就行（前提是16进制）</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667388340836-59e73bb1-60ee-4569-a917-1cd05b528ab5.png" alt="image.png"><br /> <code>Cache</code>中本身不记录行号和块号，是逻辑上产生<br><a name="Xcxzr"></a></p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667463892544-629a5f53-40c6-44ad-864d-2cc90f1af93d.png" alt="image.png"></p><ul><li>行数变多：数据之间的关联性降低，因此冲突失效概率降低</li><li>电路简单：增大容量，但是映射关系仍然保持一致，所以检查时间变化不大</li><li>降低检查时间<code>Tc</code>，增加命中率，这两者直接存在矛盾。<br><a name="hzC0t"></a></li></ul><h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>一个主存块可以装入<code>Cache</code>任意一行，所以不需要记录行号了<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667464555767-4bc9de8e-c557-4d46-98f1-47547de9ee39.png" alt="image.png"><br><a name="o9XHQ"></a></p><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p>代价：</p><ol><li>需要知道哪一行是空的</li><li>要访问每一行，所以容量增大的话，则<code>Tc</code>显著增加</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667464443441-912339c9-7b78-43e0-8f95-2d115d55c81c.png" alt="image.png"><br />对于小容量，不适合直接映射<br><a name="bfLZr"></a></p><h5 id="组关联映射"><a href="#组关联映射" class="headerlink" title="组关联映射"></a>组关联映射</h5><p>将书柜分区：中文区、日文区、英文区<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667464714834-86ff1b21-3887-49fc-a8e2-b330790f4082.png#averageHue=%23f6f4f4&clientId=uaa87a2dc-af29-4&from=paste&height=258&id=uae9304a1&name=image.png&originHeight=323&originWidth=793&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81508&status=done&style=shadow&taskId=uab9e02b6-2f1f-407f-b0fe-8ec3b58c301&title=&width=634.4" alt="image.png"><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667464835947-858cc66f-18f1-4508-a464-4fc22d60ef5a.png" alt="image.png"><br><a name="t5O7u"></a></p><h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h6><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667465027916-d6c6957f-0522-4e65-a468-47ef90a89f8d.png" alt="image.png"><br><a name="hu8bR"></a></p><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667465192606-c777eb24-b3c9-4670-903a-33e5b7f672f8.png" alt="image.png"><br /><strong>K和容量、命中率、检查时间的变化</strong><br><a name="LmvZA"></a></p><h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667465463904-3cf6cdf1-0337-4c41-8fab-36ee1a1634bf.png" alt="image.png"><br />可以通过软件进行模拟，例如解决缓存问题。但本身是通过<strong>硬件</strong>实现<br />再次访问的概率相较于其他行更低？<br><a name="x1PLV"></a></p><h5 id="最近最少使用算法-LRU？"><a href="#最近最少使用算法-LRU？" class="headerlink" title="最近最少使用算法 LRU？"></a>最近最少使用算法 LRU？</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667465619658-1f43e206-092a-4a1d-ac4e-be4858032bf2.png#averageHue=%23f2f1f1&clientId=uaa87a2dc-af29-4&from=paste&height=454&id=u9967a4cb&name=image.png&originHeight=568&originWidth=819&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146966&status=done&style=shadow&taskId=udea36be2-a366-4e3b-a18e-3fda1177be6&title=&width=655.2" alt="image.png"><br />非此即彼：0&#x2F;1代表的是访问时间的近远<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667466998466-045f1ece-9b44-4523-a305-fc63938562bf.png" alt="image.png"><br><a name="iY2yC"></a></p><h5 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h5><p>仍然存储抖动现象<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667467396784-995a5bb6-3d2a-42ab-a351-4d98caa8d64f.png#averageHue=%23f6f3f2&clientId=uaa87a2dc-af29-4&from=paste&height=303&id=u1bcd893f&name=image.png&originHeight=379&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139846&status=done&style=shadow&taskId=u0e9709c5-2032-47fb-8052-e3e32164ae4&title=&width=624.8" alt="image.png"><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667467358785-5ade1a2b-31a0-4927-b26a-3eda7127e036.png" alt="image.png"><br><a name="JrlNC"></a></p><h5 id="最不经常使用算法-LFU"><a href="#最不经常使用算法-LFU" class="headerlink" title="最不经常使用算法 LFU"></a>最不经常使用算法 LFU</h5><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667467410431-db70e4fa-499c-4b88-8f6b-afdbaa5a293b.png" alt="image.png"><br><a name="T0X33"></a></p><h5 id="随机替换算法"><a href="#随机替换算法" class="headerlink" title="随机替换算法"></a>随机替换算法</h5><p>假设的情况和真正情况的符合度较高。所有能够进入<code>Cache</code>的数据，本身都是“万里挑一的”<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667467503132-aebe0253-1371-408e-aff9-d05d7e1c5bc1.png" alt="image.png"><br><a name="gw6Sv"></a></p><h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><p><a name="JVQGR"></a></p><h5 id="缓存命中时的写策略"><a href="#缓存命中时的写策略" class="headerlink" title="缓存命中时的写策略"></a>缓存命中时的写策略</h5><p><a name="v8bXo"></a></p><h6 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h6><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667468245448-bceb6ff8-8f87-4729-b2dd-ca4e2eefd1e0.png" alt="image.png"><br><a name="VRVWw"></a></p><h6 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h6><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667468274096-63437b84-2bb1-4d6d-904a-40a4d23337e7.png" alt="image.png"><br><a name="ov8D6"></a></p><h5 id="缓存未命中时的写策略"><a href="#缓存未命中时的写策略" class="headerlink" title="缓存未命中时的写策略"></a>缓存未命中时的写策略</h5><p>写不分配：对安全要求较高的<br />写分配：程序中隐含较多时间和空间的局部性<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667468309563-d70f3f1b-5d70-4e61-8581-9f3a5932716e.png" alt="image.png"><br><a name="VfMw8"></a></p><h4 id="行大小"><a href="#行大小" class="headerlink" title="行大小"></a>行大小</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667468442985-db7915c2-ce8e-4f60-961c-986426baea6f.png" alt="image.png"><br />不是违反了时间关系，而是违反了时间局部性：<strong>重复访问存储在相同位置的信息</strong>，那么每一次找都要找很久<br />反空间局部性：**重复<br><a name="Po3ao"></a></p><h4 id="Cache数目"><a href="#Cache数目" class="headerlink" title="Cache数目"></a>Cache数目</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32543531/1667468656923-5bf32d4e-8fa1-43b2-9eb4-763f086628bc.png#averageHue=%23eeeeee&clientId=uaa87a2dc-af29-4&from=paste&height=244&id=uc84faddd&name=image.png&originHeight=305&originWidth=840&originalType=binary&ratio=1&rotation=0&showTitle=false&size=97318&status=done&style=shadow&taskId=u0219c0e0-0f21-4e92-8dac-b13a61bb8f4&title=&width=672" alt="image.png"><br />冯诺依曼：指令和数据不区分。根据阶段进行区分<br />对与<code>Cache</code>，数据很快会把Cache填满，而指令也会频繁使用-都受到局部性的支配，所以需要消除竞争关系，避免冲突失效<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1667468849188-a8539d6d-e141-41ab-b533-9be656164c6e.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十一课 冗余磁盘阵列</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/20131784">RAID有哪几种？有什么区别？ - 知乎</a><br /><a href="https://zhuanlan.zhihu.com/p/119452913">各种 RAID 详解</a></p><ul><li>RAID3是如何找到错误并纠错的？</li><li>RAID50 的容量利用率为什么比RAID5 高</li><li>关于RAID 2的思考题</li></ul><p>在已知坏了哪2块盘的情况下，RAID 2是否能够重构数据？</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668702216809-9f66c46f-12ee-48f1-a8f7-7d6786847a21.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668505094811-f40d5c16-15d0-4fbb-b581-cf5b565c0064.png" alt="image.png"></p><ul><li>RAID10：结合RAID0 和RAID1</li><li>大IO 小IO：大小描述数据量的多少<br><a name="YPRMc"></a></li></ul><h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h2><p>按条带的顺序而不是磁盘的顺序存储数据。从条带0、条带1……进行存储，而不是存完磁盘1后再存磁盘2<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668702198817-0a7b4ce8-592e-40fa-b868-67050c1df025.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668505569008-a1f5c31a-d2a9-4ac7-aa0d-9ef2609e126f.png" alt="image.png"><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668505609551-624c04a2-e7e6-448b-8785-6edb6834b87d.png" alt="image.png"><br />与单个大容器磁盘相比：</p><ul><li>高数据传输率：多个硬盘可以同时提供读写操作（每个硬盘都有缓存，提高传输速率）<strong>针对大的数据块</strong></li><li>高速响应I&#x2F;O请求：<strong>两个I&#x2F;O</strong>请求所需要的数据块可能<strong>在不同的磁盘上 针对的是小的IO块</strong></li></ul><p><strong>缺点：数据可靠性比单盘低。因为只要有一个磁盘出错了，整个RIAD0就无法正常工作</strong><br><a name="o5kWn"></a></p><h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h2><p>读取速度是单盘的两倍 — 因为可以同时使用两个条带<br />写入速度受限于两个条带中更慢的磁盘。</p><ul><li>优点</li></ul><ol><li>高速响应IO请求:即便是<strong>同一个磁盘上</strong>的数据块，也可以由<strong>两组硬盘（原装+备份）分别响应</strong></li><li>读请求可以由包含请求数据的两个对应磁盘中的某一个提供服务，可以<strong>选择寻道时间较小的那个（选择磁头位置离目标位置更近的）</strong></li><li>写请求需要更新两个对应的条带:可以并行完成，但<strong>受限于写入较慢的磁盘</strong>。</li><li>单个磁盘损坏时不会影响数据访问，<strong>恢复受损磁盘简单</strong></li><li><strong>小IO请求可以由两组硬盘响应，所以读取速度是单盘两倍。大IO请求可能设计到同一磁盘的多个条带，所以比单盘块，但是没有涉及到两倍的速度</strong></li></ol><ul><li>缺点：价格昂贵，有一半的磁盘用于存放冗余数据</li><li>用途</li></ul><ol><li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li></ol><ul><li>与RAIDO相比</li></ul><ol><li>如果有<strong>大批的读请求</strong>，则RAID 1能实现高速的IO速率，性能可以达到RAID 0（<strong>如果两个条带都在一个单盘上时，只能和普通单盘一样去响应</strong>）的两倍</li><li>如果IO请求有相当大的部分是写请求，则它不比RAID 0的性能好多少</li></ol><ul><li>采用了数据条带</li><li>采用简单地<strong>备份所有数据的方法</strong>来实现冗余</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668505752836-d076f564-d0ed-403d-8a25-83f60f432e05.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668506181935-38580cc6-c7cf-4a7a-b9ef-67d21ab6136c.png" alt="image.png"><br><a name="Eh0c6"></a></p><h2 id="RAID10-和-RAID01比较"><a href="#RAID10-和-RAID01比较" class="headerlink" title="RAID10 和 RAID01比较"></a>RAID10 和 RAID01比较</h2><ol><li><strong>RAID10比RAID01安全性要好</strong></li><li>RAID1的特性是同一组的磁盘互为镜像，其中一个损坏时，<strong>同组的另一个会代替损坏的继续提供服务</strong></li><li>RAID0没有冗余功能，<strong>任何一个磁盘的损坏就会导致的数据不可用。</strong></li><li>RAID01可以当做普通的RAID1</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668672966673-85910e16-3028-4e35-831b-677b1d24cff9.png" alt="image.png"><br />因此，对于RAID 01</p><ul><li>如果Disk0坏了，Disk1是不能正常工作的 – 是不能配合Disk2工作的</li><li>如果Disk3坏了，Disk2也是不能正常工作的</li></ul><p>对于RAID 10</p><ul><li>如果Disk0坏了，同组的Disk1仍然可以正常工作 – 可以配合Disk2工作</li><li>如果Disk3坏了，同组的Disk2也是可以正常工作的<br><a name="x7bwO"></a></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>RAID0解决的是条带化的问题。多个磁盘，不是独立的应用，而是条带化，一起使用</li><li>RAID1解决的是冗余的问题，通过直接的简单备份，提高数据的可用性、容错能力</li><li>RAID10和RAID01的搭配问题<br><a name="zhq8d"></a></li></ol><h2 id="RAID2"><a href="#RAID2" class="headerlink" title="RAID2"></a>RAID2</h2><p>并行存取的特点：</p><ol><li>各个驱动器的轴同步旋转</li><li>采用非常小的数据条带</li></ol><p>并行存取的目标：<strong>所有</strong>磁盘都参与<strong>每个</strong>io请求（不论大小）。<br /><strong>条带很小</strong>：写入时才能让所有磁盘都能调用。因为一个条带必须用满了才能使用下一个条带，所以条带需要很容易被填满。从而使得所有磁盘都参与进去。<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668672924570-bed0abee-c51e-462a-abdd-359a657b997c.png" alt="image.png"></p><ul><li>利用海明码校验，根据公式<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/c3c20b7c5e26e4fda0b3b2188b2355bf.svg"></li><li>在写入时，RAID 2在<strong>写入数据位同时</strong>还要<strong>计算出它们的汉明码并写入校验阵列</strong>，读取时也要对数据即时地进行校验，最后再发向系统。</li><li><strong>海明码只能对一个位的出错进行定位和纠错</strong>，所以RAID 2也只能允许一个硬盘出问题，如果两个或以上的硬盘出问题，RAID 2的数据就将受到破坏</li><li>RAID0的条带是KB级，RAID2的条带是字节级。同样很小的IO请求，RAID0只需要一个盘，RAID2需要4个数据盘</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668673179868-9c487527-463e-4f75-aa86-ac93edfcabde.png" alt="image.png"></p><ul><li>单个磁盘本身具有校验位</li></ul><p>磁盘数量：<code>n+m</code>，m个磁盘用来存储校验位<br><a name="x7Yr2"></a></p><h2 id="RAID3"><a href="#RAID3" class="headerlink" title="RAID3"></a>RAID3</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668703045075-e6abfe0f-3fb9-43de-a6c3-319d8d0d3334.png" alt="image.png"><br><br /><br>RAID 3 是把数据分成多个“位元组”，按照 一定的容错算法，连续存放在N+1个磁盘上，<strong>N个磁盘存数据，第N+1个磁盘上存储校验容错信息</strong>，当这N+1个磁盘中的一个磁盘出现故障时，依据其它N个硬盘中的数据，可以恢复完整的原始数据，这样，仅使用这N个硬盘也可以带伤继续工作（如采集和回放素材），当更换一个新硬盘后，系统可以重新恢复。<br />奇偶校验码只能发现有错，不能发现谁出错了。在RAID中，是为了防止<strong>磁盘坏了</strong>，而不是数据出错。磁盘坏了，能够清楚的<strong>明确是哪一个磁盘出错了</strong>，而数据出错则无法发现。<strong>在RAID中的冗余，是为了防止磁盘损坏</strong><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668673540430-fc64810c-9495-4467-b33e-fa1f8af415de.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668673915863-5ebb1285-2abf-4a20-a8fc-b7be05e627b4.png" alt="image.png"></p><ul><li>奇偶校验码码距是2，只具有检错的能力，不具有纠错的能力，不能纠错是因为不知道哪一位数据出错了</li><li>磁盘损坏是已知的，所以通过奇偶校验可以知道是哪一个出错了<blockquote><p>RAID 3 使用字节级别的条带化技术，并<strong>采用专用的奇偶校验磁盘</strong>。RAID 3 阵列能在一个磁盘出现故障的情况下确保数据不丢失。如果一个物理磁盘出现故障，该磁盘上的数据可以重建到更换磁盘上。如果数据尚未重建到更换驱动器上，而此时又有一个磁盘出现故障，那么阵列中的所有数据都将丢失。</p></blockquote></li></ul><p><a name="bdbj8"></a></p><h2 id="RAID4"><a href="#RAID4" class="headerlink" title="RAID4"></a>RAID4</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668674101595-1f204daf-2380-48d2-a1d2-3253f7d6f9e5.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668674199002-ba45f835-cdeb-4b73-b4e2-cfc27602f1e9.png" alt="image.png"></p><ul><li>不需要向RAID3一样所有盘都同步传动</li><li>瓶颈：写入四个盘时，都会争夺同一个校验盘（<strong>校验盘指的是一整个磁盘，因为磁盘本身是同步转动的</strong>），因此会产生瓶颈。<strong>无法实现写操作的独立</strong></li><li>两次读写：当写入一位数据时，因为需要同步修改校验码，所以需要修改校验码。同时，由于不知道其他盘的数据，因此需要知道该盘之前的数据以及之前的校验码，所以需要写两次和读两次。<strong>读两次：读旧的数据和旧的校验码，写两次：写新的数据和新的校验码</strong></li></ul><p>对于小IO请求，也需要使用奇偶校验码，看上去使用了4位，4个任务都会争夺同一个校验码。对于RAID3，因为读写同步，所以b1 b2 b3都是已知的，但是对于RAID4，写入B0时，其他的都是未知的，需要读出B1 B2 B3。所以，写入之前，先把<code>P(B)</code>   <code>B0</code>都先读出来。每一次写操作，实际上都要<strong>写两次，读两次</strong><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668674833267-027f9199-002c-493e-a577-cdc3b4b3c76a.png" alt="image.png"><br><a name="vFa3i"></a></p><h2 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h2><blockquote><ol><li>RAID5 应该是目前最常见的 RAID 等级，它的原理与 RAID4 相似，<strong>区别在于校验数据分布在阵列中的所有磁盘上，而没有采用专门的校验磁盘。</strong>对于数据和校验数据，它们的写操作可以同时发生在完全不同的磁盘上。因此， RAID5 不存在 RAID4 中的并发写操作时的校验盘性能瓶颈问题。</li><li>RAID5 的磁盘上同时存储数据和校验数据，<strong>数据块和对应的校验信息存保存在不同的磁盘上</strong>，当一个数据盘损坏时，<strong>系统可以根据同一条带的其他数据块和对应的校验数据来重建损坏的数据</strong>。与其他 RAID 等级一样，重建数据时， RAID5 的性能会受到较大的影响。</li></ol></blockquote><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668674484168-d8a5e506-0168-4d4a-9bf3-4748335df37c.png" alt="image.png"></p><ul><li>没有单独的校验盘，没有单独的数据盘</li><li>避免RAID4中集中访问同一个校验盘的现象</li><li>修改时还是会涉及到<strong>两读两写</strong></li><li><strong>在写操作时，一个平面的块都会受到影响，无法写入，但是相比RAID 4，不会对一整个磁盘造成影响。例如块0和块9，在不同平面，在RAID5中不会有冲突，但是在RAID 4中就会造成冲突</strong><br><a name="B1xwQ"></a></li></ul><h2 id="RAID-50"><a href="#RAID-50" class="headerlink" title="RAID 50"></a>RAID 50</h2><blockquote><p>RAID 5与RAID 0的组合，先作RAID 5，再作RAID 0，也就是对多组RAID 5彼此构成Stripe访问。由于RAID 50是以RAID 5为基础，而<strong>RAID 5至少需要3颗硬盘</strong>，因此要以多组RAID 5构成RAID 50，至少需要6颗硬盘。以RAID 50最小的6颗硬盘配置为例，先把6颗硬盘分为2组，每组3颗构成RAID 5，如此就得到两组RAID 5，然后再把两组RAID 5构成RAID 0。<br>RAID 50在底层的任一组或多组RAID 5中出现1颗硬盘损坏时，仍能维持运作，不过如果任一组RAID 5中出现2颗或2颗以上硬盘损毁，整组RAID 50就会失效。<br>RAID 50由于在上层把多组RAID 5构成Stripe，<strong>性能比起单纯的RAID 5高，容量利用率比RAID5要低</strong>。比如同样使用9颗硬盘，由各3颗RAID 5再组成RAID 0的RAID 50，每组RAID 5浪费一颗硬盘，利用率为(1-3&#x2F;9)，RAID 5则为(1-1&#x2F;9)。</p></blockquote><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668675235775-9454f75a-079d-41ed-863c-f1ca012cef8b.png" alt="image.png"><br />用3个磁盘空间去做奇偶校验，而如果只是RAID5，则只需要用一个磁盘的空间<br><a name="vHKMr"></a></p><h2 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h2><ul><li>前面所述的各个 RAID 等级都<strong>只能保护因单个磁盘失效而造成的数据丢失</strong>。如果两个磁盘同时发生故障，数据将无法恢复。 RAID6 引入<strong>双重校验</strong>的概念，它<strong>可以保护阵列中同时出现两个磁盘失效时，阵列仍能够继续工作，不会发生数据丢失</strong>。 RAID6 等级是在 RAID5 的基础上为了进一步增强数据保护而设计的一种 RAID 方式，它可以看作是一种扩展的 RAID5 等级。</li><li>RAID6 不仅要支持数据的恢复，还要支持校验数据的恢复，因此实现代价很高，控制器的设计也比其他等级更复杂、更昂贵。 <strong>RAID6 思想最常见的实现方式是采用两个独立的校验算法</strong>，假设称为 P 和 Q ，校验数据可以分别存储在两个不同的校验盘上，或者分散存储在所有成员磁盘中。<strong>当两个磁盘同时失效时，即可通过求解两元方程来重建两个磁盘上的数据。</strong></li><li>RAID6 具有快速的读取性能、更高的容错能力。但是，它的<strong>成本要高于 RAID5 许多，写性能也较差</strong>，并有设计和实施非常复杂。因此， RAID6 很少得到实际应用，主要用于对数据安全等级要求非常高的场合。它一般是替代 RAID10 方案的经济性选择</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668675293673-f7a370f3-3233-4932-bb5c-156b133a221c.png" alt="image.png"><br><a name="MgIW2"></a></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668703858623-88a01b8a-8ac7-48ea-a149-b293be444d8b.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668675564994-2e8d74a6-8f92-4c9d-84d9-9dce33907f99.png" alt="image.png"><br><br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668675632716-b5bb40ae-f19c-4f7c-a1c8-0ebcdd01727a.png" alt="image.png"><br><br /><br>RAID3适合大数据的单次的IO读写，按顺序读写-寻道时间更少<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668675671383-a37e8860-2040-44a5-8f23-2f33d32be087.png" alt="image.png"><br><br />RAID2 RAID4已经弃用了</p><hr><p>RAID 0：如果你有n块磁盘，原来只能同时写一块磁盘，写满了再下一块，做了RAID 0之后，n块可以同时写，速度提升很快，但由于没有备份，可靠性很差。n最少为2。<br />RAID 1：正因为RAID 0太不可靠，所以衍生出了RAID 1。如果你有n块磁盘，把其中n&#x2F;2块磁盘作为镜像磁盘，在往其中一块磁盘写入数据时，也同时往另一块写数据。坏了其中一块时，镜像磁盘自动顶上，可靠性最佳，但空间利用率太低。n最少为2。<strong>写操作可以并行完成</strong><br />RAID 3：为了说明白RAID 5，先说RAID 3.RAID 3是若你有n块盘，其中1块盘作为校验盘，剩余n-1块盘相当于作RAID 0同时读写，当其中一块盘坏掉时，可以通过校验码还原出坏掉盘的原始数据。这个校验方式比较特别，<strong>奇偶检验</strong>，1 XOR 0 XOR 1&#x3D;0，0 XOR 1 XOR 0&#x3D;1，最后的数据时校验数据，当中间缺了一个数据时，可以通过其他盘的数据和校验数据推算出来。但是这有个问题，由于n-1块盘做了RAID 0，每一次读写都要牵动所有盘来为它服务，而且万一校验盘坏掉就完蛋了。<strong>最多允许坏一块盘</strong>。n最少为3.<br />RAID 5：在RAID 3的基础上有所区别，同样是相当于是1块盘的大小作为校验盘，n-1块盘的大小作为数据盘，但校验码分布在各个磁盘中，不是单独的一块磁盘，也就是分布式校验盘，这样做好处多多。最多坏一块盘。n最少为3.<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668703844625-2b4cfea9-a8f9-4d60-adaf-232a18531f30.png" alt="image.png"></p><ul><li>RAID 3 是采取<strong>并行存取技术</strong>，所以只需要一次写操作和一次读操作就能更新校验码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十七课 输入输出</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AF%BE%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AF%BE%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092964050-b0e027e7-bc8e-4829-a530-a148b4e45cf1.png" alt="image.png"><br><a name="nE4qE"></a></p><h2 id="I-x2F-O模块"><a href="#I-x2F-O模块" class="headerlink" title="I&#x2F;O模块"></a>I&#x2F;O模块</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093087561-d646c3ca-3b7d-48fe-88de-e325489b8ea9.png" alt="image.png"><br><a name="wW1Fq"></a></p><h3 id="外围设备的接口"><a href="#外围设备的接口" class="headerlink" title="外围设备的接口"></a>外围设备的接口</h3><p>转换器：外设的数据格式和计算机内部的数据格式可能不一致<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093193022-7d5eedaa-0baf-4319-823d-b3a910548468.png" alt="image.png"><br><a name="PlgC4"></a></p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093407597-d8eb7ef7-f7f6-4f2d-a13a-7a98d555997d.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093513588-823d2062-a477-498d-8e52-25f669c46e16.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093735022-348f6ecf-41aa-40a1-a1ea-e50dff7f9168.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671093853802-b9ae09b6-fe76-447a-9f29-55c44f39015b.png" alt="image.png"><br><a name="m9WZ2"></a></p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671094127152-0da4f1d4-1aa5-41fa-b8c9-e9ed5d443490.png" alt="image.png"></p><ul><li>CPU对外设的命令是走数据线的，是具体的操作</li><li>状态和控制不是同一时间发生，只有确认了状态后，才能确认控制。状态是从右往左返回，控制是从左往右返回</li><li>数据寄存器实际上是输入寄存器和输出寄存器的合并<br><a name="e1inL"></a></li></ul><h4 id="外部接口"><a href="#外部接口" class="headerlink" title="外部接口"></a>外部接口</h4><p>事实上，并行接口，每一根线的延迟可能是不一样的，当线的长度非常长时，每一位传输时就会导致错位，数据传输出错。<br />所以，需要按照一定频率传输<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671094339336-88e79342-c69f-44a6-8172-9d16892fa542.png" alt="image.png"><br><a name="cbgly"></a></p><h4 id="串行总线"><a href="#串行总线" class="headerlink" title="串行总线"></a>串行总线</h4><ul><li>批量传输比同步传输多了“握手”，是为了实现<strong>异步</strong></li><li>同步传输：传送音视频时，需要同步。音视频对实时性的要求较高；允许一定的误码率</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671094569227-cd489685-adec-429e-bbf6-cd331cdf06b4.png" alt="image.png"><br><a name="Aqr1z"></a></p><h2 id="I-x2F-O操作技术"><a href="#I-x2F-O操作技术" class="headerlink" title="I&#x2F;O操作技术"></a>I&#x2F;O操作技术</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671095525199-68ebb65d-fad4-4811-b3a9-cda3794389b9.png" alt="image.png"><br><a name="uKPNs"></a></p><h3 id="编程式I-x2F-O"><a href="#编程式I-x2F-O" class="headerlink" title="编程式I&#x2F;O"></a>编程式I&#x2F;O</h3><p>缺点：比较低效？<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671095898490-1402e9b6-37b2-4785-88de-193d125eeca5.png" alt="image.png"><br><a name="wuNWA"></a></p><h4 id="I-x2F-O命令"><a href="#I-x2F-O命令" class="headerlink" title="I&#x2F;O命令"></a>I&#x2F;O命令</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096036418-f99e8058-f321-48f5-b18c-edc79c8530d2.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096107530-655b7a58-ef2f-4139-84c4-d69942c4922a.png" alt="image.png"></p><ul><li>CPU需要做什么 - 指令</li><li>I&#x2F;O需要做什么 - 命令<br><a name="PDNTN"></a></li></ul><h3 id="中断驱动式I-x2F-O"><a href="#中断驱动式I-x2F-O" class="headerlink" title="中断驱动式I&#x2F;O"></a>中断驱动式I&#x2F;O</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096337526-b350ddfe-4c1b-488b-8e94-f1adff4e3e77.png" alt="image.png"><br><a name="hSAwA"></a></p><h4 id="模块理解"><a href="#模块理解" class="headerlink" title="模块理解"></a>模块理解</h4><ul><li>I&#x2F;O模块等处理器，而不是处理器等I&#x2F;O了</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096515962-86e808e7-0488-4d59-9689-023fcbd0de84.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096596053-66c6bb00-ec53-4f0f-ac9f-2b29780358fc.png" alt="image.png"><br><a name="B9NcS"></a></p><h4 id="中断允许和中断禁止"><a href="#中断允许和中断禁止" class="headerlink" title="中断允许和中断禁止"></a>中断允许和中断禁止</h4><ol><li>中断处理之前，要保存现场</li><li>保存现场时，不能被中断。所以中断响应后，要进入中断禁止，保护现场</li><li>恢复现场时，也不能被中断</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671096773626-57c52056-552d-4964-8ec5-594321a48c1a.png" alt="image.png"></p><p><a name="sYj5L"></a></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671097206942-6ab2d824-8025-4b8d-8ee9-bca3fea55158.png" alt="image.png"></p><ol><li>主程序的响应优先级和处理优先级的最低</li><li>先执行和处理完L1（L3 L4的处理优先级比L1低），回到主程序</li><li>先响应3，但是先处理完L4</li><li>恢复L3，发生了L2中断，但是L2的处理优先级低于L3，所以先处理L3</li></ol><p><strong>处理优先级决定哪些中断可以被响应，响应优先级决定哪些中断最先被响应</strong><br /><strong>行屏蔽是从处理优先级的角度出发的</strong><br><a name="QyvRS"></a></p><h4 id="设备识别"><a href="#设备识别" class="headerlink" title="设备识别"></a>设备识别</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671097342189-5f34c4b6-dd42-4d30-b78f-192778334e48.png" alt="image.png"><br><a name="OZUXo"></a></p><h3 id="直接存储器存取-DMA"><a href="#直接存储器存取-DMA" class="headerlink" title="直接存储器存取 DMA"></a>直接存储器存取 DMA</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671097553947-c02d296e-f133-4716-af15-982d51221831.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671097702884-b866c684-3e96-4b27-8656-aa7d0f7c87ec.png" alt="image.png"></p><ul><li>DMA和CPU访问同一块内存时，可能会导致冲突<br><a name="kAlv8"></a></li></ul><h4 id="DMA内存访问：CPU停止法"><a href="#DMA内存访问：CPU停止法" class="headerlink" title="DMA内存访问：CPU停止法"></a>DMA内存访问：CPU停止法</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671097979359-580da163-ee98-444d-b288-e9062336671c.png" alt="image.png"><br><a name="x6TRy"></a></p><h4 id="DMA内存访问：周期窃取"><a href="#DMA内存访问：周期窃取" class="headerlink" title="DMA内存访问：周期窃取"></a>DMA内存访问：周期窃取</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671098030143-2c2dde0e-8e15-4b2b-9d16-02ff8b52ed59.png" alt="image.png"><br />断断续续：存储周期处于空闲状态。一次IO请求可能会有多次DMA访存<br><a name="TeNwY"></a></p><h4 id="DMA内存访问：交替分时访问"><a href="#DMA内存访问：交替分时访问" class="headerlink" title="DMA内存访问：交替分时访问"></a>DMA内存访问：交替分时访问</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671098195384-c84307a0-a2a4-4358-a9d0-1b52dc70bea9.png" alt="image.png"><br><a name="rxceT"></a></p><h4 id="DMA配置机制：单总线分离DMA"><a href="#DMA配置机制：单总线分离DMA" class="headerlink" title="DMA配置机制：单总线分离DMA"></a>DMA配置机制：单总线分离DMA</h4><p><a name="fUNAy"></a></p><h4 id="单总线集合的DMA"><a href="#单总线集合的DMA" class="headerlink" title="单总线集合的DMA"></a>单总线集合的DMA</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671098378607-c95fdc3e-a6a6-4ddc-b923-c3126a62e70f.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671098413471-c4398552-0841-43d5-8597-01aaa3e85394.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671529051743-1938edaa-753d-4131-921a-f3171431780a.png" alt="image.png"><br />CPU还在操控，但是不等待<br><a name="ELnew"></a></p><h2 id="I-x2F-O模块的演变"><a href="#I-x2F-O模块的演变" class="headerlink" title="I&#x2F;O模块的演变"></a>I&#x2F;O模块的演变</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671529094550-d4297325-a0ec-4f2d-80d1-9d0b8f5f455f.png" alt="image.png"><br><br />I&#x2F;O处理器不仅有处理器，同时也有了局部存储器<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671529173900-2335dbc1-7bb5-484a-9cba-f616a1639309.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十六课 控制器</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AF%BE%20%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AF%BE%20%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a name="BRwKC"></a></p><h2 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919267410-b94ec08c-05ac-449c-919f-031d7d8674cf.png" alt="image.png"></p><ul><li>用户：特指<strong>编程人员</strong></li><li>可见：通过编程语言访问</li><li>状态寄存器：没有必要让编程人员访问，也不应该可见<ul><li>会导致不安全的情况</li><li>程序出现漏洞的风险也会增高</li><li>指令集的复杂度也会增加，效率降低<br><a name="gfdqI"></a></li></ul></li></ul><h3 id="用户可见寄存器"><a href="#用户可见寄存器" class="headerlink" title="用户可见寄存器"></a>用户可见寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919504581-833c4d81-e3f5-4a76-ae7d-0167b57216f6.png" alt="image.png"><br />条件码寄存器不是必须的。缺点：硬件复杂性增加<br><a name="iHNFa"></a></p><h4 id="设计出发点"><a href="#设计出发点" class="headerlink" title="设计出发点"></a>设计出发点</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919636491-3d32eb25-46dc-40f3-8577-7f9cb58cd6a8.png" alt="image.png"><br><a name="G79C6"></a></p><h4 id="保存和恢复"><a href="#保存和恢复" class="headerlink" title="保存和恢复"></a>保存和恢复</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919811007-34076bad-ede8-40d3-ac75-c8b6238983c1.png" alt="image.png"><br><a name="A2wGH"></a></p><h3 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919880475-246bf2a4-189f-44f4-8f70-63e43e5f22fd.png" alt="image.png"><br><br /><code>PC</code>是可见的<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670919980960-f01b11a6-0a3a-4a0e-821e-fb049ecc856c.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920013758-9acefedd-9918-49fe-a397-cf2afa4620ab.png" alt="image.png"><br><a name="yDFme"></a></p><h4 id="设计出发点-1"><a href="#设计出发点-1" class="headerlink" title="设计出发点"></a>设计出发点</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920061137-5ee03a91-a0d4-4ad2-a8c3-6b498f92b717.png" alt="image.png"><br><a name="JFQzs"></a></p><h2 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h2><p><a name="jbGbq"></a></p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920320585-fce0f067-ad8e-4215-883c-0c429b8ddc6b.png" alt="image.png"><br><a name="KW0ws"></a></p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920401702-9d3ce9cb-112c-43a2-b978-231abda3f33c.png" alt="image.png"><br><a name="lgfCS"></a></p><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920577701-e5ef5114-9804-4636-a5d8-bd4401951de3.png" alt="image.png"><br><a name="nuD1B"></a></p><h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920615142-39d5a8ec-56dc-453c-81c5-902d046e14e1.png" alt="image.png"><br><br />为什么是<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/64636e8771ef215128139253c19e840a.svg"><br><a name="nVEMI"></a></p><h2 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670920926888-8a8daa14-86b0-4e14-a571-30406aa00211.png" alt="image.png"><br><a name="gDz4A"></a></p><h3 id="分组原则"><a href="#分组原则" class="headerlink" title="分组原则"></a>分组原则</h3><p>通过放在前后的时间周期内，让时间的流动顺序恰当<br />对同一个寄存器进行读写，不能放在同一个时间周期内<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670921380192-1f213a4c-3bd9-4a7e-a35c-c0ef2679ec12.png" alt="image.png"><br><a name="HYPOh"></a></p><h3 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670921071143-60ece1e9-30f3-4388-8cc0-ff65658979a1.png" alt="image.png"><br />t1：数据通过MAR传给地址总线<br />t2：对应两个微操作</p><ul><li>取出指令放到数据总线上</li><li>PC+”1” <strong>要当心同步、异步 — 发送在同一个时间单位内</strong></li></ul><p>每一个<code>t</code>表示一个时间单位，表示微操作发送在哪一个时间单位内。<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676278523396-e3840dbe-3f21-4676-abab-1a1476fb7136.png" alt="image.png"><br />调整了<code>pc + 1</code>的位置<br><a name="mhhov"></a></p><h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p>将间接地址转换成有效地址<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676278788647-3d63125c-b97e-4e52-af77-2946c0253697.png" alt="image.png"> </p><ol><li>IR中存了取到的指令，将指令中的地址部分放到MAR中</li><li>将地址对应的内容从存储器中放到MBR中</li><li>替换IR的地址部分<br><a name="TZTmR"></a></li></ol><h3 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670921628782-56c3af73-0ac2-4068-9815-af825b50c551.png" alt="image.png"></p><ol><li>送地址后才能取到内容，所以t1和t2不能合并</li><li><code>t2</code>是写<code>MBR</code>，<code>t3</code>是读<code>MBR</code>，所以不能合并</li></ol><p>转移并保存：保存PC地址，并跳转到一个新的地址</p><ol><li>将IR中的地址送到MAR中，告诉MAR，PC要存到哪里，该地址是PC要保存到的地址。把PC的内容送到MBR中。这俩个步骤互相独立，可以存放在同一个时间周期内。</li><li>把MBR的内容写到主存中，把新的地址存到PC中。只有PC保存了，才能更新PC；只有写入了MBR，才能继续读MBR</li><li>PC+1<br><a name="fGC5U"></a></li></ol><h3 id="中断周期？"><a href="#中断周期？" class="headerlink" title="中断周期？"></a>中断周期？</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676280174445-3d2b645b-a50c-452e-8184-9f1f59fe1696.png" alt="image.png"><br />只需要两个时间单位<br><a name="KfHQA"></a></p><h2 id="指令周期代码-ICC"><a href="#指令周期代码-ICC" class="headerlink" title="指令周期代码 ICC"></a>指令周期代码 ICC</h2><p><strong>取指、间址、中断周期各有一个微操作序列</strong>，执行周期则对于<strong>每个操作码有一个微操作序列</strong><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670923075438-d6d8e465-8686-4a40-b27c-8526d10f6896.png" alt="image.png"><br><a name="uOKF1"></a></p><h3 id="取指周期-1"><a href="#取指周期-1" class="headerlink" title="取指周期"></a>取指周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676280691528-bbc07979-212b-4fec-99ce-282976e7cc33.png" alt="image.png"><br><a name="tMwuv"></a></p><h3 id="间址周期-1"><a href="#间址周期-1" class="headerlink" title="间址周期"></a>间址周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676280775169-d67730ae-883a-40a8-bdd4-09b8a62d4d85.png" alt="image.png"><br><a name="vGdBp"></a></p><h3 id="执行周期-1"><a href="#执行周期-1" class="headerlink" title="执行周期"></a>执行周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676280817628-3d293da8-8921-4ba2-9e5e-e21a587769f4.png" alt="image.png"><br><a name="JXVaS"></a></p><h3 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676280899073-1d33d56f-2433-47f7-9f6c-d696c17dd9f1.png" alt="image.png"><br><a name="mlWDz"></a></p><h2 id="CPU内部总线"><a href="#CPU内部总线" class="headerlink" title="CPU内部总线"></a>CPU内部总线</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676281035906-53dbaff2-32e7-4ae7-adc8-7e12974ea3de.png" alt="image.png"><br><a name="LrJFt"></a></p><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p><a name="j278F"></a></p><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676281278060-8d173a61-1a73-453e-821c-54461a8baa9c.png" alt="image.png"><br><a name="mMIIK"></a></p><h3 id="控制器的输入"><a href="#控制器的输入" class="headerlink" title="控制器的输入"></a>控制器的输入</h3><p>操作码影响执行周期<br />寻址方式影响间址周期<br /><strong>控制器也会收到控制信号：中断请求</strong><br /> <img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924080197-92f1345a-44b0-4fd6-b352-a2ad677591fb.png" alt="image.png"><br><a name="VGiFM"></a></p><h3 id="控制器的输出"><a href="#控制器的输出" class="headerlink" title="控制器的输出"></a>控制器的输出</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924058358-da3ce790-1839-46be-937f-a330ae23528b.png" alt="image.png"><br><a name="OHh5Y"></a></p><h3 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924483599-b92aeb4a-7e93-4064-91ab-8445e1ea85be.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676281867546-98feb1b3-1158-412b-bb4a-91f8eb712476.png" alt="image.png">（图有点小问题）<br><a name="mjmzm"></a></p><h3 id="控制器的最小特性"><a href="#控制器的最小特性" class="headerlink" title="控制器的最小特性"></a>控制器的最小特性</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924690734-76f534ec-3118-4d4e-8e78-eabeba97f725.png" alt="image.png"><br />实现上尽可能地简洁<br><a name="K8fzg"></a></p><h2 id="控制器实现"><a href="#控制器实现" class="headerlink" title="控制器实现"></a>控制器实现</h2><p><a name="e3A87"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924736797-818d155f-84a8-425a-8e59-d6f108c9de65.png" alt="image.png"></h4><p><a name="rRAKd"></a></p><h3 id="硬布线实现"><a href="#硬布线实现" class="headerlink" title="硬布线实现"></a>硬布线实现</h3><p><a name="L0ANx"></a></p><h4 id="控制器输入"><a href="#控制器输入" class="headerlink" title="控制器输入"></a>控制器输入</h4><p>时钟、标志、控制总线的输入、指令寄存器</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924821550-85ba9bbb-1562-4713-80e2-963a120852ae.png" alt="image.png"><br><br />操作码通过译码器转化为微操作序列<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670924860619-1d10e097-e753-49c0-b8bb-b285856ec712.png" alt="image.png"><br><a name="IwrJu"></a></p><h4 id="控制器逻辑"><a href="#控制器逻辑" class="headerlink" title="控制器逻辑"></a>控制器逻辑</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670925024608-139dd57a-92b9-4aae-8f1c-46031c93a366.png" alt="image.png"><br />缺点：太过复杂<br><a name="NhjWi"></a></p><h3 id="微程序实现？"><a href="#微程序实现？" class="headerlink" title="微程序实现？"></a>微程序实现？</h3><p>和硬布线实现有什么不同<br><a name="tf8By"></a></p><h4 id="基本概念和思路"><a href="#基本概念和思路" class="headerlink" title="基本概念和思路"></a>基本概念和思路</h4><ul><li>微程序(固件)介于硬件与软件之间</li><li>设计固件比设计硬件容易，但写固件程序比软件程序困难·微指令序列</li><li>微指令∶<strong>每行</strong>描述一个时间内出现的<strong>一组微操作</strong>。</li></ul><p>基本思路</p><ul><li>对于每个微操作，控制器的任务是产生<strong>一组控制信号</strong>，即控制器发出的<strong>每根控制线或开或关</strong>（每根控制线由一个二进制数字表示）·构造一个控制字，每位代表一根控制线，这样每个微操作能用控制字中的不同的0和1的样式来表示</li><li>将这些控制字串在一起，可以表示控制器需要完成的微操作序列</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1670925452420-15ec817d-0ecb-4f92-8b9e-3747a0d218b5.png" alt="image.png"><br><a name="yIwzn"></a></p><h3 id="微程序执行？"><a href="#微程序执行？" class="headerlink" title="微程序执行？"></a>微程序执行？</h3><p>取指、间接、中断的微操作序列是一样的，都可以用相同的微指令** ？ 为什么是一样的**<br />相同的操作码可以用相同的微指令序列<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676300014626-a8f2f12a-c1d1-44a6-bded-c06f4a19dcde.png" alt="image.png"><br><a name="QQce4"></a></p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671091969058-f30ca772-1c3f-45ce-9b46-13fdd746c7ef.png" alt="image.png"><br><a name="l6F1h"></a></p><h4 id="定序"><a href="#定序" class="headerlink" title="定序"></a>定序</h4><p>下一个指令的地址在哪？<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092076221-584ed9b1-f56e-48c2-964c-08168387ac63.png" alt="image.png"><br />双地址：指令太长，成本上升<br />地址选择有不同的方式。<br><a name="G6wv4"></a></p><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1676300598587-c67eb512-c1e2-4278-892e-7f0b9e22843b.png" alt="image.png"><br><a name="PSznR"></a></p><h4 id="工作流程？？"><a href="#工作流程？？" class="headerlink" title="工作流程？？"></a>工作流程？？</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092388440-552fbd64-9c06-49d9-946b-e5ec3eb1ac1a.png" alt="image.png"><br><br />下面这张图什么意思？<br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092511829-b0e54373-734f-494d-ad8d-d7a9a8445a6d.png" alt="image.png"></p><ul><li>操作码在指令寄存器中，需要进行译码器译码<br><a name="GnlTH"></a></li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092548608-5f84db8f-8a05-4361-9fc0-d82d24687646.png" alt="image.png"><br><a name="PsYUs"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1671092625274-a3d92e0f-6821-4343-bcf7-cd8c895f7189.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十二课 虚拟存储器</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a name="nFqlT"></a></p><h3 id="分区方式"><a href="#分区方式" class="headerlink" title="分区方式"></a>分区方式</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277706527-998432e0-a2fc-4508-a459-0462d95d9259.png" alt="image.png"><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277715931-9cb5eb6d-3720-4614-8410-6308a5873c48.png" alt="image.png"><br><a name="gg4z0"></a></p><h3 id="分页方式"><a href="#分页方式" class="headerlink" title="分页方式"></a>分页方式</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277748398-0cc4a6e2-fdca-4261-aa6d-4c371ba1833b.png" alt="image.png"><br><a name="L6lhU"></a></p><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277942468-ec1e84a3-ebaa-404a-82f7-12d0f536d4cf.png" alt="image.png"><br><br />只需要保证同时<strong>需要载入的页</strong>的大小是低于主存的大小就行。对于同一个任务，其实是每个时刻只会执行部分代码段，所以只需要载入部分页进入内存就行<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277966166-0c715239-9ac1-42b2-8d05-30ecde4fc470.png" alt="image.png"></p><ol><li>所有的任务的所有的页放入硬盘的特定区域中，也就是<strong>虚拟内存</strong></li><li>每个任务正在使用的页载入主存当中</li><li>没命中时主存从硬盘中加载；有修改时，硬盘也会从主存加载</li><li>页表：对每个任务生成一个页表，记录页的状态</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669277979600-731a069b-e5e4-4b80-8d9a-99071803ad2a.png" alt="image.png"></p><ul><li>全相联映射：命中率更高</li><li>写回：避免像写直达一样，多次对硬盘进行操作<br><a name="krw6M"></a></li></ul><h3 id="分页式虚拟存储器"><a href="#分页式虚拟存储器" class="headerlink" title="分页式虚拟存储器"></a>分页式虚拟存储器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669278432223-3b432e84-bedf-423a-b55a-9efc2a0488e8.png" alt="image.png"></p><ul><li>编写程序时，默认自己有一个很大的、连续的空间，所以记录在页表中的地址都是虚拟地址。</li><li>程序真正被启动时，会产生很多页面，载入硬盘中</li><li>把要用的页面真正载入主存中，由页表来记录</li><li>页表也存在主存中<br><a name="OrHIE"></a></li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669278909804-03e37ac1-149e-48c0-8717-bfab35e6db6a.png" alt="image.png"><br><a name="i21yx"></a></p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p><strong>物理页和虚拟页的大小是一样的。所以页内偏移量是一致的</strong><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669279021802-26aa3ba1-42dc-4880-b68b-4894c1759968.png" alt="image.png"></p><ul><li><code>null</code>磁盘没有存储VP0 VP4，对应的位置存储了其他信息<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669279176054-4dd0b82e-33cc-4447-9762-53cbe5f148b9.png" alt="A959A7B612035ABFFB13EF2EC4BE03A8.png"></li><li><code>PP0</code>物理页号：说明在主存中有载入</li><li>指针：说明在磁盘存储器中有，但是没有载入主存中。</li><li><strong>虚拟地址比物理地址更长</strong>，虚拟空间比物理空间更大，虚拟页号比物理页号的长度更长；<strong>存放位置时的指针长度比物理地址小</strong></li><li>不需要额外用空间记录虚拟页号，因为是按顺序排放的</li><li>**存放位置的长度是按照最长的物理地址存放的 **<br><a name="bgiXr"></a></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669279472951-53ed2a0f-fd94-4324-a79a-5247a2c03333.png" alt="image.png"><br><a name="JQN19"></a></p><h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669279512490-aad58c79-5266-41cd-8c4a-7076d662ddb1.png" alt="image.png"><br><a name="YxFIf"></a></p><h4 id="CPU访存过程"><a href="#CPU访存过程" class="headerlink" title="CPU访存过程"></a>CPU访存过程</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669280124191-614a3c12-4a15-49db-bfdd-fe3f90a7e44f.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669280143486-c3062d63-658c-4610-95dc-55cc0bf9d235.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669280570598-b997891c-1fd3-4266-a226-636230946178.png" alt="image.png"></p><ol start="2"><li>访问的是主存中的数据，因为在Cache中miss了</li><li>访问的是主存中的页表，数据仍然在Cache中</li><li>出现缺页情况，访问硬盘和访问主存速度差距非常大</li><li>TLB中有，页表中也一定有<br><a name="oXU29"></a></li></ol><h3 id="分段式虚拟存储器"><a href="#分段式虚拟存储器" class="headerlink" title="分段式虚拟存储器"></a>分段式虚拟存储器</h3><p>物理地址&#x3D; 段号左移4位+段内偏移量<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669280849606-3494bb7d-aff3-4ab5-a9b1-eaeac95777fd.png" alt="image.png"><br />分页式：对权限管理很混乱，每一个页都要单独记录权限<br />分段式：</p><ul><li>会有重复地址</li><li>长度不固定</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669281353237-f9a73a1a-49b5-4214-b7e9-149015592132.png" alt="image.png"><br><a name="huy5f"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1669281422445-f6f60a5a-1b1e-4cbc-8196-882371e9d52c.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十课 数据校验码</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E8%AF%BE%20%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%8D%81%E8%AF%BE%20%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><a name="PzQE5"></a></p><h3 id="差错"><a href="#差错" class="headerlink" title="差错"></a>差错</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668072243204-c84422fd-18cd-4ca5-97c2-7366d05627fa.png" alt="image.png"><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668072867915-b6daef4a-6422-4b57-999c-1f107467e5b4.png" alt="image.png"><br><a name="a31Gg"></a></p><h3 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668073261817-d8c44924-6189-48d8-b516-2ce0c440c03f.png" alt="image.png"><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668073252925-c5f59f43-da29-4d58-83bd-2d6c4c4dcfe0.png" alt="image.png"></p><p><a name="GeMKt"></a></p><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668073398885-759187f4-99e9-443d-aa0b-7e955548d242.png" alt="image.png"><br />判断奇数&#x2F;偶数：异或<br />奇偶校验：相差一个异或<code>1</code><br />多一个异或：相当于多一个非门，多了一级门延迟</p><ul><li>奇校验的作用：防止全<code>0</code>数据的传输（同步传输中），从而区分传输有无结束</li><li>偶校验：门延迟更低</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668073730554-ce6cab88-339c-4fca-8b08-af11c8e1114c.png" alt="image.png"><br />长度短：发生偶数位的差错概率更低<br><a name="wDvPo"></a></p><h2 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h2><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503322446-e867af91-1154-4612-a236-7b82d99bf2d0.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503335114-07b6101b-e172-475a-8851-b1dbbb92e96e.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503343047-fe6c229e-ddd4-4d5e-ba7a-33176ab4640d.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668501979453-d9c73b31-adbb-4d05-b53b-f24cadf82cf0.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503434104-33246edd-f80b-4c48-82d4-4fa881c09981.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503457828-645948bf-3dd6-428a-a76e-604d13dfd0f4.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503471385-27e56ca9-9909-4e67-9b7e-0c01897f0825.png" alt="image.png"><br><a name="eVelZ"></a></p><h3 id="码距和纠错理论"><a href="#码距和纠错理论" class="headerlink" title="码距和纠错理论"></a>码距和纠错理论</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668501191956-9a846bfd-f5f2-4104-ae87-3801e306d165.png" alt="image.png"><br><br /><br>奇偶校验的码距是2：如果D中有一位发生了变化则C中也有一位发生变化，如果D中有两位发生了变化，则C中没有变化<br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668502235956-3f49ff77-6d27-4bb3-9d95-e180e811e10b.png" alt="image.png"><br />海明码2.0：同时可以识别出2位出错的情况，是双检错，但依然是<strong>单纠错</strong><br />D1 D2出错和C5 D3出错的情况相同，所以只能具备单纠错的能力<br><a name="oOj3b"></a></p><h3 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503492488-add43037-7eeb-4440-acf0-667766475aef.png" alt="image.png"><br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503669170-2bbd8525-5af0-4c61-a7b7-a906eb1b130c.png" alt="image.png"><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668503682149-b77d16a1-7e9c-487e-a188-835d61841472.png" alt="image.png"></p><ul><li>无借位减，等价于异或运算</li><li>多项式1001对应的是<img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/3619ace3eb24da39bda024bcf29b14ac.svg" alt="image.png"></li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1668504591848-89723a4a-c613-452f-9732-b8d48931813a.png" alt="image.png"></p><ul><li>海明码1.0只适合1位出错的情况</li><li>奇校验码能增加1，区分出传送的00000000数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第四课 整数运算</title>
      <link href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%9B%9B%E8%AF%BE%20%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%9B%9B%E8%AF%BE%20%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p><a name="nhw6e"></a></p><h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><p><a name="Gpexo"></a></p><h3 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h3><p>前提假设：<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664467718264-0c488d43-4145-4ebd-8945-b62cc8662389.png" alt="image.png"><br><a name="pgspn"></a></p><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>公式：<br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/6b6d76946fe54be4b3057c06487abf03.svg" alt="image.png"><br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664467409312-d330df3d-06a5-410f-a57a-9d76e0ccc733.png" alt="image.png"><br><a name="MQufc"></a></p><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>公式</p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/e43dff128f12eb9e1f959290b6c873db.svg" alt="image.png"><br><br />其中，并非 <br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/fa0e3b48e6cf2289e98b7449bf402186.svg"> 的返回值为真，而是因为和前面的X与Y相配合，刚好形成了对应的结果<br><br /><br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664467661390-9e89045b-7a4c-4d0f-acf5-806f90e44c62.png" alt="image.png"><br />那么这种改善的好处是，减少了与门的使用</p><p><a name="KBcWd"></a></p><h3 id="串行进位（行波进位）加法器"><a href="#串行进位（行波进位）加法器" class="headerlink" title="串行进位（行波进位）加法器"></a>串行进位（行波进位）加法器</h3><ul><li>1位加法：<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/f4941249f1d11a1885789b6eae8696d4.svg" alt="image.png"></li><li>第i位加法：</li></ul><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/43267647225ac22f9d5b38f5d111a94c.svg" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664468091575-81876688-7542-418a-8b6d-4430faaec967.png" alt="image.png"></p><p><br />Cn 是2n的延迟，原因是每个延迟为2：与操作+或操作<br />Fn是2n+1的延迟，原因是，</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/ffa01558fab0e00cfdd749ec2d60f2f4.svg"><br><br />其中，</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/81083cba0c4fb4c4d3ec9ac308736a49.svg"> 额外+3 是因为F产生的延迟。需要注意的是</p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/7e7defc5e24c1284250e6c1ee1153487.svg">因此，不会产生额外的延迟<br><a name="zSccX"></a></p><h3 id="全先行进位加法器"><a href="#全先行进位加法器" class="headerlink" title="全先行进位加法器"></a>全先行进位加法器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664470369829-6e248a4c-87cc-49c6-ad9f-6272f5170136.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664470145406-a7817201-d9aa-4e33-b189-295b391eecce.png" alt="image.png" title="n个或门改为1个或门"></p><ul><li>1ty：代表的是生成信号和传播信号的生成</li><li>2ty：代表的是第i个进位信号的生成：1延迟的与运算+1延迟的或运算【与运算和或运算可以接受任意个数的参数】</li><li>3ty：代表的是第i个本位的生成：3延迟的或运算【和之前的1+2并行消耗，先计算X和Y的异或运算，经过3延迟后，C也得到了】+3延迟的或运算<br><a name="DqoPF"></a></li></ul><h3 id="部分先行进位加法器"><a href="#部分先行进位加法器" class="headerlink" title="部分先行进位加法器"></a>部分先行进位加法器</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664470171477-4aece9f3-73d1-401d-b7b0-13ef941e40d4.png" alt="image.png"></p><ul><li>3ty&#x3D;2ty+1ty</li></ul><p>在最开始时，</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/f067520d99b0a22dee9abd4241528bfb.svg" alt="image.png">此时的计算需要最初的1ty，之后，再根据计算公式可知需要2ty的延迟来生成<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/3251ead7580cfd081ce354aaaf39201e.svg"> 因此总延迟为3</p><ul><li>2ty 2ty 分别代表<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/41afffd775e4ecdc5fca82f842aa1c9b.svg" alt="image.png">和<br><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/738bcc5adfc17944d2fae6b7fa88ea40.svg">的生成</li><li>5ty &#x3D; 3ty + 2ty 其中3ty代表的则是F的生成，2ty代表最后一次进位的生成<br><a name="ZiA71"></a></li></ul><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><p><a name="yDkpT"></a></p><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664470207731-27c3d92c-f614-4a9b-8d4a-2b0b24080dbf.png" alt="image.png"></p><p><br />标注：此处的<br><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1f093cca47b2c22bde288e8322d68fa5.svg">单单第n位<br><a name="f43T5"></a></p><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664871896605-00f88e72-4afb-4038-8c5c-69c34a7e6c17.png" alt="image.png"><br><br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664871790303-9d8a4091-a940-4767-8135-00a6ca831d57.png" alt="image.png"><br><a name="Twjzd"></a></p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>二进制乘法不需要乘法表进行存储。十分方便</p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664872256196-9c3f454e-c8f4-4d30-9820-a544b539687f.png" alt="image.png"><br><br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664872573267-7c707b44-df0b-4dc5-a4ad-44ccb9d40808.png" alt="image.png"></p><p><a name="cziiN"></a></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664873083261-c5dfb876-e557-42c5-8267-8880d9263bf5.png" alt="image.png"></p><p><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664873700060-4153e091-b6ad-4e34-9db5-9e30599dd25d.png" alt="image.png"></p><p><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664873711104-44feb530-e235-43cf-8824-7c6e286fc498.png" alt="image.png"></p><p><br /><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1677227495378-49285cfa-2079-466a-aea7-983cbcde62d1.png" alt="image.png"></p><p><a name="OAWYS"></a></p><h4 id="出错"><a href="#出错" class="headerlink" title="出错"></a>出错</h4><ol><li>原码一位乘法</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664874010621-a3a12e09-883b-487e-84c0-6cc18b625b17.png" alt="image.png"></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1664876294590-608360fa-eb5e-40ad-bea8-91cd0e461fc4.png" alt="image.png"></p><p><a name="IatBN"></a></p><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p><a name="fn65V"></a></p><h4 id="原码：恢复余数法"><a href="#原码：恢复余数法" class="headerlink" title="原码：恢复余数法"></a>原码：恢复余数法</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579103517-21bc973e-b11d-4d6e-9dc4-9ff3f7a18596.png" alt="image.png"><br />余数逻辑左移是为了实现错位相减。因为手算时实际上是除数右移，而我们规定除数不移动时，则是余数左移 <br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665046084999-fcd74f9f-0fe8-47ad-86b9-488c58d7454f.png" alt="image.png"></p><p>优化：并行+硬件的节省<br />并行：<br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665046246364-e0791a34-797b-4388-89b4-9cb48fc432f3.png" alt="image.png"><br><a name="siEx8"></a></p><h4 id="原码：不恢复余数法"><a href="#原码：不恢复余数法" class="headerlink" title="原码：不恢复余数法"></a>原码：不恢复余数法</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579191990-bdda3b92-bd88-4f85-92fb-d515840a9493.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579365006-a43c0888-f001-4d5a-8fe4-87d7e335a295.png" alt="image.png"><br />若最后一步余数为负数，仍然需要恢复为正确余数<br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579436894-84f3a9d4-7811-463d-8a7a-3b44b91052d5.png" alt="image.png"></p><p><a name="Qj7E8"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>余数和被除数的符号相同</strong><br><a name="KNCuv"></a></p><h4 id="补码：不恢复余数法"><a href="#补码：不恢复余数法" class="headerlink" title="补码：不恢复余数法"></a>补码：不恢复余数法</h4><p><strong>余数和除数相减：</strong></p><ul><li>如果余数和除数的符号相同：减法</li><li>如果余数和除数的符号不同：加法</li></ul><ol><li>够减：余数和新余数的符号不能变</li><li>不够减：余数和新余数的符号改变</li></ol><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665048069773-3951cb9f-66ca-47a0-950c-61e963f6fc6b.png" alt="image.png"></p><br /><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579578780-d5692823-6614-40ad-a7b2-90686d44692f.png" alt="image.png"><br><a name="ML3zD"></a></p><h4 id="除法硬件改善"><a href="#除法硬件改善" class="headerlink" title="除法硬件改善"></a>除法硬件改善</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665047579085-5f0b98ff-e23e-4909-9617-03b56fa5a3bb.png" alt="image.png"><br><br /></p><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665047595553-58e0bc80-0076-41ca-b06a-e287844ffb3f.png" alt="image.png"><br /><strong>被除数移动了，除数就不需要移动了</strong><br><a name="xB2lR"></a></p><h4 id="除法运算总结"><a href="#除法运算总结" class="headerlink" title="除法运算总结"></a>除法运算总结</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665579646869-a44972c3-bead-470a-9bd7-42c6d1d185aa.png" alt="image.png"><br><a name="aHsWD"></a></p><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p><a name="Dob89"></a></p><h4 id="乘法溢出"><a href="#乘法溢出" class="headerlink" title="乘法溢出"></a>乘法溢出</h4><p><img src="https://blog-bed0.oss-cn-hangzhou.aliyuncs.com/1665460775408-5807ea34-f57e-4adf-a3b2-1ceb739a75cb.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
